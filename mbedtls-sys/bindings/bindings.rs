/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    storage: Storage,
    align: [Align; 0],
}

impl<Storage, Align> __BindgenBitfieldUnit<Storage, Align>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn new(storage: Storage) -> Self {
        Self { storage, align: [] }
    }

    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;

        byte & mask == mask
    }

    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());

        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];

        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };

        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }

    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        let mut val = 0;

        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }

        val
    }

    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());

        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const _LIBC_LIMITS_H_: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 27;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const MB_LEN_MAX: u32 = 16;
pub const _BITS_POSIX1_LIM_H: u32 = 1;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const NR_OPEN: u32 = 1024;
pub const NGROUPS_MAX: u32 = 65536;
pub const ARG_MAX: u32 = 131072;
pub const LINK_MAX: u32 = 127;
pub const MAX_CANON: u32 = 255;
pub const MAX_INPUT: u32 = 255;
pub const NAME_MAX: u32 = 255;
pub const PATH_MAX: u32 = 4096;
pub const PIPE_BUF: u32 = 4096;
pub const XATTR_NAME_MAX: u32 = 255;
pub const XATTR_SIZE_MAX: u32 = 65536;
pub const XATTR_LIST_MAX: u32 = 65536;
pub const RTSIG_MAX: u32 = 32;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const PTHREAD_KEYS_MAX: u32 = 1024;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const AIO_PRIO_DELTA_MAX: u32 = 20;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const DELAYTIMER_MAX: u32 = 2147483647;
pub const TTY_NAME_MAX: u32 = 32;
pub const LOGIN_NAME_MAX: u32 = 256;
pub const HOST_NAME_MAX: u32 = 64;
pub const MQ_PRIO_MAX: u32 = 32768;
pub const SEM_VALUE_MAX: u32 = 2147483647;
pub const _BITS_POSIX2_LIM_H: u32 = 1;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const COLL_WEIGHTS_MAX: u32 = 255;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const CHARCLASS_NAME_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 32767;
pub const _STDINT_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _STDIO_H: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const _BITS_LIBIO_H: u32 = 1;
pub const _BITS_G_CONFIG_H: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const _BITS_STDIO_LIM_H: u32 = 1;
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const ERR_MPI_FILE_IO_ERROR: i32 = -2;
pub const ERR_MPI_BAD_INPUT_DATA: i32 = -4;
pub const ERR_MPI_INVALID_CHARACTER: i32 = -6;
pub const ERR_MPI_BUFFER_TOO_SMALL: i32 = -8;
pub const ERR_MPI_NEGATIVE_VALUE: i32 = -10;
pub const ERR_MPI_DIVISION_BY_ZERO: i32 = -12;
pub const ERR_MPI_NOT_ACCEPTABLE: i32 = -14;
pub const ERR_MPI_ALLOC_FAILED: i32 = -16;
pub const MPI_MAX_LIMBS: u32 = 10000;
pub const MPI_WINDOW_SIZE: u32 = 6;
pub const MPI_MAX_SIZE: u32 = 1024;
pub const MPI_MAX_BITS: u32 = 8192;
pub const MPI_MAX_BITS_SCALE100: u32 = 819200;
pub const LN_2_DIV_LN_10_SCALE100: u32 = 332;
pub const MPI_RW_BUFFER_SIZE: u32 = 2484;
pub const ERR_MD_FEATURE_UNAVAILABLE: i32 = -20608;
pub const ERR_MD_BAD_INPUT_DATA: i32 = -20736;
pub const ERR_MD_ALLOC_FAILED: i32 = -20864;
pub const ERR_MD_FILE_IO_ERROR: i32 = -20992;
pub const ERR_MD_HW_ACCEL_FAILED: i32 = -21120;
pub const MD_MAX_SIZE: u32 = 64;
pub const _STDLIB_H: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WSTOPPED: u32 = 2;
pub const WEXITED: u32 = 4;
pub const WCONTINUED: u32 = 8;
pub const WNOWAIT: u32 = 16777216;
pub const __WNOTHREAD: u32 = 536870912;
pub const __WALL: u32 = 1073741824;
pub const __WCLONE: u32 = 2147483648;
pub const __ENUM_IDTYPE_T: u32 = 1;
pub const __W_CONTINUED: u32 = 65535;
pub const __WCOREFLAG: u32 = 128;
pub const __HAVE_FLOAT128: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128: u32 = 0;
pub const __HAVE_FLOAT64X: u32 = 1;
pub const __HAVE_FLOAT64X_LONG_DOUBLE: u32 = 1;
pub const __HAVE_FLOAT16: u32 = 0;
pub const __HAVE_FLOAT32: u32 = 1;
pub const __HAVE_FLOAT64: u32 = 1;
pub const __HAVE_FLOAT32X: u32 = 1;
pub const __HAVE_FLOAT128X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT16: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT32X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT64X: u32 = 0;
pub const __HAVE_DISTINCT_FLOAT128X: u32 = 0;
pub const __HAVE_FLOATN_NOT_TYPEDEF: u32 = 0;
pub const __ldiv_t_defined: u32 = 1;
pub const __lldiv_t_defined: u32 = 1;
pub const RAND_MAX: u32 = 2147483647;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const _SYS_TYPES_H: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const __BIT_TYPES_DEFINED__: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_UINTN_IDENTITY_H: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const __FD_ZERO_STOS: &'static [u8; 6usize] = b"stosq\0";
pub const __sigset_t_defined: u32 = 1;
pub const __timeval_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const _SYS_SYSMACROS_H: u32 = 1;
pub const _BITS_SYSMACROS_H: u32 = 1;
pub const _BITS_PTHREADTYPES_COMMON_H: u32 = 1;
pub const _THREAD_SHARED_TYPES_H: u32 = 1;
pub const _BITS_PTHREADTYPES_ARCH_H: u32 = 1;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 40;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 56;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 56;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 32;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __PTHREAD_MUTEX_LOCK_ELISION: u32 = 1;
pub const __PTHREAD_MUTEX_NUSERS_AFTER_KIND: u32 = 0;
pub const __PTHREAD_MUTEX_USE_UNION: u32 = 0;
pub const __PTHREAD_RWLOCK_INT_FLAGS_SHARED: u32 = 1;
pub const __PTHREAD_MUTEX_HAVE_PREV: u32 = 1;
pub const __have_pthread_attr_t: u32 = 1;
pub const _ALLOCA_H: u32 = 1;
pub const ERR_THREADING_FEATURE_UNAVAILABLE: i32 = -26;
pub const ERR_THREADING_BAD_INPUT_DATA: i32 = -28;
pub const ERR_THREADING_MUTEX_ERROR: i32 = -30;
pub const _PTHREAD_H: u32 = 1;
pub const _SCHED_H: u32 = 1;
pub const _BITS_SCHED_H: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const _BITS_CPU_SET_H: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __struct_tm_defined: u32 = 1;
pub const __itimerspec_defined: u32 = 1;
pub const _BITS_TYPES_LOCALE_T_H: u32 = 1;
pub const _BITS_TYPES___LOCALE_T_H: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const ERR_ECP_BAD_INPUT_DATA: i32 = -20352;
pub const ERR_ECP_BUFFER_TOO_SMALL: i32 = -20224;
pub const ERR_ECP_FEATURE_UNAVAILABLE: i32 = -20096;
pub const ERR_ECP_VERIFY_FAILED: i32 = -19968;
pub const ERR_ECP_ALLOC_FAILED: i32 = -19840;
pub const ERR_ECP_RANDOM_FAILED: i32 = -19712;
pub const ERR_ECP_INVALID_KEY: i32 = -19584;
pub const ERR_ECP_SIG_LEN_MISMATCH: i32 = -19456;
pub const ERR_ECP_HW_ACCEL_FAILED: i32 = -19328;
pub const ERR_ECP_IN_PROGRESS: i32 = -19200;
pub const ECP_DP_MAX: u32 = 12;
pub const ECP_MAX_BITS: u32 = 521;
pub const ECP_MAX_BYTES: u32 = 66;
pub const ECP_MAX_PT_LEN: u32 = 133;
pub const ECP_WINDOW_SIZE: u32 = 6;
pub const ECP_FIXED_POINT_OPTIM: u32 = 1;
pub const ECP_PF_UNCOMPRESSED: raw_types::c_int = 0;
pub const ECP_PF_COMPRESSED: raw_types::c_int = 1;
pub const ECP_TLS_NAMED_CURVE: u32 = 3;
pub const ERR_RSA_BAD_INPUT_DATA: i32 = -16512;
pub const ERR_RSA_INVALID_PADDING: i32 = -16640;
pub const ERR_RSA_KEY_GEN_FAILED: i32 = -16768;
pub const ERR_RSA_KEY_CHECK_FAILED: i32 = -16896;
pub const ERR_RSA_PUBLIC_FAILED: i32 = -17024;
pub const ERR_RSA_PRIVATE_FAILED: i32 = -17152;
pub const ERR_RSA_VERIFY_FAILED: i32 = -17280;
pub const ERR_RSA_OUTPUT_TOO_LARGE: i32 = -17408;
pub const ERR_RSA_RNG_FAILED: i32 = -17536;
pub const ERR_RSA_UNSUPPORTED_OPERATION: i32 = -17664;
pub const ERR_RSA_HW_ACCEL_FAILED: i32 = -17792;
pub const RSA_PUBLIC: u32 = 0;
pub const RSA_PRIVATE: u32 = 1;
pub const RSA_PKCS_V15: raw_types::c_int = 0;
pub const RSA_PKCS_V21: raw_types::c_int = 1;
pub const RSA_SIGN: u32 = 1;
pub const RSA_CRYPT: u32 = 2;
pub const RSA_SALT_LEN_ANY: i32 = -1;
pub const ECDSA_MAX_LEN: u32 = 141;
pub const ERR_ASN1_OUT_OF_DATA: i32 = -96;
pub const ERR_ASN1_UNEXPECTED_TAG: i32 = -98;
pub const ERR_ASN1_INVALID_LENGTH: i32 = -100;
pub const ERR_ASN1_LENGTH_MISMATCH: i32 = -102;
pub const ERR_ASN1_INVALID_DATA: i32 = -104;
pub const ERR_ASN1_ALLOC_FAILED: i32 = -106;
pub const ERR_ASN1_BUF_TOO_SMALL: i32 = -108;
pub const ASN1_BOOLEAN: u32 = 1;
pub const ASN1_INTEGER: u32 = 2;
pub const ASN1_BIT_STRING: u32 = 3;
pub const ASN1_OCTET_STRING: u32 = 4;
pub const ASN1_NULL: u32 = 5;
pub const ASN1_OID: u32 = 6;
pub const ASN1_UTF8_STRING: u32 = 12;
pub const ASN1_SEQUENCE: u32 = 16;
pub const ASN1_SET: u32 = 17;
pub const ASN1_PRINTABLE_STRING: u32 = 19;
pub const ASN1_T61_STRING: u32 = 20;
pub const ASN1_IA5_STRING: u32 = 22;
pub const ASN1_UTC_TIME: u32 = 23;
pub const ASN1_GENERALIZED_TIME: u32 = 24;
pub const ASN1_UNIVERSAL_STRING: u32 = 28;
pub const ASN1_BMP_STRING: u32 = 30;
pub const ASN1_PRIMITIVE: u32 = 0;
pub const ASN1_CONSTRUCTED: u32 = 32;
pub const ASN1_CONTEXT_SPECIFIC: u32 = 128;
pub const ASN1_TAG_CLASS_MASK: u32 = 192;
pub const ASN1_TAG_PC_MASK: u32 = 32;
pub const ASN1_TAG_VALUE_MASK: u32 = 31;
pub const ERR_PK_ALLOC_FAILED: i32 = -16256;
pub const ERR_PK_TYPE_MISMATCH: i32 = -16128;
pub const ERR_PK_BAD_INPUT_DATA: i32 = -16000;
pub const ERR_PK_FILE_IO_ERROR: i32 = -15872;
pub const ERR_PK_KEY_INVALID_VERSION: i32 = -15744;
pub const ERR_PK_KEY_INVALID_FORMAT: i32 = -15616;
pub const ERR_PK_UNKNOWN_PK_ALG: i32 = -15488;
pub const ERR_PK_PASSWORD_REQUIRED: i32 = -15360;
pub const ERR_PK_PASSWORD_MISMATCH: i32 = -15232;
pub const ERR_PK_INVALID_PUBKEY: i32 = -15104;
pub const ERR_PK_INVALID_ALG: i32 = -14976;
pub const ERR_PK_UNKNOWN_NAMED_CURVE: i32 = -14848;
pub const ERR_PK_FEATURE_UNAVAILABLE: i32 = -14720;
pub const ERR_PK_SIG_LEN_MISMATCH: i32 = -14592;
pub const ERR_PK_HW_ACCEL_FAILED: i32 = -14464;
pub const PK_DEBUG_MAX_ITEMS: u32 = 3;
pub const X509_MAX_INTERMEDIATE_CA: u32 = 8;
pub const ERR_X509_FEATURE_UNAVAILABLE: i32 = -8320;
pub const ERR_X509_UNKNOWN_OID: i32 = -8448;
pub const ERR_X509_INVALID_FORMAT: i32 = -8576;
pub const ERR_X509_INVALID_VERSION: i32 = -8704;
pub const ERR_X509_INVALID_SERIAL: i32 = -8832;
pub const ERR_X509_INVALID_ALG: i32 = -8960;
pub const ERR_X509_INVALID_NAME: i32 = -9088;
pub const ERR_X509_INVALID_DATE: i32 = -9216;
pub const ERR_X509_INVALID_SIGNATURE: i32 = -9344;
pub const ERR_X509_INVALID_EXTENSIONS: i32 = -9472;
pub const ERR_X509_UNKNOWN_VERSION: i32 = -9600;
pub const ERR_X509_UNKNOWN_SIG_ALG: i32 = -9728;
pub const ERR_X509_SIG_MISMATCH: i32 = -9856;
pub const ERR_X509_CERT_VERIFY_FAILED: i32 = -9984;
pub const ERR_X509_CERT_UNKNOWN_FORMAT: i32 = -10112;
pub const ERR_X509_BAD_INPUT_DATA: i32 = -10240;
pub const ERR_X509_ALLOC_FAILED: i32 = -10368;
pub const ERR_X509_FILE_IO_ERROR: i32 = -10496;
pub const ERR_X509_BUFFER_TOO_SMALL: i32 = -10624;
pub const ERR_X509_FATAL_ERROR: i32 = -12288;
pub const X509_BADCERT_EXPIRED: u32 = 1;
pub const X509_BADCERT_REVOKED: u32 = 2;
pub const X509_BADCERT_CN_MISMATCH: u32 = 4;
pub const X509_BADCERT_NOT_TRUSTED: u32 = 8;
pub const X509_BADCRL_NOT_TRUSTED: u32 = 16;
pub const X509_BADCRL_EXPIRED: u32 = 32;
pub const X509_BADCERT_MISSING: u32 = 64;
pub const X509_BADCERT_SKIP_VERIFY: u32 = 128;
pub const X509_BADCERT_OTHER: u32 = 256;
pub const X509_BADCERT_FUTURE: u32 = 512;
pub const X509_BADCRL_FUTURE: u32 = 1024;
pub const X509_BADCERT_KEY_USAGE: u32 = 2048;
pub const X509_BADCERT_EXT_KEY_USAGE: u32 = 4096;
pub const X509_BADCERT_NS_CERT_TYPE: u32 = 8192;
pub const X509_BADCERT_BAD_MD: u32 = 16384;
pub const X509_BADCERT_BAD_PK: u32 = 32768;
pub const X509_BADCERT_BAD_KEY: u32 = 65536;
pub const X509_BADCRL_BAD_MD: u32 = 131072;
pub const X509_BADCRL_BAD_PK: u32 = 262144;
pub const X509_BADCRL_BAD_KEY: u32 = 524288;
pub const X509_KU_DIGITAL_SIGNATURE: u32 = 128;
pub const X509_KU_NON_REPUDIATION: u32 = 64;
pub const X509_KU_KEY_ENCIPHERMENT: u32 = 32;
pub const X509_KU_DATA_ENCIPHERMENT: u32 = 16;
pub const X509_KU_KEY_AGREEMENT: u32 = 8;
pub const X509_KU_KEY_CERT_SIGN: u32 = 4;
pub const X509_KU_CRL_SIGN: u32 = 2;
pub const X509_KU_ENCIPHER_ONLY: u32 = 1;
pub const X509_KU_DECIPHER_ONLY: u32 = 32768;
pub const X509_NS_CERT_TYPE_SSL_CLIENT: u32 = 128;
pub const X509_NS_CERT_TYPE_SSL_SERVER: u32 = 64;
pub const X509_NS_CERT_TYPE_EMAIL: u32 = 32;
pub const X509_NS_CERT_TYPE_OBJECT_SIGNING: u32 = 16;
pub const X509_NS_CERT_TYPE_RESERVED: u32 = 8;
pub const X509_NS_CERT_TYPE_SSL_CA: u32 = 4;
pub const X509_NS_CERT_TYPE_EMAIL_CA: u32 = 2;
pub const X509_NS_CERT_TYPE_OBJECT_SIGNING_CA: u32 = 1;
pub const X509_EXT_AUTHORITY_KEY_IDENTIFIER: u32 = 1;
pub const X509_EXT_SUBJECT_KEY_IDENTIFIER: u32 = 2;
pub const X509_EXT_KEY_USAGE: u32 = 4;
pub const X509_EXT_CERTIFICATE_POLICIES: u32 = 8;
pub const X509_EXT_POLICY_MAPPINGS: u32 = 16;
pub const X509_EXT_SUBJECT_ALT_NAME: u32 = 32;
pub const X509_EXT_ISSUER_ALT_NAME: u32 = 64;
pub const X509_EXT_SUBJECT_DIRECTORY_ATTRS: u32 = 128;
pub const X509_EXT_BASIC_CONSTRAINTS: u32 = 256;
pub const X509_EXT_NAME_CONSTRAINTS: u32 = 512;
pub const X509_EXT_POLICY_CONSTRAINTS: u32 = 1024;
pub const X509_EXT_EXTENDED_KEY_USAGE: u32 = 2048;
pub const X509_EXT_CRL_DISTRIBUTION_POINTS: u32 = 4096;
pub const X509_EXT_INIHIBIT_ANYPOLICY: u32 = 8192;
pub const X509_EXT_FRESHEST_CRL: u32 = 16384;
pub const X509_EXT_NS_CERT_TYPE: u32 = 65536;
pub const X509_FORMAT_DER: u32 = 1;
pub const X509_FORMAT_PEM: u32 = 2;
pub const X509_MAX_DN_NAME_SIZE: u32 = 256;
pub const ERR_CIPHER_FEATURE_UNAVAILABLE: i32 = -24704;
pub const ERR_CIPHER_BAD_INPUT_DATA: i32 = -24832;
pub const ERR_CIPHER_ALLOC_FAILED: i32 = -24960;
pub const ERR_CIPHER_INVALID_PADDING: i32 = -25088;
pub const ERR_CIPHER_FULL_BLOCK_EXPECTED: i32 = -25216;
pub const ERR_CIPHER_AUTH_FAILED: i32 = -25344;
pub const ERR_CIPHER_INVALID_CONTEXT: i32 = -25472;
pub const ERR_CIPHER_HW_ACCEL_FAILED: i32 = -25600;
pub const CIPHER_VARIABLE_IV_LEN: u32 = 1;
pub const CIPHER_VARIABLE_KEY_LEN: u32 = 2;
pub const MAX_IV_LENGTH: u32 = 16;
pub const MAX_BLOCK_LENGTH: u32 = 16;
pub const TLS_RSA_WITH_NULL_MD5: raw_types::c_int = 1;
pub const TLS_RSA_WITH_NULL_SHA: raw_types::c_int = 2;
pub const TLS_RSA_WITH_RC4_128_MD5: raw_types::c_int = 4;
pub const TLS_RSA_WITH_RC4_128_SHA: raw_types::c_int = 5;
pub const TLS_RSA_WITH_DES_CBC_SHA: raw_types::c_int = 9;
pub const TLS_RSA_WITH_3DES_EDE_CBC_SHA: raw_types::c_int = 10;
pub const TLS_DHE_RSA_WITH_DES_CBC_SHA: raw_types::c_int = 21;
pub const TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA: raw_types::c_int = 22;
pub const TLS_PSK_WITH_NULL_SHA: raw_types::c_int = 44;
pub const TLS_DHE_PSK_WITH_NULL_SHA: raw_types::c_int = 45;
pub const TLS_RSA_PSK_WITH_NULL_SHA: raw_types::c_int = 46;
pub const TLS_RSA_WITH_AES_128_CBC_SHA: raw_types::c_int = 47;
pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA: raw_types::c_int = 51;
pub const TLS_RSA_WITH_AES_256_CBC_SHA: raw_types::c_int = 53;
pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA: raw_types::c_int = 57;
pub const TLS_RSA_WITH_NULL_SHA256: raw_types::c_int = 59;
pub const TLS_RSA_WITH_AES_128_CBC_SHA256: raw_types::c_int = 60;
pub const TLS_RSA_WITH_AES_256_CBC_SHA256: raw_types::c_int = 61;
pub const TLS_RSA_WITH_CAMELLIA_128_CBC_SHA: raw_types::c_int = 65;
pub const TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA: raw_types::c_int = 69;
pub const TLS_DHE_RSA_WITH_AES_128_CBC_SHA256: raw_types::c_int = 103;
pub const TLS_DHE_RSA_WITH_AES_256_CBC_SHA256: raw_types::c_int = 107;
pub const TLS_RSA_WITH_CAMELLIA_256_CBC_SHA: raw_types::c_int = 132;
pub const TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA: raw_types::c_int = 136;
pub const TLS_PSK_WITH_RC4_128_SHA: raw_types::c_int = 138;
pub const TLS_PSK_WITH_3DES_EDE_CBC_SHA: raw_types::c_int = 139;
pub const TLS_PSK_WITH_AES_128_CBC_SHA: raw_types::c_int = 140;
pub const TLS_PSK_WITH_AES_256_CBC_SHA: raw_types::c_int = 141;
pub const TLS_DHE_PSK_WITH_RC4_128_SHA: raw_types::c_int = 142;
pub const TLS_DHE_PSK_WITH_3DES_EDE_CBC_SHA: raw_types::c_int = 143;
pub const TLS_DHE_PSK_WITH_AES_128_CBC_SHA: raw_types::c_int = 144;
pub const TLS_DHE_PSK_WITH_AES_256_CBC_SHA: raw_types::c_int = 145;
pub const TLS_RSA_PSK_WITH_RC4_128_SHA: raw_types::c_int = 146;
pub const TLS_RSA_PSK_WITH_3DES_EDE_CBC_SHA: raw_types::c_int = 147;
pub const TLS_RSA_PSK_WITH_AES_128_CBC_SHA: raw_types::c_int = 148;
pub const TLS_RSA_PSK_WITH_AES_256_CBC_SHA: raw_types::c_int = 149;
pub const TLS_RSA_WITH_AES_128_GCM_SHA256: raw_types::c_int = 156;
pub const TLS_RSA_WITH_AES_256_GCM_SHA384: raw_types::c_int = 157;
pub const TLS_DHE_RSA_WITH_AES_128_GCM_SHA256: raw_types::c_int = 158;
pub const TLS_DHE_RSA_WITH_AES_256_GCM_SHA384: raw_types::c_int = 159;
pub const TLS_PSK_WITH_AES_128_GCM_SHA256: raw_types::c_int = 168;
pub const TLS_PSK_WITH_AES_256_GCM_SHA384: raw_types::c_int = 169;
pub const TLS_DHE_PSK_WITH_AES_128_GCM_SHA256: raw_types::c_int = 170;
pub const TLS_DHE_PSK_WITH_AES_256_GCM_SHA384: raw_types::c_int = 171;
pub const TLS_RSA_PSK_WITH_AES_128_GCM_SHA256: raw_types::c_int = 172;
pub const TLS_RSA_PSK_WITH_AES_256_GCM_SHA384: raw_types::c_int = 173;
pub const TLS_PSK_WITH_AES_128_CBC_SHA256: raw_types::c_int = 174;
pub const TLS_PSK_WITH_AES_256_CBC_SHA384: raw_types::c_int = 175;
pub const TLS_PSK_WITH_NULL_SHA256: raw_types::c_int = 176;
pub const TLS_PSK_WITH_NULL_SHA384: raw_types::c_int = 177;
pub const TLS_DHE_PSK_WITH_AES_128_CBC_SHA256: raw_types::c_int = 178;
pub const TLS_DHE_PSK_WITH_AES_256_CBC_SHA384: raw_types::c_int = 179;
pub const TLS_DHE_PSK_WITH_NULL_SHA256: raw_types::c_int = 180;
pub const TLS_DHE_PSK_WITH_NULL_SHA384: raw_types::c_int = 181;
pub const TLS_RSA_PSK_WITH_AES_128_CBC_SHA256: raw_types::c_int = 182;
pub const TLS_RSA_PSK_WITH_AES_256_CBC_SHA384: raw_types::c_int = 183;
pub const TLS_RSA_PSK_WITH_NULL_SHA256: raw_types::c_int = 184;
pub const TLS_RSA_PSK_WITH_NULL_SHA384: raw_types::c_int = 185;
pub const TLS_RSA_WITH_CAMELLIA_128_CBC_SHA256: raw_types::c_int = 186;
pub const TLS_DHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: raw_types::c_int = 190;
pub const TLS_RSA_WITH_CAMELLIA_256_CBC_SHA256: raw_types::c_int = 192;
pub const TLS_DHE_RSA_WITH_CAMELLIA_256_CBC_SHA256: raw_types::c_int = 196;
pub const TLS_ECDH_ECDSA_WITH_NULL_SHA: raw_types::c_int = 49153;
pub const TLS_ECDH_ECDSA_WITH_RC4_128_SHA: raw_types::c_int = 49154;
pub const TLS_ECDH_ECDSA_WITH_3DES_EDE_CBC_SHA: raw_types::c_int = 49155;
pub const TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA: raw_types::c_int = 49156;
pub const TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA: raw_types::c_int = 49157;
pub const TLS_ECDHE_ECDSA_WITH_NULL_SHA: raw_types::c_int = 49158;
pub const TLS_ECDHE_ECDSA_WITH_RC4_128_SHA: raw_types::c_int = 49159;
pub const TLS_ECDHE_ECDSA_WITH_3DES_EDE_CBC_SHA: raw_types::c_int = 49160;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA: raw_types::c_int = 49161;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA: raw_types::c_int = 49162;
pub const TLS_ECDH_RSA_WITH_NULL_SHA: raw_types::c_int = 49163;
pub const TLS_ECDH_RSA_WITH_RC4_128_SHA: raw_types::c_int = 49164;
pub const TLS_ECDH_RSA_WITH_3DES_EDE_CBC_SHA: raw_types::c_int = 49165;
pub const TLS_ECDH_RSA_WITH_AES_128_CBC_SHA: raw_types::c_int = 49166;
pub const TLS_ECDH_RSA_WITH_AES_256_CBC_SHA: raw_types::c_int = 49167;
pub const TLS_ECDHE_RSA_WITH_NULL_SHA: raw_types::c_int = 49168;
pub const TLS_ECDHE_RSA_WITH_RC4_128_SHA: raw_types::c_int = 49169;
pub const TLS_ECDHE_RSA_WITH_3DES_EDE_CBC_SHA: raw_types::c_int = 49170;
pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA: raw_types::c_int = 49171;
pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA: raw_types::c_int = 49172;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256: raw_types::c_int = 49187;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384: raw_types::c_int = 49188;
pub const TLS_ECDH_ECDSA_WITH_AES_128_CBC_SHA256: raw_types::c_int = 49189;
pub const TLS_ECDH_ECDSA_WITH_AES_256_CBC_SHA384: raw_types::c_int = 49190;
pub const TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256: raw_types::c_int = 49191;
pub const TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384: raw_types::c_int = 49192;
pub const TLS_ECDH_RSA_WITH_AES_128_CBC_SHA256: raw_types::c_int = 49193;
pub const TLS_ECDH_RSA_WITH_AES_256_CBC_SHA384: raw_types::c_int = 49194;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256: raw_types::c_int = 49195;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384: raw_types::c_int = 49196;
pub const TLS_ECDH_ECDSA_WITH_AES_128_GCM_SHA256: raw_types::c_int = 49197;
pub const TLS_ECDH_ECDSA_WITH_AES_256_GCM_SHA384: raw_types::c_int = 49198;
pub const TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256: raw_types::c_int = 49199;
pub const TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384: raw_types::c_int = 49200;
pub const TLS_ECDH_RSA_WITH_AES_128_GCM_SHA256: raw_types::c_int = 49201;
pub const TLS_ECDH_RSA_WITH_AES_256_GCM_SHA384: raw_types::c_int = 49202;
pub const TLS_ECDHE_PSK_WITH_RC4_128_SHA: raw_types::c_int = 49203;
pub const TLS_ECDHE_PSK_WITH_3DES_EDE_CBC_SHA: raw_types::c_int = 49204;
pub const TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA: raw_types::c_int = 49205;
pub const TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA: raw_types::c_int = 49206;
pub const TLS_ECDHE_PSK_WITH_AES_128_CBC_SHA256: raw_types::c_int = 49207;
pub const TLS_ECDHE_PSK_WITH_AES_256_CBC_SHA384: raw_types::c_int = 49208;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA: raw_types::c_int = 49209;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA256: raw_types::c_int = 49210;
pub const TLS_ECDHE_PSK_WITH_NULL_SHA384: raw_types::c_int = 49211;
pub const TLS_RSA_WITH_ARIA_128_CBC_SHA256: raw_types::c_int = 49212;
pub const TLS_RSA_WITH_ARIA_256_CBC_SHA384: raw_types::c_int = 49213;
pub const TLS_DHE_RSA_WITH_ARIA_128_CBC_SHA256: raw_types::c_int = 49220;
pub const TLS_DHE_RSA_WITH_ARIA_256_CBC_SHA384: raw_types::c_int = 49221;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_128_CBC_SHA256: raw_types::c_int = 49224;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_256_CBC_SHA384: raw_types::c_int = 49225;
pub const TLS_ECDH_ECDSA_WITH_ARIA_128_CBC_SHA256: raw_types::c_int = 49226;
pub const TLS_ECDH_ECDSA_WITH_ARIA_256_CBC_SHA384: raw_types::c_int = 49227;
pub const TLS_ECDHE_RSA_WITH_ARIA_128_CBC_SHA256: raw_types::c_int = 49228;
pub const TLS_ECDHE_RSA_WITH_ARIA_256_CBC_SHA384: raw_types::c_int = 49229;
pub const TLS_ECDH_RSA_WITH_ARIA_128_CBC_SHA256: raw_types::c_int = 49230;
pub const TLS_ECDH_RSA_WITH_ARIA_256_CBC_SHA384: raw_types::c_int = 49231;
pub const TLS_RSA_WITH_ARIA_128_GCM_SHA256: raw_types::c_int = 49232;
pub const TLS_RSA_WITH_ARIA_256_GCM_SHA384: raw_types::c_int = 49233;
pub const TLS_DHE_RSA_WITH_ARIA_128_GCM_SHA256: raw_types::c_int = 49234;
pub const TLS_DHE_RSA_WITH_ARIA_256_GCM_SHA384: raw_types::c_int = 49235;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_128_GCM_SHA256: raw_types::c_int = 49244;
pub const TLS_ECDHE_ECDSA_WITH_ARIA_256_GCM_SHA384: raw_types::c_int = 49245;
pub const TLS_ECDH_ECDSA_WITH_ARIA_128_GCM_SHA256: raw_types::c_int = 49246;
pub const TLS_ECDH_ECDSA_WITH_ARIA_256_GCM_SHA384: raw_types::c_int = 49247;
pub const TLS_ECDHE_RSA_WITH_ARIA_128_GCM_SHA256: raw_types::c_int = 49248;
pub const TLS_ECDHE_RSA_WITH_ARIA_256_GCM_SHA384: raw_types::c_int = 49249;
pub const TLS_ECDH_RSA_WITH_ARIA_128_GCM_SHA256: raw_types::c_int = 49250;
pub const TLS_ECDH_RSA_WITH_ARIA_256_GCM_SHA384: raw_types::c_int = 49251;
pub const TLS_PSK_WITH_ARIA_128_CBC_SHA256: raw_types::c_int = 49252;
pub const TLS_PSK_WITH_ARIA_256_CBC_SHA384: raw_types::c_int = 49253;
pub const TLS_DHE_PSK_WITH_ARIA_128_CBC_SHA256: raw_types::c_int = 49254;
pub const TLS_DHE_PSK_WITH_ARIA_256_CBC_SHA384: raw_types::c_int = 49255;
pub const TLS_RSA_PSK_WITH_ARIA_128_CBC_SHA256: raw_types::c_int = 49256;
pub const TLS_RSA_PSK_WITH_ARIA_256_CBC_SHA384: raw_types::c_int = 49257;
pub const TLS_PSK_WITH_ARIA_128_GCM_SHA256: raw_types::c_int = 49258;
pub const TLS_PSK_WITH_ARIA_256_GCM_SHA384: raw_types::c_int = 49259;
pub const TLS_DHE_PSK_WITH_ARIA_128_GCM_SHA256: raw_types::c_int = 49260;
pub const TLS_DHE_PSK_WITH_ARIA_256_GCM_SHA384: raw_types::c_int = 49261;
pub const TLS_RSA_PSK_WITH_ARIA_128_GCM_SHA256: raw_types::c_int = 49262;
pub const TLS_RSA_PSK_WITH_ARIA_256_GCM_SHA384: raw_types::c_int = 49263;
pub const TLS_ECDHE_PSK_WITH_ARIA_128_CBC_SHA256: raw_types::c_int = 49264;
pub const TLS_ECDHE_PSK_WITH_ARIA_256_CBC_SHA384: raw_types::c_int = 49265;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: raw_types::c_int = 49266;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: raw_types::c_int = 49267;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_128_CBC_SHA256: raw_types::c_int = 49268;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_256_CBC_SHA384: raw_types::c_int = 49269;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_128_CBC_SHA256: raw_types::c_int = 49270;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_256_CBC_SHA384: raw_types::c_int = 49271;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_128_CBC_SHA256: raw_types::c_int = 49272;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_256_CBC_SHA384: raw_types::c_int = 49273;
pub const TLS_RSA_WITH_CAMELLIA_128_GCM_SHA256: raw_types::c_int = 49274;
pub const TLS_RSA_WITH_CAMELLIA_256_GCM_SHA384: raw_types::c_int = 49275;
pub const TLS_DHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: raw_types::c_int = 49276;
pub const TLS_DHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: raw_types::c_int = 49277;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: raw_types::c_int = 49286;
pub const TLS_ECDHE_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: raw_types::c_int = 49287;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_128_GCM_SHA256: raw_types::c_int = 49288;
pub const TLS_ECDH_ECDSA_WITH_CAMELLIA_256_GCM_SHA384: raw_types::c_int = 49289;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_128_GCM_SHA256: raw_types::c_int = 49290;
pub const TLS_ECDHE_RSA_WITH_CAMELLIA_256_GCM_SHA384: raw_types::c_int = 49291;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_128_GCM_SHA256: raw_types::c_int = 49292;
pub const TLS_ECDH_RSA_WITH_CAMELLIA_256_GCM_SHA384: raw_types::c_int = 49293;
pub const TLS_PSK_WITH_CAMELLIA_128_GCM_SHA256: raw_types::c_int = 49294;
pub const TLS_PSK_WITH_CAMELLIA_256_GCM_SHA384: raw_types::c_int = 49295;
pub const TLS_DHE_PSK_WITH_CAMELLIA_128_GCM_SHA256: raw_types::c_int = 49296;
pub const TLS_DHE_PSK_WITH_CAMELLIA_256_GCM_SHA384: raw_types::c_int = 49297;
pub const TLS_RSA_PSK_WITH_CAMELLIA_128_GCM_SHA256: raw_types::c_int = 49298;
pub const TLS_RSA_PSK_WITH_CAMELLIA_256_GCM_SHA384: raw_types::c_int = 49299;
pub const TLS_PSK_WITH_CAMELLIA_128_CBC_SHA256: raw_types::c_int = 49300;
pub const TLS_PSK_WITH_CAMELLIA_256_CBC_SHA384: raw_types::c_int = 49301;
pub const TLS_DHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: raw_types::c_int = 49302;
pub const TLS_DHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: raw_types::c_int = 49303;
pub const TLS_RSA_PSK_WITH_CAMELLIA_128_CBC_SHA256: raw_types::c_int = 49304;
pub const TLS_RSA_PSK_WITH_CAMELLIA_256_CBC_SHA384: raw_types::c_int = 49305;
pub const TLS_ECDHE_PSK_WITH_CAMELLIA_128_CBC_SHA256: raw_types::c_int = 49306;
pub const TLS_ECDHE_PSK_WITH_CAMELLIA_256_CBC_SHA384: raw_types::c_int = 49307;
pub const TLS_RSA_WITH_AES_128_CCM: raw_types::c_int = 49308;
pub const TLS_RSA_WITH_AES_256_CCM: raw_types::c_int = 49309;
pub const TLS_DHE_RSA_WITH_AES_128_CCM: raw_types::c_int = 49310;
pub const TLS_DHE_RSA_WITH_AES_256_CCM: raw_types::c_int = 49311;
pub const TLS_RSA_WITH_AES_128_CCM_8: raw_types::c_int = 49312;
pub const TLS_RSA_WITH_AES_256_CCM_8: raw_types::c_int = 49313;
pub const TLS_DHE_RSA_WITH_AES_128_CCM_8: raw_types::c_int = 49314;
pub const TLS_DHE_RSA_WITH_AES_256_CCM_8: raw_types::c_int = 49315;
pub const TLS_PSK_WITH_AES_128_CCM: raw_types::c_int = 49316;
pub const TLS_PSK_WITH_AES_256_CCM: raw_types::c_int = 49317;
pub const TLS_DHE_PSK_WITH_AES_128_CCM: raw_types::c_int = 49318;
pub const TLS_DHE_PSK_WITH_AES_256_CCM: raw_types::c_int = 49319;
pub const TLS_PSK_WITH_AES_128_CCM_8: raw_types::c_int = 49320;
pub const TLS_PSK_WITH_AES_256_CCM_8: raw_types::c_int = 49321;
pub const TLS_DHE_PSK_WITH_AES_128_CCM_8: raw_types::c_int = 49322;
pub const TLS_DHE_PSK_WITH_AES_256_CCM_8: raw_types::c_int = 49323;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CCM: raw_types::c_int = 49324;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CCM: raw_types::c_int = 49325;
pub const TLS_ECDHE_ECDSA_WITH_AES_128_CCM_8: raw_types::c_int = 49326;
pub const TLS_ECDHE_ECDSA_WITH_AES_256_CCM_8: raw_types::c_int = 49327;
pub const TLS_ECJPAKE_WITH_AES_128_CCM_8: raw_types::c_int = 49407;
pub const TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256: raw_types::c_int = 52392;
pub const TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256: raw_types::c_int = 52393;
pub const TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256: raw_types::c_int = 52394;
pub const TLS_PSK_WITH_CHACHA20_POLY1305_SHA256: raw_types::c_int = 52395;
pub const TLS_ECDHE_PSK_WITH_CHACHA20_POLY1305_SHA256: raw_types::c_int = 52396;
pub const TLS_DHE_PSK_WITH_CHACHA20_POLY1305_SHA256: raw_types::c_int = 52397;
pub const TLS_RSA_PSK_WITH_CHACHA20_POLY1305_SHA256: raw_types::c_int = 52398;
pub const CIPHERSUITE_WEAK: u32 = 1;
pub const CIPHERSUITE_SHORT_TAG: u32 = 2;
pub const CIPHERSUITE_NODTLS: u32 = 4;
pub const X509_CRT_VERSION_1: u32 = 0;
pub const X509_CRT_VERSION_2: u32 = 1;
pub const X509_CRT_VERSION_3: u32 = 2;
pub const X509_RFC5280_MAX_SERIAL_LEN: u32 = 32;
pub const X509_RFC5280_UTC_TIME_LEN: u32 = 15;
pub const X509_MAX_FILE_PATH_LEN: u32 = 512;
pub const X509_MAX_VERIFY_CHAIN_SIZE: u32 = 10;
pub const ERR_DHM_BAD_INPUT_DATA: i32 = -12416;
pub const ERR_DHM_READ_PARAMS_FAILED: i32 = -12544;
pub const ERR_DHM_MAKE_PARAMS_FAILED: i32 = -12672;
pub const ERR_DHM_READ_PUBLIC_FAILED: i32 = -12800;
pub const ERR_DHM_MAKE_PUBLIC_FAILED: i32 = -12928;
pub const ERR_DHM_CALC_SECRET_FAILED: i32 = -13056;
pub const ERR_DHM_INVALID_FORMAT: i32 = -13184;
pub const ERR_DHM_ALLOC_FAILED: i32 = -13312;
pub const ERR_DHM_FILE_IO_ERROR: i32 = -13440;
pub const ERR_DHM_HW_ACCEL_FAILED: i32 = -13568;
pub const ERR_DHM_SET_GROUP_FAILED: i32 = -13696;
pub const MAX_MEM_LEVEL: u32 = 9;
pub const MAX_WBITS: u32 = 15;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V6_LPBIG_OFFBIG: i32 = -1;
pub const _XBS5_LPBIG_OFFBIG: i32 = -1;
pub const _POSIX_V7_LP64_OFF64: u32 = 1;
pub const _POSIX_V6_LP64_OFF64: u32 = 1;
pub const _XBS5_LP64_OFF64: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const _GETOPT_POSIX_H: u32 = 1;
pub const _GETOPT_CORE_H: u32 = 1;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const ZLIB_VERSION: &'static [u8; 7usize] = b"1.2.11\0";
pub const ZLIB_VERNUM: u32 = 4784;
pub const ZLIB_VER_MAJOR: u32 = 1;
pub const ZLIB_VER_MINOR: u32 = 2;
pub const ZLIB_VER_REVISION: u32 = 11;
pub const ZLIB_VER_SUBREVISION: u32 = 0;
pub const Z_NO_FLUSH: u32 = 0;
pub const Z_PARTIAL_FLUSH: u32 = 1;
pub const Z_SYNC_FLUSH: u32 = 2;
pub const Z_FULL_FLUSH: u32 = 3;
pub const Z_FINISH: u32 = 4;
pub const Z_BLOCK: u32 = 5;
pub const Z_TREES: u32 = 6;
pub const Z_OK: u32 = 0;
pub const Z_STREAM_END: u32 = 1;
pub const Z_NEED_DICT: u32 = 2;
pub const Z_ERRNO: i32 = -1;
pub const Z_STREAM_ERROR: i32 = -2;
pub const Z_DATA_ERROR: i32 = -3;
pub const Z_MEM_ERROR: i32 = -4;
pub const Z_BUF_ERROR: i32 = -5;
pub const Z_VERSION_ERROR: i32 = -6;
pub const Z_NO_COMPRESSION: u32 = 0;
pub const Z_BEST_SPEED: u32 = 1;
pub const Z_BEST_COMPRESSION: u32 = 9;
pub const Z_DEFAULT_COMPRESSION: i32 = -1;
pub const Z_FILTERED: u32 = 1;
pub const Z_HUFFMAN_ONLY: u32 = 2;
pub const Z_RLE: u32 = 3;
pub const Z_FIXED: u32 = 4;
pub const Z_DEFAULT_STRATEGY: u32 = 0;
pub const Z_BINARY: u32 = 0;
pub const Z_TEXT: u32 = 1;
pub const Z_ASCII: u32 = 1;
pub const Z_UNKNOWN: u32 = 2;
pub const Z_DEFLATED: u32 = 8;
pub const Z_NULL: u32 = 0;
pub const ERR_SSL_FEATURE_UNAVAILABLE: i32 = -28800;
pub const ERR_SSL_BAD_INPUT_DATA: i32 = -28928;
pub const ERR_SSL_INVALID_MAC: i32 = -29056;
pub const ERR_SSL_INVALID_RECORD: i32 = -29184;
pub const ERR_SSL_CONN_EOF: i32 = -29312;
pub const ERR_SSL_UNKNOWN_CIPHER: i32 = -29440;
pub const ERR_SSL_NO_CIPHER_CHOSEN: i32 = -29568;
pub const ERR_SSL_NO_RNG: i32 = -29696;
pub const ERR_SSL_NO_CLIENT_CERTIFICATE: i32 = -29824;
pub const ERR_SSL_CERTIFICATE_TOO_LARGE: i32 = -29952;
pub const ERR_SSL_CERTIFICATE_REQUIRED: i32 = -30080;
pub const ERR_SSL_PRIVATE_KEY_REQUIRED: i32 = -30208;
pub const ERR_SSL_CA_CHAIN_REQUIRED: i32 = -30336;
pub const ERR_SSL_UNEXPECTED_MESSAGE: i32 = -30464;
pub const ERR_SSL_FATAL_ALERT_MESSAGE: i32 = -30592;
pub const ERR_SSL_PEER_VERIFY_FAILED: i32 = -30720;
pub const ERR_SSL_PEER_CLOSE_NOTIFY: i32 = -30848;
pub const ERR_SSL_BAD_HS_CLIENT_HELLO: i32 = -30976;
pub const ERR_SSL_BAD_HS_SERVER_HELLO: i32 = -31104;
pub const ERR_SSL_BAD_HS_CERTIFICATE: i32 = -31232;
pub const ERR_SSL_BAD_HS_CERTIFICATE_REQUEST: i32 = -31360;
pub const ERR_SSL_BAD_HS_SERVER_KEY_EXCHANGE: i32 = -31488;
pub const ERR_SSL_BAD_HS_SERVER_HELLO_DONE: i32 = -31616;
pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE: i32 = -31744;
pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_RP: i32 = -31872;
pub const ERR_SSL_BAD_HS_CLIENT_KEY_EXCHANGE_CS: i32 = -32000;
pub const ERR_SSL_BAD_HS_CERTIFICATE_VERIFY: i32 = -32128;
pub const ERR_SSL_BAD_HS_CHANGE_CIPHER_SPEC: i32 = -32256;
pub const ERR_SSL_BAD_HS_FINISHED: i32 = -32384;
pub const ERR_SSL_ALLOC_FAILED: i32 = -32512;
pub const ERR_SSL_HW_ACCEL_FAILED: i32 = -32640;
pub const ERR_SSL_HW_ACCEL_FALLTHROUGH: i32 = -28544;
pub const ERR_SSL_COMPRESSION_FAILED: i32 = -28416;
pub const ERR_SSL_BAD_HS_PROTOCOL_VERSION: i32 = -28288;
pub const ERR_SSL_BAD_HS_NEW_SESSION_TICKET: i32 = -28160;
pub const ERR_SSL_SESSION_TICKET_EXPIRED: i32 = -28032;
pub const ERR_SSL_PK_TYPE_MISMATCH: i32 = -27904;
pub const ERR_SSL_UNKNOWN_IDENTITY: i32 = -27776;
pub const ERR_SSL_INTERNAL_ERROR: i32 = -27648;
pub const ERR_SSL_COUNTER_WRAPPING: i32 = -27520;
pub const ERR_SSL_WAITING_SERVER_HELLO_RENEGO: i32 = -27392;
pub const ERR_SSL_HELLO_VERIFY_REQUIRED: i32 = -27264;
pub const ERR_SSL_BUFFER_TOO_SMALL: i32 = -27136;
pub const ERR_SSL_NO_USABLE_CIPHERSUITE: i32 = -27008;
pub const ERR_SSL_WANT_READ: i32 = -26880;
pub const ERR_SSL_WANT_WRITE: i32 = -26752;
pub const ERR_SSL_TIMEOUT: i32 = -26624;
pub const ERR_SSL_CLIENT_RECONNECT: i32 = -26496;
pub const ERR_SSL_UNEXPECTED_RECORD: i32 = -26368;
pub const ERR_SSL_NON_FATAL: i32 = -26240;
pub const ERR_SSL_INVALID_VERIFY_HASH: i32 = -26112;
pub const ERR_SSL_CONTINUE_PROCESSING: i32 = -25984;
pub const ERR_SSL_ASYNC_IN_PROGRESS: i32 = -25856;
pub const ERR_SSL_EARLY_MESSAGE: i32 = -25728;
pub const ERR_SSL_CRYPTO_IN_PROGRESS: i32 = -28672;
pub const SSL_MAJOR_VERSION_3: u32 = 3;
pub const SSL_MINOR_VERSION_0: u32 = 0;
pub const SSL_MINOR_VERSION_1: u32 = 1;
pub const SSL_MINOR_VERSION_2: u32 = 2;
pub const SSL_MINOR_VERSION_3: u32 = 3;
pub const SSL_TRANSPORT_STREAM: raw_types::c_int = 0;
pub const SSL_TRANSPORT_DATAGRAM: raw_types::c_int = 1;
pub const SSL_MAX_HOST_NAME_LEN: u32 = 255;
pub const SSL_MAX_FRAG_LEN_NONE: u32 = 0;
pub const SSL_MAX_FRAG_LEN_512: u32 = 1;
pub const SSL_MAX_FRAG_LEN_1024: u32 = 2;
pub const SSL_MAX_FRAG_LEN_2048: u32 = 3;
pub const SSL_MAX_FRAG_LEN_4096: u32 = 4;
pub const SSL_MAX_FRAG_LEN_INVALID: u32 = 5;
pub const SSL_IS_CLIENT: raw_types::c_int = 0;
pub const SSL_IS_SERVER: raw_types::c_int = 1;
pub const SSL_IS_NOT_FALLBACK: raw_types::c_int = 0;
pub const SSL_IS_FALLBACK: raw_types::c_int = 1;
pub const SSL_EXTENDED_MS_DISABLED: u32 = 0;
pub const SSL_EXTENDED_MS_ENABLED: u32 = 1;
pub const SSL_ETM_DISABLED: u32 = 0;
pub const SSL_ETM_ENABLED: u32 = 1;
pub const SSL_COMPRESS_NULL: u32 = 0;
pub const SSL_COMPRESS_DEFLATE: u32 = 1;
pub const SSL_VERIFY_NONE: raw_types::c_int = 0;
pub const SSL_VERIFY_OPTIONAL: raw_types::c_int = 1;
pub const SSL_VERIFY_REQUIRED: raw_types::c_int = 2;
pub const SSL_VERIFY_UNSET: raw_types::c_int = 3;
pub const SSL_VERIFY_EXTERNAL: raw_types::c_int = 4;
pub const SSL_LEGACY_RENEGOTIATION: u32 = 0;
pub const SSL_SECURE_RENEGOTIATION: u32 = 1;
pub const SSL_RENEGOTIATION_DISABLED: u32 = 0;
pub const SSL_RENEGOTIATION_ENABLED: u32 = 1;
pub const SSL_ANTI_REPLAY_DISABLED: u32 = 0;
pub const SSL_ANTI_REPLAY_ENABLED: u32 = 1;
pub const SSL_RENEGOTIATION_NOT_ENFORCED: i32 = -1;
pub const SSL_RENEGO_MAX_RECORDS_DEFAULT: u32 = 16;
pub const SSL_LEGACY_NO_RENEGOTIATION: u32 = 0;
pub const SSL_LEGACY_ALLOW_RENEGOTIATION: u32 = 1;
pub const SSL_LEGACY_BREAK_HANDSHAKE: u32 = 2;
pub const SSL_TRUNC_HMAC_DISABLED: u32 = 0;
pub const SSL_TRUNC_HMAC_ENABLED: u32 = 1;
pub const SSL_TRUNCATED_HMAC_LEN: u32 = 10;
pub const SSL_SESSION_TICKETS_DISABLED: raw_types::c_int = 0;
pub const SSL_SESSION_TICKETS_ENABLED: raw_types::c_int = 1;
pub const SSL_CBC_RECORD_SPLITTING_DISABLED: u32 = 0;
pub const SSL_CBC_RECORD_SPLITTING_ENABLED: u32 = 1;
pub const SSL_ARC4_ENABLED: u32 = 0;
pub const SSL_ARC4_DISABLED: u32 = 1;
pub const SSL_PRESET_DEFAULT: raw_types::c_int = 0;
pub const SSL_PRESET_SUITEB: raw_types::c_int = 2;
pub const SSL_CERT_REQ_CA_LIST_ENABLED: u32 = 1;
pub const SSL_CERT_REQ_CA_LIST_DISABLED: u32 = 0;
pub const SSL_DTLS_TIMEOUT_DFL_MIN: u32 = 1000;
pub const SSL_DTLS_TIMEOUT_DFL_MAX: u32 = 60000;
pub const SSL_DEFAULT_TICKET_LIFETIME: u32 = 86400;
pub const SSL_MAX_CONTENT_LEN: u32 = 16384;
pub const SSL_IN_CONTENT_LEN: u32 = 16384;
pub const SSL_OUT_CONTENT_LEN: u32 = 16384;
pub const SSL_DTLS_MAX_BUFFERING: u32 = 32768;
pub const SSL_VERIFY_DATA_MAX_LEN: raw_types::c_int = 36;
pub const SSL_EMPTY_RENEGOTIATION_INFO: u32 = 255;
pub const SSL_FALLBACK_SCSV_VALUE: u32 = 22016;
pub const SSL_HASH_NONE: u32 = 0;
pub const SSL_HASH_MD5: u32 = 1;
pub const SSL_HASH_SHA1: u32 = 2;
pub const SSL_HASH_SHA224: u32 = 3;
pub const SSL_HASH_SHA256: u32 = 4;
pub const SSL_HASH_SHA384: u32 = 5;
pub const SSL_HASH_SHA512: u32 = 6;
pub const SSL_SIG_ANON: u32 = 0;
pub const SSL_SIG_RSA: u32 = 1;
pub const SSL_SIG_ECDSA: u32 = 3;
pub const SSL_CERT_TYPE_RSA_SIGN: u32 = 1;
pub const SSL_CERT_TYPE_ECDSA_SIGN: u32 = 64;
pub const SSL_MSG_CHANGE_CIPHER_SPEC: u32 = 20;
pub const SSL_MSG_ALERT: u32 = 21;
pub const SSL_MSG_HANDSHAKE: u32 = 22;
pub const SSL_MSG_APPLICATION_DATA: u32 = 23;
pub const SSL_ALERT_LEVEL_WARNING: u32 = 1;
pub const SSL_ALERT_LEVEL_FATAL: u32 = 2;
pub const SSL_ALERT_MSG_CLOSE_NOTIFY: u32 = 0;
pub const SSL_ALERT_MSG_UNEXPECTED_MESSAGE: u32 = 10;
pub const SSL_ALERT_MSG_BAD_RECORD_MAC: u32 = 20;
pub const SSL_ALERT_MSG_DECRYPTION_FAILED: u32 = 21;
pub const SSL_ALERT_MSG_RECORD_OVERFLOW: u32 = 22;
pub const SSL_ALERT_MSG_DECOMPRESSION_FAILURE: u32 = 30;
pub const SSL_ALERT_MSG_HANDSHAKE_FAILURE: u32 = 40;
pub const SSL_ALERT_MSG_NO_CERT: u32 = 41;
pub const SSL_ALERT_MSG_BAD_CERT: u32 = 42;
pub const SSL_ALERT_MSG_UNSUPPORTED_CERT: u32 = 43;
pub const SSL_ALERT_MSG_CERT_REVOKED: u32 = 44;
pub const SSL_ALERT_MSG_CERT_EXPIRED: u32 = 45;
pub const SSL_ALERT_MSG_CERT_UNKNOWN: u32 = 46;
pub const SSL_ALERT_MSG_ILLEGAL_PARAMETER: u32 = 47;
pub const SSL_ALERT_MSG_UNKNOWN_CA: u32 = 48;
pub const SSL_ALERT_MSG_ACCESS_DENIED: u32 = 49;
pub const SSL_ALERT_MSG_DECODE_ERROR: u32 = 50;
pub const SSL_ALERT_MSG_DECRYPT_ERROR: u32 = 51;
pub const SSL_ALERT_MSG_EXPORT_RESTRICTION: u32 = 60;
pub const SSL_ALERT_MSG_PROTOCOL_VERSION: u32 = 70;
pub const SSL_ALERT_MSG_INSUFFICIENT_SECURITY: u32 = 71;
pub const SSL_ALERT_MSG_INTERNAL_ERROR: u32 = 80;
pub const SSL_ALERT_MSG_INAPROPRIATE_FALLBACK: u32 = 86;
pub const SSL_ALERT_MSG_USER_CANCELED: u32 = 90;
pub const SSL_ALERT_MSG_NO_RENEGOTIATION: u32 = 100;
pub const SSL_ALERT_MSG_UNSUPPORTED_EXT: u32 = 110;
pub const SSL_ALERT_MSG_UNRECOGNIZED_NAME: u32 = 112;
pub const SSL_ALERT_MSG_UNKNOWN_PSK_IDENTITY: u32 = 115;
pub const SSL_ALERT_MSG_NO_APPLICATION_PROTOCOL: u32 = 120;
pub const SSL_HS_HELLO_REQUEST: u32 = 0;
pub const SSL_HS_CLIENT_HELLO: u32 = 1;
pub const SSL_HS_SERVER_HELLO: u32 = 2;
pub const SSL_HS_HELLO_VERIFY_REQUEST: u32 = 3;
pub const SSL_HS_NEW_SESSION_TICKET: u32 = 4;
pub const SSL_HS_CERTIFICATE: u32 = 11;
pub const SSL_HS_SERVER_KEY_EXCHANGE: u32 = 12;
pub const SSL_HS_CERTIFICATE_REQUEST: u32 = 13;
pub const SSL_HS_SERVER_HELLO_DONE: u32 = 14;
pub const SSL_HS_CERTIFICATE_VERIFY: u32 = 15;
pub const SSL_HS_CLIENT_KEY_EXCHANGE: u32 = 16;
pub const SSL_HS_FINISHED: u32 = 20;
pub const TLS_EXT_SERVERNAME: u32 = 0;
pub const TLS_EXT_SERVERNAME_HOSTNAME: u32 = 0;
pub const TLS_EXT_MAX_FRAGMENT_LENGTH: u32 = 1;
pub const TLS_EXT_TRUNCATED_HMAC: u32 = 4;
pub const TLS_EXT_SUPPORTED_ELLIPTIC_CURVES: u32 = 10;
pub const TLS_EXT_SUPPORTED_POINT_FORMATS: u32 = 11;
pub const TLS_EXT_SIG_ALG: u32 = 13;
pub const TLS_EXT_ALPN: u32 = 16;
pub const TLS_EXT_ENCRYPT_THEN_MAC: u32 = 22;
pub const TLS_EXT_EXTENDED_MASTER_SECRET: u32 = 23;
pub const TLS_EXT_SESSION_TICKET: u32 = 35;
pub const TLS_EXT_ECJPAKE_KKPP: u32 = 256;
pub const TLS_EXT_RENEGOTIATION_INFO: u32 = 65281;
pub const PSK_MAX_LEN: u32 = 32;
pub const ERR_MD5_HW_ACCEL_FAILED: i32 = -47;
pub const ERR_SHA1_HW_ACCEL_FAILED: i32 = -53;
pub const ERR_SHA1_BAD_INPUT_DATA: i32 = -115;
pub const ERR_SHA256_HW_ACCEL_FAILED: i32 = -55;
pub const ERR_SHA256_BAD_INPUT_DATA: i32 = -116;
pub const ERR_SHA512_HW_ACCEL_FAILED: i32 = -57;
pub const ERR_SHA512_BAD_INPUT_DATA: i32 = -117;
pub const AES_ENCRYPT: u32 = 1;
pub const AES_DECRYPT: u32 = 0;
pub const ERR_AES_INVALID_KEY_LENGTH: i32 = -32;
pub const ERR_AES_INVALID_INPUT_LENGTH: i32 = -34;
pub const ERR_AES_BAD_INPUT_DATA: i32 = -33;
pub const ERR_AES_FEATURE_UNAVAILABLE: i32 = -35;
pub const ERR_AES_HW_ACCEL_FAILED: i32 = -37;
pub const ERR_NET_SOCKET_FAILED: i32 = -66;
pub const ERR_NET_CONNECT_FAILED: i32 = -68;
pub const ERR_NET_BIND_FAILED: i32 = -70;
pub const ERR_NET_LISTEN_FAILED: i32 = -72;
pub const ERR_NET_ACCEPT_FAILED: i32 = -74;
pub const ERR_NET_RECV_FAILED: i32 = -76;
pub const ERR_NET_SEND_FAILED: i32 = -78;
pub const ERR_NET_CONN_RESET: i32 = -80;
pub const ERR_NET_UNKNOWN_HOST: i32 = -82;
pub const ERR_NET_BUFFER_TOO_SMALL: i32 = -67;
pub const ERR_NET_INVALID_CONTEXT: i32 = -69;
pub const ERR_NET_POLL_FAILED: i32 = -71;
pub const ERR_NET_BAD_INPUT_DATA: i32 = -73;
pub const NET_LISTEN_BACKLOG: u32 = 10;
pub const NET_PROTO_TCP: u32 = 0;
pub const NET_PROTO_UDP: u32 = 1;
pub const NET_POLL_READ: u32 = 1;
pub const NET_POLL_WRITE: u32 = 2;
pub const HAVEGE_COLLECT_SIZE: u32 = 1024;
pub const ERR_POLY1305_BAD_INPUT_DATA: i32 = -87;
pub const ERR_POLY1305_FEATURE_UNAVAILABLE: i32 = -89;
pub const ERR_POLY1305_HW_ACCEL_FAILED: i32 = -91;
pub const ERR_CHACHA20_BAD_INPUT_DATA: i32 = -81;
pub const ERR_CHACHA20_FEATURE_UNAVAILABLE: i32 = -83;
pub const ERR_CHACHA20_HW_ACCEL_FAILED: i32 = -85;
pub const XTEA_ENCRYPT: u32 = 1;
pub const XTEA_DECRYPT: u32 = 0;
pub const ERR_XTEA_INVALID_INPUT_LENGTH: i32 = -40;
pub const ERR_XTEA_HW_ACCEL_FAILED: i32 = -41;
pub const VERSION_MAJOR: u32 = 2;
pub const VERSION_MINOR: u32 = 16;
pub const VERSION_PATCH: u32 = 0;
pub const VERSION_NUMBER: u32 = 34603008;
pub const VERSION_STRING: &'static [u8; 7usize] = b"2.16.0\0";
pub const VERSION_STRING_FULL: &'static [u8; 16usize] = b"mbed TLS 2.16.0\0";
pub const SSL_MIN_MAJOR_VERSION: u32 = 3;
pub const SSL_MIN_MINOR_VERSION: u32 = 0;
pub const SSL_MIN_VALID_MINOR_VERSION: u32 = 1;
pub const SSL_MIN_VALID_MAJOR_VERSION: u32 = 3;
pub const SSL_MAX_MAJOR_VERSION: u32 = 3;
pub const SSL_MAX_MINOR_VERSION: u32 = 3;
pub const SSL_INITIAL_HANDSHAKE: u32 = 0;
pub const SSL_RENEGOTIATION_IN_PROGRESS: u32 = 1;
pub const SSL_RENEGOTIATION_DONE: u32 = 2;
pub const SSL_RENEGOTIATION_PENDING: u32 = 3;
pub const SSL_RETRANS_PREPARING: u32 = 0;
pub const SSL_RETRANS_SENDING: u32 = 1;
pub const SSL_RETRANS_WAITING: u32 = 2;
pub const SSL_RETRANS_FINISHED: u32 = 3;
pub const SSL_COMPRESSION_ADD: u32 = 1024;
pub const SSL_MAC_ADD: u32 = 48;
pub const SSL_PADDING_ADD: u32 = 256;
pub const SSL_PAYLOAD_OVERHEAD: u32 = 1344;
pub const SSL_IN_PAYLOAD_LEN: u32 = 17728;
pub const SSL_OUT_PAYLOAD_LEN: u32 = 17728;
pub const SSL_MAX_BUFFERED_HS: u32 = 4;
pub const SSL_HEADER_LEN: u32 = 13;
pub const SSL_IN_BUFFER_LEN: u32 = 17741;
pub const SSL_OUT_BUFFER_LEN: u32 = 17741;
pub const TLS_EXT_SUPPORTED_POINT_FORMATS_PRESENT: u32 = 1;
pub const TLS_EXT_ECJPAKE_KKPP_OK: u32 = 2;
pub const SSL_COOKIE_TIMEOUT: u32 = 60;
pub const SSL_CACHE_DEFAULT_TIMEOUT: u32 = 86400;
pub const SSL_CACHE_DEFAULT_MAX_ENTRIES: u32 = 50;
pub const ERR_RIPEMD160_HW_ACCEL_FAILED: i32 = -49;
pub const ERR_PLATFORM_HW_ACCEL_FAILED: i32 = -112;
pub const ERR_PLATFORM_FEATURE_UNSUPPORTED: i32 = -114;
pub const PLATFORM_STD_EXIT_SUCCESS: u32 = 0;
pub const PLATFORM_STD_EXIT_FAILURE: u32 = 1;
pub const PLATFORM_STD_NV_SEED_FILE: &'static [u8; 9usize] = b"seedfile\0";
pub const ERR_PKCS5_BAD_INPUT_DATA: i32 = -12160;
pub const ERR_PKCS5_INVALID_FORMAT: i32 = -12032;
pub const ERR_PKCS5_FEATURE_UNAVAILABLE: i32 = -11904;
pub const ERR_PKCS5_PASSWORD_MISMATCH: i32 = -11776;
pub const PKCS5_DECRYPT: u32 = 0;
pub const PKCS5_ENCRYPT: u32 = 1;
pub const ERR_PKCS12_BAD_INPUT_DATA: i32 = -8064;
pub const ERR_PKCS12_FEATURE_UNAVAILABLE: i32 = -7936;
pub const ERR_PKCS12_PBE_INVALID_FORMAT: i32 = -7808;
pub const ERR_PKCS12_PASSWORD_MISMATCH: i32 = -7680;
pub const PKCS12_DERIVE_KEY: u32 = 1;
pub const PKCS12_DERIVE_IV: u32 = 2;
pub const PKCS12_DERIVE_MAC_KEY: u32 = 3;
pub const PKCS12_PBE_DECRYPT: u32 = 0;
pub const PKCS12_PBE_ENCRYPT: u32 = 1;
pub const ERR_PEM_NO_HEADER_FOOTER_PRESENT: i32 = -4224;
pub const ERR_PEM_INVALID_DATA: i32 = -4352;
pub const ERR_PEM_ALLOC_FAILED: i32 = -4480;
pub const ERR_PEM_INVALID_ENC_IV: i32 = -4608;
pub const ERR_PEM_UNKNOWN_ENC_ALG: i32 = -4736;
pub const ERR_PEM_PASSWORD_REQUIRED: i32 = -4864;
pub const ERR_PEM_PASSWORD_MISMATCH: i32 = -4992;
pub const ERR_PEM_FEATURE_UNAVAILABLE: i32 = -5120;
pub const ERR_PEM_BAD_INPUT_DATA: i32 = -5248;
pub const ERR_PADLOCK_DATA_MISALIGNED: i32 = -48;
pub const ERR_OID_NOT_FOUND: i32 = -46;
pub const ERR_OID_BUF_TOO_SMALL: i32 = -11;
pub const OID_ISO_MEMBER_BODIES: &'static [u8; 2usize] = b"*\0";
pub const OID_ISO_IDENTIFIED_ORG: &'static [u8; 2usize] = b"+\0";
pub const OID_ISO_CCITT_DS: &'static [u8; 2usize] = b"U\0";
pub const OID_ISO_ITU_COUNTRY: &'static [u8; 2usize] = b"`\0";
pub const OID_COUNTRY_US: [u8; 3usize] = [134u8, 72u8, 0u8];
pub const OID_ORG_RSA_DATA_SECURITY: [u8; 4usize] = [134u8, 247u8, 13u8, 0u8];
pub const OID_RSA_COMPANY: [u8; 7usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 0u8];
pub const OID_ORG_ANSI_X9_62: [u8; 3usize] = [206u8, 61u8, 0u8];
pub const OID_ANSI_X9_62: [u8; 6usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 0u8];
pub const OID_ORG_DOD: &'static [u8; 2usize] = b"\x06\0";
pub const OID_ORG_OIW: &'static [u8; 2usize] = b"\x0E\0";
pub const OID_OIW_SECSIG: &'static [u8; 3usize] = b"\x0E\x03\0";
pub const OID_OIW_SECSIG_ALG: &'static [u8; 4usize] = b"\x0E\x03\x02\0";
pub const OID_OIW_SECSIG_SHA1: &'static [u8; 5usize] = b"\x0E\x03\x02\x1A\0";
pub const OID_ORG_CERTICOM: [u8; 3usize] = [129u8, 4u8, 0u8];
pub const OID_CERTICOM: [u8; 4usize] = [43u8, 129u8, 4u8, 0u8];
pub const OID_ORG_TELETRUST: &'static [u8; 2usize] = b"$\0";
pub const OID_TELETRUST: &'static [u8; 3usize] = b"+$\0";
pub const OID_ORGANIZATION: &'static [u8; 2usize] = b"\x01\0";
pub const OID_ISO_ITU_US_ORG: [u8; 5usize] = [96u8, 134u8, 72u8, 1u8, 0u8];
pub const OID_ORG_GOV: &'static [u8; 2usize] = b"e\0";
pub const OID_GOV: [u8; 6usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 0u8];
pub const OID_ORG_NETSCAPE: [u8; 4usize] = [134u8, 248u8, 66u8, 0u8];
pub const OID_NETSCAPE: [u8; 8usize] = [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 0u8];
pub const OID_ID_CE: &'static [u8; 3usize] = b"U\x1D\0";
pub const OID_NIST_ALG: [u8; 8usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 0u8];
pub const OID_PKIX: &'static [u8; 7usize] = b"+\x06\x01\x05\x05\x07\0";
pub const OID_AT: &'static [u8; 3usize] = b"U\x04\0";
pub const OID_AT_CN: &'static [u8; 4usize] = b"U\x04\x03\0";
pub const OID_AT_SUR_NAME: &'static [u8; 4usize] = b"U\x04\x04\0";
pub const OID_AT_SERIAL_NUMBER: &'static [u8; 4usize] = b"U\x04\x05\0";
pub const OID_AT_COUNTRY: &'static [u8; 4usize] = b"U\x04\x06\0";
pub const OID_AT_LOCALITY: &'static [u8; 4usize] = b"U\x04\x07\0";
pub const OID_AT_STATE: &'static [u8; 4usize] = b"U\x04\x08\0";
pub const OID_AT_ORGANIZATION: &'static [u8; 4usize] = b"U\x04\n\0";
pub const OID_AT_ORG_UNIT: &'static [u8; 4usize] = b"U\x04\x0B\0";
pub const OID_AT_TITLE: &'static [u8; 4usize] = b"U\x04\x0C\0";
pub const OID_AT_POSTAL_ADDRESS: &'static [u8; 4usize] = b"U\x04\x10\0";
pub const OID_AT_POSTAL_CODE: &'static [u8; 4usize] = b"U\x04\x11\0";
pub const OID_AT_GIVEN_NAME: &'static [u8; 4usize] = b"U\x04*\0";
pub const OID_AT_INITIALS: &'static [u8; 4usize] = b"U\x04+\0";
pub const OID_AT_GENERATION_QUALIFIER: &'static [u8; 4usize] = b"U\x04,\0";
pub const OID_AT_UNIQUE_IDENTIFIER: &'static [u8; 4usize] = b"U\x04-\0";
pub const OID_AT_DN_QUALIFIER: &'static [u8; 4usize] = b"U\x04.\0";
pub const OID_AT_PSEUDONYM: &'static [u8; 4usize] = b"U\x04A\0";
pub const OID_DOMAIN_COMPONENT: [u8; 11usize] = [
    9u8, 146u8, 38u8, 137u8, 147u8, 242u8, 44u8, 100u8, 1u8, 25u8, 0u8,
];
pub const OID_AUTHORITY_KEY_IDENTIFIER: &'static [u8; 4usize] = b"U\x1D#\0";
pub const OID_SUBJECT_KEY_IDENTIFIER: &'static [u8; 4usize] = b"U\x1D\x0E\0";
pub const OID_KEY_USAGE: &'static [u8; 4usize] = b"U\x1D\x0F\0";
pub const OID_CERTIFICATE_POLICIES: &'static [u8; 4usize] = b"U\x1D \0";
pub const OID_POLICY_MAPPINGS: &'static [u8; 4usize] = b"U\x1D!\0";
pub const OID_SUBJECT_ALT_NAME: &'static [u8; 4usize] = b"U\x1D\x11\0";
pub const OID_ISSUER_ALT_NAME: &'static [u8; 4usize] = b"U\x1D\x12\0";
pub const OID_SUBJECT_DIRECTORY_ATTRS: &'static [u8; 4usize] = b"U\x1D\t\0";
pub const OID_BASIC_CONSTRAINTS: &'static [u8; 4usize] = b"U\x1D\x13\0";
pub const OID_NAME_CONSTRAINTS: &'static [u8; 4usize] = b"U\x1D\x1E\0";
pub const OID_POLICY_CONSTRAINTS: &'static [u8; 4usize] = b"U\x1D$\0";
pub const OID_EXTENDED_KEY_USAGE: &'static [u8; 4usize] = b"U\x1D%\0";
pub const OID_CRL_DISTRIBUTION_POINTS: &'static [u8; 4usize] = b"U\x1D\x1F\0";
pub const OID_INIHIBIT_ANYPOLICY: &'static [u8; 4usize] = b"U\x1D6\0";
pub const OID_FRESHEST_CRL: &'static [u8; 4usize] = b"U\x1D.\0";
pub const OID_NS_CERT: [u8; 9usize] = [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 0u8];
pub const OID_NS_CERT_TYPE: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 1u8, 0u8];
pub const OID_NS_BASE_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 2u8, 0u8];
pub const OID_NS_REVOCATION_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 3u8, 0u8];
pub const OID_NS_CA_REVOCATION_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 4u8, 0u8];
pub const OID_NS_RENEWAL_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 7u8, 0u8];
pub const OID_NS_CA_POLICY_URL: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 8u8, 0u8];
pub const OID_NS_SSL_SERVER_NAME: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 12u8, 0u8];
pub const OID_NS_COMMENT: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 1u8, 13u8, 0u8];
pub const OID_NS_DATA_TYPE: [u8; 9usize] = [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 2u8, 0u8];
pub const OID_NS_CERT_SEQUENCE: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 134u8, 248u8, 66u8, 2u8, 5u8, 0u8];
pub const OID_PRIVATE_KEY_USAGE_PERIOD: &'static [u8; 4usize] = b"U\x1D\x10\0";
pub const OID_CRL_NUMBER: &'static [u8; 4usize] = b"U\x1D\x14\0";
pub const OID_ANY_EXTENDED_KEY_USAGE: &'static [u8; 5usize] = b"U\x1D%\0\0";
pub const OID_KP: &'static [u8; 8usize] = b"+\x06\x01\x05\x05\x07\x03\0";
pub const OID_SERVER_AUTH: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x01\0";
pub const OID_CLIENT_AUTH: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x02\0";
pub const OID_CODE_SIGNING: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x03\0";
pub const OID_EMAIL_PROTECTION: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x04\0";
pub const OID_TIME_STAMPING: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\x08\0";
pub const OID_OCSP_SIGNING: &'static [u8; 9usize] = b"+\x06\x01\x05\x05\x07\x03\t\0";
pub const OID_PKCS: [u8; 8usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 0u8];
pub const OID_PKCS1: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 0u8];
pub const OID_PKCS5: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 0u8];
pub const OID_PKCS9: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 9u8, 0u8];
pub const OID_PKCS12: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 0u8];
pub const OID_PKCS1_RSA: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 1u8, 0u8];
pub const OID_PKCS1_MD2: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 2u8, 0u8];
pub const OID_PKCS1_MD4: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 3u8, 0u8];
pub const OID_PKCS1_MD5: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 4u8, 0u8];
pub const OID_PKCS1_SHA1: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 5u8, 0u8];
pub const OID_PKCS1_SHA224: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 14u8, 0u8];
pub const OID_PKCS1_SHA256: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 11u8, 0u8];
pub const OID_PKCS1_SHA384: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 12u8, 0u8];
pub const OID_PKCS1_SHA512: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 13u8, 0u8];
pub const OID_RSA_SHA_OBS: &'static [u8; 6usize] = b"+\x0E\x03\x02\x1D\0";
pub const OID_PKCS9_EMAIL: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 9u8, 1u8, 0u8];
pub const OID_RSASSA_PSS: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 10u8, 0u8];
pub const OID_MGF1: [u8; 10usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 1u8, 8u8, 0u8];
pub const OID_DIGEST_ALG_MD2: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 2u8, 0u8];
pub const OID_DIGEST_ALG_MD4: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 4u8, 0u8];
pub const OID_DIGEST_ALG_MD5: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 5u8, 0u8];
pub const OID_DIGEST_ALG_SHA1: &'static [u8; 6usize] = b"+\x0E\x03\x02\x1A\0";
pub const OID_DIGEST_ALG_SHA224: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 4u8, 0u8];
pub const OID_DIGEST_ALG_SHA256: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 1u8, 0u8];
pub const OID_DIGEST_ALG_SHA384: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 2u8, 0u8];
pub const OID_DIGEST_ALG_SHA512: [u8; 10usize] =
    [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 2u8, 3u8, 0u8];
pub const OID_HMAC_SHA1: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 7u8, 0u8];
pub const OID_HMAC_SHA224: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 8u8, 0u8];
pub const OID_HMAC_SHA256: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 9u8, 0u8];
pub const OID_HMAC_SHA384: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 10u8, 0u8];
pub const OID_HMAC_SHA512: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 2u8, 11u8, 0u8];
pub const OID_DES_CBC: &'static [u8; 6usize] = b"+\x0E\x03\x02\x07\0";
pub const OID_DES_EDE3_CBC: [u8; 9usize] = [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 3u8, 7u8, 0u8];
pub const OID_AES: [u8; 9usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 0u8];
pub const OID_AES128_KW: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 5u8, 0u8];
pub const OID_AES128_KWP: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 8u8, 0u8];
pub const OID_AES192_KW: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 25u8, 0u8];
pub const OID_AES192_KWP: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 28u8, 0u8];
pub const OID_AES256_KW: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 45u8, 0u8];
pub const OID_AES256_KWP: [u8; 10usize] = [96u8, 134u8, 72u8, 1u8, 101u8, 3u8, 4u8, 1u8, 48u8, 0u8];
pub const OID_PKCS5_PBKDF2: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 12u8, 0u8];
pub const OID_PKCS5_PBES2: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 13u8, 0u8];
pub const OID_PKCS5_PBMAC1: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 14u8, 0u8];
pub const OID_PKCS5_PBE_MD2_DES_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 1u8, 0u8];
pub const OID_PKCS5_PBE_MD2_RC2_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 4u8, 0u8];
pub const OID_PKCS5_PBE_MD5_DES_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 3u8, 0u8];
pub const OID_PKCS5_PBE_MD5_RC2_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 6u8, 0u8];
pub const OID_PKCS5_PBE_SHA1_DES_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 10u8, 0u8];
pub const OID_PKCS5_PBE_SHA1_RC2_CBC: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 5u8, 11u8, 0u8];
pub const OID_PKCS9_CSR_EXT_REQ: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 9u8, 14u8, 0u8];
pub const OID_PKCS12_PBE: [u8; 10usize] =
    [42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 0u8];
pub const OID_PKCS12_PBE_SHA1_RC4_128: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 1u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_RC4_40: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 2u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_DES3_EDE_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 3u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_DES2_EDE_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 4u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_RC2_128_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 5u8, 0u8,
];
pub const OID_PKCS12_PBE_SHA1_RC2_40_CBC: [u8; 11usize] = [
    42u8, 134u8, 72u8, 134u8, 247u8, 13u8, 1u8, 12u8, 1u8, 6u8, 0u8,
];
pub const OID_EC_ALG_UNRESTRICTED: [u8; 8usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 2u8, 1u8, 0u8];
pub const OID_EC_ALG_ECDH: [u8; 6usize] = [43u8, 129u8, 4u8, 1u8, 12u8, 0u8];
pub const OID_EC_GRP_SECP192R1: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 3u8, 1u8, 1u8, 0u8];
pub const OID_EC_GRP_SECP224R1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 33u8, 0u8];
pub const OID_EC_GRP_SECP256R1: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 3u8, 1u8, 7u8, 0u8];
pub const OID_EC_GRP_SECP384R1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 34u8, 0u8];
pub const OID_EC_GRP_SECP521R1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 35u8, 0u8];
pub const OID_EC_GRP_SECP192K1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 31u8, 0u8];
pub const OID_EC_GRP_SECP224K1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 32u8, 0u8];
pub const OID_EC_GRP_SECP256K1: [u8; 6usize] = [43u8, 129u8, 4u8, 0u8, 10u8, 0u8];
pub const OID_EC_BRAINPOOL_V1: &'static [u8; 9usize] = b"+$\x03\x03\x02\x08\x01\x01\0";
pub const OID_EC_GRP_BP256R1: &'static [u8; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\x07\0";
pub const OID_EC_GRP_BP384R1: &'static [u8; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\x0B\0";
pub const OID_EC_GRP_BP512R1: &'static [u8; 10usize] = b"+$\x03\x03\x02\x08\x01\x01\r\0";
pub const OID_ANSI_X9_62_FIELD_TYPE: [u8; 7usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 1u8, 0u8];
pub const OID_ANSI_X9_62_PRIME_FIELD: [u8; 8usize] =
    [42u8, 134u8, 72u8, 206u8, 61u8, 1u8, 1u8, 0u8];
pub const OID_ANSI_X9_62_SIG: [u8; 7usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 0u8];
pub const OID_ANSI_X9_62_SIG_SHA2: [u8; 8usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 0u8];
pub const OID_ECDSA_SHA1: [u8; 8usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 1u8, 0u8];
pub const OID_ECDSA_SHA224: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 1u8, 0u8];
pub const OID_ECDSA_SHA256: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 2u8, 0u8];
pub const OID_ECDSA_SHA384: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 3u8, 0u8];
pub const OID_ECDSA_SHA512: [u8; 9usize] = [42u8, 134u8, 72u8, 206u8, 61u8, 4u8, 3u8, 4u8, 0u8];
pub const MEMORY_ALIGN_MULTIPLE: u32 = 4;
pub const MEMORY_VERIFY_NONE: u32 = 0;
pub const MEMORY_VERIFY_ALLOC: u32 = 1;
pub const MEMORY_VERIFY_FREE: u32 = 2;
pub const MEMORY_VERIFY_ALWAYS: u32 = 3;
pub const ERR_MD4_HW_ACCEL_FAILED: i32 = -45;
pub const ERR_MD2_HW_ACCEL_FAILED: i32 = -43;
pub const ERR_HMAC_DRBG_REQUEST_TOO_BIG: i32 = -3;
pub const ERR_HMAC_DRBG_INPUT_TOO_BIG: i32 = -5;
pub const ERR_HMAC_DRBG_FILE_IO_ERROR: i32 = -7;
pub const ERR_HMAC_DRBG_ENTROPY_SOURCE_FAILED: i32 = -9;
pub const HMAC_DRBG_RESEED_INTERVAL: u32 = 10000;
pub const HMAC_DRBG_MAX_INPUT: u32 = 256;
pub const HMAC_DRBG_MAX_REQUEST: u32 = 1024;
pub const HMAC_DRBG_MAX_SEED_INPUT: u32 = 384;
pub const HMAC_DRBG_PR_OFF: raw_types::c_int = 0;
pub const HMAC_DRBG_PR_ON: raw_types::c_int = 1;
pub const ERR_HKDF_BAD_INPUT_DATA: i32 = -24448;
pub const GCM_ENCRYPT: u32 = 1;
pub const GCM_DECRYPT: u32 = 0;
pub const ERR_GCM_AUTH_FAILED: i32 = -18;
pub const ERR_GCM_HW_ACCEL_FAILED: i32 = -19;
pub const ERR_GCM_BAD_INPUT: i32 = -20;
pub const ENTROPY_MIN_PLATFORM: u32 = 32;
pub const ENTROPY_MIN_HAVEGE: u32 = 32;
pub const ENTROPY_MIN_HARDCLOCK: u32 = 4;
pub const ENTROPY_MIN_HARDWARE: u32 = 32;
pub const ERR_ENTROPY_SOURCE_FAILED: i32 = -60;
pub const ERR_ENTROPY_MAX_SOURCES: i32 = -62;
pub const ERR_ENTROPY_NO_SOURCES_DEFINED: i32 = -64;
pub const ERR_ENTROPY_NO_STRONG_SOURCE: i32 = -61;
pub const ERR_ENTROPY_FILE_IO_ERROR: i32 = -63;
pub const ENTROPY_MAX_SOURCES: u32 = 20;
pub const ENTROPY_MAX_GATHER: u32 = 128;
pub const ENTROPY_BLOCK_SIZE: u32 = 64;
pub const ENTROPY_MAX_SEED_SIZE: u32 = 1024;
pub const ENTROPY_SOURCE_MANUAL: raw_types::c_int = 20;
pub const ENTROPY_SOURCE_STRONG: raw_types::c_int = 1;
pub const ENTROPY_SOURCE_WEAK: raw_types::c_int = 0;
pub const DES_ENCRYPT: u32 = 1;
pub const DES_DECRYPT: u32 = 0;
pub const ERR_DES_INVALID_INPUT_LENGTH: i32 = -50;
pub const ERR_DES_HW_ACCEL_FAILED: i32 = -51;
pub const DES_KEY_SIZE: u32 = 8;
pub const ERR_CTR_DRBG_ENTROPY_SOURCE_FAILED: i32 = -52;
pub const ERR_CTR_DRBG_REQUEST_TOO_BIG: i32 = -54;
pub const ERR_CTR_DRBG_INPUT_TOO_BIG: i32 = -56;
pub const ERR_CTR_DRBG_FILE_IO_ERROR: i32 = -58;
pub const CTR_DRBG_BLOCKSIZE: u32 = 16;
pub const CTR_DRBG_KEYSIZE: u32 = 32;
pub const CTR_DRBG_KEYBITS: u32 = 256;
pub const CTR_DRBG_SEEDLEN: u32 = 48;
pub const CTR_DRBG_ENTROPY_LEN: u32 = 48;
pub const CTR_DRBG_RESEED_INTERVAL: u32 = 10000;
pub const CTR_DRBG_MAX_INPUT: u32 = 256;
pub const CTR_DRBG_MAX_REQUEST: u32 = 1024;
pub const CTR_DRBG_MAX_SEED_INPUT: u32 = 384;
pub const CTR_DRBG_PR_OFF: raw_types::c_int = 0;
pub const CTR_DRBG_PR_ON: raw_types::c_int = 1;
pub const ERR_CMAC_HW_ACCEL_FAILED: i32 = -122;
pub const AES_BLOCK_SIZE: u32 = 16;
pub const DES3_BLOCK_SIZE: u32 = 8;
pub const CIPHER_BLKSIZE_MAX: u32 = 16;
pub const ERR_CHACHAPOLY_BAD_STATE: i32 = -84;
pub const ERR_CHACHAPOLY_AUTH_FAILED: i32 = -86;
pub const ERR_CCM_BAD_INPUT: i32 = -13;
pub const ERR_CCM_AUTH_FAILED: i32 = -15;
pub const ERR_CCM_HW_ACCEL_FAILED: i32 = -17;
pub const CAMELLIA_ENCRYPT: u32 = 1;
pub const CAMELLIA_DECRYPT: u32 = 0;
pub const ERR_CAMELLIA_BAD_INPUT_DATA: i32 = -36;
pub const ERR_CAMELLIA_INVALID_INPUT_LENGTH: i32 = -38;
pub const ERR_CAMELLIA_HW_ACCEL_FAILED: i32 = -39;
pub const MULADDC_CORE : & 'static [ u8 ; 176usize ] = b"movq   (%%rsi), %%rax\nmulq   %%rbx\naddq   $8, %%rsi\naddq   %%rcx, %%rax\nmovq   %%r8, %%rcx\nadcq   $0, %%rdx\nnop    \naddq   %%rax, (%%rdi)\nadcq   %%rdx, %%rcx\naddq   $8, %%rdi\n\0" ;
pub const BLOWFISH_ENCRYPT: u32 = 1;
pub const BLOWFISH_DECRYPT: u32 = 0;
pub const BLOWFISH_MAX_KEY_BITS: u32 = 448;
pub const BLOWFISH_MIN_KEY_BITS: u32 = 32;
pub const BLOWFISH_ROUNDS: u32 = 16;
pub const BLOWFISH_BLOCKSIZE: u32 = 8;
pub const ERR_BLOWFISH_BAD_INPUT_DATA: i32 = -22;
pub const ERR_BLOWFISH_INVALID_INPUT_LENGTH: i32 = -24;
pub const ERR_BLOWFISH_HW_ACCEL_FAILED: i32 = -23;
pub const ERR_BASE64_BUFFER_TOO_SMALL: i32 = -42;
pub const ERR_BASE64_INVALID_CHARACTER: i32 = -44;
pub const ARIA_ENCRYPT: u32 = 1;
pub const ARIA_DECRYPT: u32 = 0;
pub const ARIA_BLOCKSIZE: u32 = 16;
pub const ARIA_MAX_ROUNDS: u32 = 16;
pub const ARIA_MAX_KEYSIZE: u32 = 32;
pub const ERR_ARIA_BAD_INPUT_DATA: i32 = -92;
pub const ERR_ARIA_INVALID_INPUT_LENGTH: i32 = -94;
pub const ERR_ARIA_FEATURE_UNAVAILABLE: i32 = -90;
pub const ERR_ARIA_HW_ACCEL_FAILED: i32 = -88;
pub const ERR_ARC4_HW_ACCEL_FAILED: i32 = -25;
pub const AESNI_AES: u32 = 33554432;
pub const AESNI_CLMUL: u32 = 2;
extern "C" {
    #[link_name = "mbedtls_printf"]
    pub fn printf(format: *const raw_types::c_char, ...) -> raw_types::c_int;
}
pub type iso_c_forbids_empty_translation_units = raw_types::c_int;
pub type wchar_t = raw_types::c_int;
pub type __u_char = raw_types::c_uchar;
pub type __u_short = raw_types::c_ushort;
pub type __u_int = raw_types::c_uint;
pub type __u_long = raw_types::c_ulong;
pub type __int8_t = raw_types::c_schar;
pub type __uint8_t = raw_types::c_uchar;
pub type __int16_t = raw_types::c_short;
pub type __uint16_t = raw_types::c_ushort;
pub type __int32_t = raw_types::c_int;
pub type __uint32_t = raw_types::c_uint;
pub type __int64_t = raw_types::c_long;
pub type __uint64_t = raw_types::c_ulong;
pub type __quad_t = raw_types::c_long;
pub type __u_quad_t = raw_types::c_ulong;
pub type __intmax_t = raw_types::c_long;
pub type __uintmax_t = raw_types::c_ulong;
pub type __dev_t = raw_types::c_ulong;
pub type __uid_t = raw_types::c_uint;
pub type __gid_t = raw_types::c_uint;
pub type __ino_t = raw_types::c_ulong;
pub type __ino64_t = raw_types::c_ulong;
pub type __mode_t = raw_types::c_uint;
pub type __nlink_t = raw_types::c_ulong;
pub type __off_t = raw_types::c_long;
pub type __off64_t = raw_types::c_long;
pub type __pid_t = raw_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __fsid_t {
    pub __val: [raw_types::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::core::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = raw_types::c_long;
pub type __rlim_t = raw_types::c_ulong;
pub type __rlim64_t = raw_types::c_ulong;
pub type __id_t = raw_types::c_uint;
pub type __time_t = raw_types::c_long;
pub type __useconds_t = raw_types::c_uint;
pub type __suseconds_t = raw_types::c_long;
pub type __daddr_t = raw_types::c_int;
pub type __key_t = raw_types::c_int;
pub type __clockid_t = raw_types::c_int;
pub type __timer_t = *mut raw_types::c_void;
pub type __blksize_t = raw_types::c_long;
pub type __blkcnt_t = raw_types::c_long;
pub type __blkcnt64_t = raw_types::c_long;
pub type __fsblkcnt_t = raw_types::c_ulong;
pub type __fsblkcnt64_t = raw_types::c_ulong;
pub type __fsfilcnt_t = raw_types::c_ulong;
pub type __fsfilcnt64_t = raw_types::c_ulong;
pub type __fsword_t = raw_types::c_long;
pub type __ssize_t = raw_types::c_long;
pub type __syscall_slong_t = raw_types::c_long;
pub type __syscall_ulong_t = raw_types::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut raw_types::c_char;
pub type __intptr_t = raw_types::c_long;
pub type __socklen_t = raw_types::c_uint;
pub type __sig_atomic_t = raw_types::c_int;
pub type int_least8_t = raw_types::c_schar;
pub type int_least16_t = raw_types::c_short;
pub type int_least32_t = raw_types::c_int;
pub type int_least64_t = raw_types::c_long;
pub type uint_least8_t = raw_types::c_uchar;
pub type uint_least16_t = raw_types::c_ushort;
pub type uint_least32_t = raw_types::c_uint;
pub type uint_least64_t = raw_types::c_ulong;
pub type int_fast8_t = raw_types::c_schar;
pub type int_fast16_t = raw_types::c_long;
pub type int_fast32_t = raw_types::c_long;
pub type int_fast64_t = raw_types::c_long;
pub type uint_fast8_t = raw_types::c_uchar;
pub type uint_fast16_t = raw_types::c_ulong;
pub type uint_fast32_t = raw_types::c_ulong;
pub type uint_fast64_t = raw_types::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
pub type __FILE = _IO_FILE;
pub type FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: raw_types::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: raw_types::c_uint,
    pub __wchb: [raw_types::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::core::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::core::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_G_fpos64_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = raw_types::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: raw_types::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::core::mem::size_of::<_IO_marker>(),
        24usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_marker>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_ok: __codecvt_result = 0;
pub const __codecvt_partial: __codecvt_result = 1;
pub const __codecvt_error: __codecvt_result = 2;
pub const __codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: raw_types::c_int,
    pub _IO_read_ptr: *mut raw_types::c_char,
    pub _IO_read_end: *mut raw_types::c_char,
    pub _IO_read_base: *mut raw_types::c_char,
    pub _IO_write_base: *mut raw_types::c_char,
    pub _IO_write_ptr: *mut raw_types::c_char,
    pub _IO_write_end: *mut raw_types::c_char,
    pub _IO_buf_base: *mut raw_types::c_char,
    pub _IO_buf_end: *mut raw_types::c_char,
    pub _IO_save_base: *mut raw_types::c_char,
    pub _IO_backup_base: *mut raw_types::c_char,
    pub _IO_save_end: *mut raw_types::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: raw_types::c_int,
    pub _flags2: raw_types::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: raw_types::c_ushort,
    pub _vtable_offset: raw_types::c_schar,
    pub _shortbuf: [raw_types::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut raw_types::c_void,
    pub __pad2: *mut raw_types::c_void,
    pub __pad3: *mut raw_types::c_void,
    pub __pad4: *mut raw_types::c_void,
    pub __pad5: usize,
    pub _mode: raw_types::c_int,
    pub _unused2: [raw_types::c_char; 20usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::core::mem::size_of::<_IO_FILE>(),
        216usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::core::mem::align_of::<_IO_FILE>(),
        8usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut raw_types::c_void,
        __buf: *mut raw_types::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut raw_types::c_void,
        __buf: *const raw_types::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::core::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut raw_types::c_void,
        __pos: *mut __off64_t,
        __w: raw_types::c_int,
    ) -> raw_types::c_int,
>;
pub type __io_close_fn = ::core::option::Option<
    unsafe extern "C" fn(__cookie: *mut raw_types::c_void) -> raw_types::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: raw_types::c_int, __fp: *mut _IO_FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const raw_types::c_char,
        arg3: *mut __va_list_tag,
        arg4: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const raw_types::c_char,
        arg3: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: raw_types::c_int, arg3: __ssize_t) -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut raw_types::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: raw_types::c_int,
        arg4: raw_types::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(arg1: *mut _IO_FILE, arg2: __off64_t, arg3: raw_types::c_int) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type off_t = __off_t;
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const raw_types::c_char,
        __new: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: raw_types::c_int,
        __old: *const raw_types::c_char,
        __newfd: raw_types::c_int,
        __new: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut raw_types::c_char) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut raw_types::c_char) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const raw_types::c_char,
        __pfx: *const raw_types::c_char,
    ) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const raw_types::c_char,
        __modes: *const raw_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const raw_types::c_char,
        __modes: *const raw_types::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: raw_types::c_int, __modes: *const raw_types::c_char) -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut raw_types::c_void,
        __len: usize,
        __modes: *const raw_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut raw_types::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut raw_types::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut raw_types::c_char,
        __modes: raw_types::c_int,
        __n: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut raw_types::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const raw_types::c_char,
        ...
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "printf"]
    pub fn printf1(__format: *const raw_types::c_char, ...) -> raw_types::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut raw_types::c_char,
        __format: *const raw_types::c_char,
        ...
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut raw_types::c_char,
        __format: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut raw_types::c_char,
        __maxlen: usize,
        __format: *const raw_types::c_char,
        ...
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut raw_types::c_char,
        __maxlen: usize,
        __format: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: raw_types::c_int,
        __fmt: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: raw_types::c_int,
        __fmt: *const raw_types::c_char,
        ...
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn fscanf(__stream: *mut FILE, __format: *const raw_types::c_char, ...)
        -> raw_types::c_int;
}
extern "C" {
    pub fn scanf(__format: *const raw_types::c_char, ...) -> raw_types::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const raw_types::c_char,
        __format: *const raw_types::c_char,
        ...
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const raw_types::c_char,
        ...
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "__isoc99_scanf"]
    pub fn scanf1(__format: *const raw_types::c_char, ...) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const raw_types::c_char,
        __format: *const raw_types::c_char,
        ...
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const raw_types::c_char,
        __format: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const raw_types::c_char,
        __format: *const raw_types::c_char,
        __arg: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn getchar() -> raw_types::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> raw_types::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn fputc(__c: raw_types::c_int, __stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn putc(__c: raw_types::c_int, __stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn putchar(__c: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: raw_types::c_int, __stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: raw_types::c_int, __stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn putw(__w: raw_types::c_int, __stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut raw_types::c_char,
        __n: raw_types::c_int,
        __stream: *mut FILE,
    ) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut raw_types::c_char,
        __n: *mut usize,
        __delimiter: raw_types::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut raw_types::c_char,
        __n: *mut usize,
        __delimiter: raw_types::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut raw_types::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const raw_types::c_char, __stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn puts(__s: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn ungetc(__c: raw_types::c_int, __stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut raw_types::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> raw_types::c_ulong;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const raw_types::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> raw_types::c_ulong;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut raw_types::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const raw_types::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: raw_types::c_long,
        __whence: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> raw_types::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> raw_types::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> raw_types::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn perror(__s: *const raw_types::c_char);
}
extern "C" {
    #[link_name = "sys_nerr"]
    pub static mut sys_nerr: raw_types::c_int;
}
extern "C" {
    #[link_name = "sys_errlist"]
    pub static mut sys_errlist: [*const raw_types::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const raw_types::c_char,
        __modes: *const raw_types::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut raw_types::c_char) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
pub type mpi_sint = i64;
pub type mpi_uint = u64;
pub type t_udbl = raw_types::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct mpi {
    pub s: raw_types::c_int,
    pub n: usize,
    pub p: *mut mpi_uint,
}
#[test]
fn bindgen_test_layout_mpi() {
    assert_eq!(
        ::core::mem::size_of::<mpi>(),
        24usize,
        concat!("Size of: ", stringify!(mpi))
    );
    assert_eq!(
        ::core::mem::align_of::<mpi>(),
        8usize,
        concat!("Alignment of ", stringify!(mpi))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mpi>())).s as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(mpi), "::", stringify!(s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mpi>())).n as *const _ as usize },
        8usize,
        concat!("Offset of field: ", stringify!(mpi), "::", stringify!(n))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<mpi>())).p as *const _ as usize },
        16usize,
        concat!("Offset of field: ", stringify!(mpi), "::", stringify!(p))
    );
}
extern "C" {
    #[link_name = "mbedtls_mpi_init"]
    pub fn mpi_init(X: *mut mpi);
}
extern "C" {
    #[link_name = "mbedtls_mpi_free"]
    pub fn mpi_free(X: *mut mpi);
}
extern "C" {
    #[link_name = "mbedtls_mpi_grow"]
    pub fn mpi_grow(X: *mut mpi, nblimbs: usize) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_shrink"]
    pub fn mpi_shrink(X: *mut mpi, nblimbs: usize) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_copy"]
    pub fn mpi_copy(X: *mut mpi, Y: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_swap"]
    pub fn mpi_swap(X: *mut mpi, Y: *mut mpi);
}
extern "C" {
    #[link_name = "mbedtls_mpi_safe_cond_assign"]
    pub fn mpi_safe_cond_assign(
        X: *mut mpi,
        Y: *const mpi,
        assign: raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_safe_cond_swap"]
    pub fn mpi_safe_cond_swap(
        X: *mut mpi,
        Y: *mut mpi,
        assign: raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_lset"]
    pub fn mpi_lset(X: *mut mpi, z: mpi_sint) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_get_bit"]
    pub fn mpi_get_bit(X: *const mpi, pos: usize) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_set_bit"]
    pub fn mpi_set_bit(X: *mut mpi, pos: usize, val: raw_types::c_uchar) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_lsb"]
    pub fn mpi_lsb(X: *const mpi) -> usize;
}
extern "C" {
    #[link_name = "mbedtls_mpi_bitlen"]
    pub fn mpi_bitlen(X: *const mpi) -> usize;
}
extern "C" {
    #[link_name = "mbedtls_mpi_size"]
    pub fn mpi_size(X: *const mpi) -> usize;
}
extern "C" {
    #[link_name = "mbedtls_mpi_read_string"]
    pub fn mpi_read_string(
        X: *mut mpi,
        radix: raw_types::c_int,
        s: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_write_string"]
    pub fn mpi_write_string(
        X: *const mpi,
        radix: raw_types::c_int,
        buf: *mut raw_types::c_char,
        buflen: usize,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_read_file"]
    pub fn mpi_read_file(X: *mut mpi, radix: raw_types::c_int, fin: *mut FILE) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_write_file"]
    pub fn mpi_write_file(
        p: *const raw_types::c_char,
        X: *const mpi,
        radix: raw_types::c_int,
        fout: *mut FILE,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_read_binary"]
    pub fn mpi_read_binary(
        X: *mut mpi,
        buf: *const raw_types::c_uchar,
        buflen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_write_binary"]
    pub fn mpi_write_binary(
        X: *const mpi,
        buf: *mut raw_types::c_uchar,
        buflen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_shift_l"]
    pub fn mpi_shift_l(X: *mut mpi, count: usize) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_shift_r"]
    pub fn mpi_shift_r(X: *mut mpi, count: usize) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_cmp_abs"]
    pub fn mpi_cmp_abs(X: *const mpi, Y: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_cmp_mpi"]
    pub fn mpi_cmp_mpi(X: *const mpi, Y: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_cmp_int"]
    pub fn mpi_cmp_int(X: *const mpi, z: mpi_sint) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_add_abs"]
    pub fn mpi_add_abs(X: *mut mpi, A: *const mpi, B: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_sub_abs"]
    pub fn mpi_sub_abs(X: *mut mpi, A: *const mpi, B: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_add_mpi"]
    pub fn mpi_add_mpi(X: *mut mpi, A: *const mpi, B: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_sub_mpi"]
    pub fn mpi_sub_mpi(X: *mut mpi, A: *const mpi, B: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_add_int"]
    pub fn mpi_add_int(X: *mut mpi, A: *const mpi, b: mpi_sint) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_sub_int"]
    pub fn mpi_sub_int(X: *mut mpi, A: *const mpi, b: mpi_sint) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_mul_mpi"]
    pub fn mpi_mul_mpi(X: *mut mpi, A: *const mpi, B: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_mul_int"]
    pub fn mpi_mul_int(X: *mut mpi, A: *const mpi, b: mpi_uint) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_div_mpi"]
    pub fn mpi_div_mpi(Q: *mut mpi, R: *mut mpi, A: *const mpi, B: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_div_int"]
    pub fn mpi_div_int(Q: *mut mpi, R: *mut mpi, A: *const mpi, b: mpi_sint) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_mod_mpi"]
    pub fn mpi_mod_mpi(R: *mut mpi, A: *const mpi, B: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_mod_int"]
    pub fn mpi_mod_int(r: *mut mpi_uint, A: *const mpi, b: mpi_sint) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_exp_mod"]
    pub fn mpi_exp_mod(
        X: *mut mpi,
        A: *const mpi,
        E: *const mpi,
        N: *const mpi,
        _RR: *mut mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_fill_random"]
    pub fn mpi_fill_random(
        X: *mut mpi,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_gcd"]
    pub fn mpi_gcd(G: *mut mpi, A: *const mpi, B: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_inv_mod"]
    pub fn mpi_inv_mod(X: *mut mpi, A: *const mpi, N: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_is_prime"]
    pub fn mpi_is_prime(
        X: *const mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_is_prime_ext"]
    pub fn mpi_is_prime_ext(
        X: *const mpi,
        rounds: raw_types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
pub const MPI_GEN_PRIME_FLAG_DH: mpi_gen_prime_flag_t = 1;
pub const MPI_GEN_PRIME_FLAG_LOW_ERR: mpi_gen_prime_flag_t = 2;
pub type mpi_gen_prime_flag_t = u32;
extern "C" {
    #[link_name = "mbedtls_mpi_gen_prime"]
    pub fn mpi_gen_prime(
        X: *mut mpi,
        nbits: usize,
        flags: raw_types::c_int,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_mpi_self_test"]
    pub fn mpi_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
pub const MD_NONE: md_type_t = 0;
pub const MD_MD2: md_type_t = 1;
pub const MD_MD4: md_type_t = 2;
pub const MD_MD5: md_type_t = 3;
pub const MD_SHA1: md_type_t = 4;
pub const MD_SHA224: md_type_t = 5;
pub const MD_SHA256: md_type_t = 6;
pub const MD_SHA384: md_type_t = 7;
pub const MD_SHA512: md_type_t = 8;
pub const MD_RIPEMD160: md_type_t = 9;
pub type md_type_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md_context_t {
    pub md_info: *const md_info_t,
    pub md_ctx: *mut raw_types::c_void,
    pub hmac_ctx: *mut raw_types::c_void,
}
#[test]
fn bindgen_test_layout_md_context_t() {
    assert_eq!(
        ::core::mem::size_of::<md_context_t>(),
        24usize,
        concat!("Size of: ", stringify!(md_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<md_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(md_context_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_context_t>())).md_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md_context_t),
            "::",
            stringify!(md_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_context_t>())).md_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md_context_t),
            "::",
            stringify!(md_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_context_t>())).hmac_ctx as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(md_context_t),
            "::",
            stringify!(hmac_ctx)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_md_list"]
    pub fn md_list() -> *const raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_info_from_string"]
    pub fn md_info_from_string(md_name: *const raw_types::c_char) -> *const md_info_t;
}
extern "C" {
    #[link_name = "mbedtls_md_info_from_type"]
    pub fn md_info_from_type(md_type: md_type_t) -> *const md_info_t;
}
extern "C" {
    #[link_name = "mbedtls_md_init"]
    pub fn md_init(ctx: *mut md_context_t);
}
extern "C" {
    #[link_name = "mbedtls_md_free"]
    pub fn md_free(ctx: *mut md_context_t);
}
extern "C" {
    #[link_name = "mbedtls_md_init_ctx"]
    pub fn md_init_ctx(ctx: *mut md_context_t, md_info: *const md_info_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_setup"]
    pub fn md_setup(
        ctx: *mut md_context_t,
        md_info: *const md_info_t,
        hmac: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_clone"]
    pub fn md_clone(dst: *mut md_context_t, src: *const md_context_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_get_size"]
    pub fn md_get_size(md_info: *const md_info_t) -> raw_types::c_uchar;
}
extern "C" {
    #[link_name = "mbedtls_md_get_type"]
    pub fn md_get_type(md_info: *const md_info_t) -> md_type_t;
}
extern "C" {
    #[link_name = "mbedtls_md_get_name"]
    pub fn md_get_name(md_info: *const md_info_t) -> *const raw_types::c_char;
}
extern "C" {
    #[link_name = "mbedtls_md_starts"]
    pub fn md_starts(ctx: *mut md_context_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_update"]
    pub fn md_update(
        ctx: *mut md_context_t,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_finish"]
    pub fn md_finish(ctx: *mut md_context_t, output: *mut raw_types::c_uchar) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md"]
    pub fn md(
        md_info: *const md_info_t,
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_file"]
    pub fn md_file(
        md_info: *const md_info_t,
        path: *const raw_types::c_char,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_hmac_starts"]
    pub fn md_hmac_starts(
        ctx: *mut md_context_t,
        key: *const raw_types::c_uchar,
        keylen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_hmac_update"]
    pub fn md_hmac_update(
        ctx: *mut md_context_t,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_hmac_finish"]
    pub fn md_hmac_finish(
        ctx: *mut md_context_t,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_hmac_reset"]
    pub fn md_hmac_reset(ctx: *mut md_context_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_hmac"]
    pub fn md_hmac(
        md_info: *const md_info_t,
        key: *const raw_types::c_uchar,
        keylen: usize,
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md_process"]
    pub fn md_process(ctx: *mut md_context_t, data: *const raw_types::c_uchar) -> raw_types::c_int;
}
pub const P_ALL: idtype_t = 0;
pub const P_PID: idtype_t = 1;
pub const P_PGID: idtype_t = 2;
pub type idtype_t = u32;
pub type _Float32 = f32;
pub type _Float64 = f64;
pub type _Float32x = f64;
pub type _Float64x = f64;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct div_t {
    pub quot: raw_types::c_int,
    pub rem: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    assert_eq!(
        ::core::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::core::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<div_t>())).rem as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ldiv_t {
    pub quot: raw_types::c_long,
    pub rem: raw_types::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct lldiv_t {
    pub quot: raw_types::c_longlong,
    pub rem: raw_types::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    assert_eq!(
        ::core::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::core::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).quot as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<lldiv_t>())).rem as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn __ctype_get_mb_cur_max() -> usize;
}
extern "C" {
    pub fn atof(__nptr: *const raw_types::c_char) -> f64;
}
extern "C" {
    pub fn atoi(__nptr: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn atol(__nptr: *const raw_types::c_char) -> raw_types::c_long;
}
extern "C" {
    pub fn atoll(__nptr: *const raw_types::c_char) -> raw_types::c_longlong;
}
extern "C" {
    pub fn strtod(__nptr: *const raw_types::c_char, __endptr: *mut *mut raw_types::c_char) -> f64;
}
extern "C" {
    pub fn strtof(__nptr: *const raw_types::c_char, __endptr: *mut *mut raw_types::c_char) -> f32;
}
extern "C" {
    pub fn strtold(__nptr: *const raw_types::c_char, __endptr: *mut *mut raw_types::c_char) -> f64;
}
extern "C" {
    pub fn strtol(
        __nptr: *const raw_types::c_char,
        __endptr: *mut *mut raw_types::c_char,
        __base: raw_types::c_int,
    ) -> raw_types::c_long;
}
extern "C" {
    pub fn strtoul(
        __nptr: *const raw_types::c_char,
        __endptr: *mut *mut raw_types::c_char,
        __base: raw_types::c_int,
    ) -> raw_types::c_ulong;
}
extern "C" {
    pub fn strtoq(
        __nptr: *const raw_types::c_char,
        __endptr: *mut *mut raw_types::c_char,
        __base: raw_types::c_int,
    ) -> raw_types::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __nptr: *const raw_types::c_char,
        __endptr: *mut *mut raw_types::c_char,
        __base: raw_types::c_int,
    ) -> raw_types::c_ulonglong;
}
extern "C" {
    pub fn strtoll(
        __nptr: *const raw_types::c_char,
        __endptr: *mut *mut raw_types::c_char,
        __base: raw_types::c_int,
    ) -> raw_types::c_longlong;
}
extern "C" {
    pub fn strtoull(
        __nptr: *const raw_types::c_char,
        __endptr: *mut *mut raw_types::c_char,
        __base: raw_types::c_int,
    ) -> raw_types::c_ulonglong;
}
extern "C" {
    pub fn l64a(__n: raw_types::c_long) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn a64l(__s: *const raw_types::c_char) -> raw_types::c_long;
}
pub type u_char = __u_char;
pub type u_short = __u_short;
pub type u_int = __u_int;
pub type u_long = __u_long;
pub type quad_t = __quad_t;
pub type u_quad_t = __u_quad_t;
pub type fsid_t = __fsid_t;
pub type loff_t = __loff_t;
pub type ino_t = __ino_t;
pub type dev_t = __dev_t;
pub type gid_t = __gid_t;
pub type mode_t = __mode_t;
pub type nlink_t = __nlink_t;
pub type uid_t = __uid_t;
pub type pid_t = __pid_t;
pub type id_t = __id_t;
pub type daddr_t = __daddr_t;
pub type caddr_t = __caddr_t;
pub type key_t = __key_t;
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type time_t = __time_t;
pub type timer_t = __timer_t;
pub type ulong = raw_types::c_ulong;
pub type ushort = raw_types::c_ushort;
pub type uint = raw_types::c_uint;
pub type u_int8_t = raw_types::c_uchar;
pub type u_int16_t = raw_types::c_ushort;
pub type u_int32_t = raw_types::c_uint;
pub type u_int64_t = raw_types::c_ulong;
pub type register_t = raw_types::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigset_t {
    pub __val: [raw_types::c_ulong; 16usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::core::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__sigset_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::core::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::core::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::core::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = raw_types::c_long;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 16usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::core::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::core::mem::align_of::<fd_set>(),
        8usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: raw_types::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: raw_types::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn gnu_dev_major(__dev: __dev_t) -> raw_types::c_uint;
}
extern "C" {
    pub fn gnu_dev_minor(__dev: __dev_t) -> raw_types::c_uint;
}
extern "C" {
    pub fn gnu_dev_makedev(__major: raw_types::c_uint, __minor: raw_types::c_uint) -> __dev_t;
}
pub type blksize_t = __blksize_t;
pub type blkcnt_t = __blkcnt_t;
pub type fsblkcnt_t = __fsblkcnt_t;
pub type fsfilcnt_t = __fsfilcnt_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_rwlock_arch_t {
    pub __readers: raw_types::c_uint,
    pub __writers: raw_types::c_uint,
    pub __wrphase_futex: raw_types::c_uint,
    pub __writers_futex: raw_types::c_uint,
    pub __pad3: raw_types::c_uint,
    pub __pad4: raw_types::c_uint,
    pub __cur_writer: raw_types::c_int,
    pub __shared: raw_types::c_int,
    pub __rwelision: raw_types::c_schar,
    pub __pad1: [raw_types::c_uchar; 7usize],
    pub __pad2: raw_types::c_ulong,
    pub __flags: raw_types::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_rwlock_arch_t() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_rwlock_arch_t>(),
        56usize,
        concat!("Size of: ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_rwlock_arch_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_rwlock_arch_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__readers as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__wrphase_futex as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__wrphase_futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__writers_futex as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__writers_futex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad3 as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad4 as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__cur_writer as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__cur_writer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__shared as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__rwelision as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__rwelision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad1 as *const _ as usize },
        33usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__pad2 as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_rwlock_arch_t>())).__flags as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_rwlock_arch_t),
            "::",
            stringify!(__flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: raw_types::c_int,
    pub __count: raw_types::c_uint,
    pub __owner: raw_types::c_int,
    pub __nusers: raw_types::c_uint,
    pub __kind: raw_types::c_int,
    pub __spins: raw_types::c_short,
    pub __elision: raw_types::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [raw_types::c_uint; 2usize],
    pub __g_size: [raw_types::c_uint; 2usize],
    pub __g1_orig_size: raw_types::c_uint,
    pub __wrefs: raw_types::c_uint,
    pub __g_signals: [raw_types::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: raw_types::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: raw_types::c_uint,
    pub __high: raw_types::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: raw_types::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: raw_types::c_uint,
    pub __high: raw_types::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type pthread_t = raw_types::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [raw_types::c_char; 4usize],
    pub __align: raw_types::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [raw_types::c_char; 4usize],
    pub __align: raw_types::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = raw_types::c_uint;
pub type pthread_once_t = raw_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [raw_types::c_char; 56usize],
    pub __align: raw_types::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_attr_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [raw_types::c_char; 40usize],
    pub __align: raw_types::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [raw_types::c_char; 48usize],
    pub __align: raw_types::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: __pthread_rwlock_arch_t,
    pub __size: [raw_types::c_char; 56usize],
    pub __align: raw_types::c_long,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlock_t>(),
        56usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [raw_types::c_char; 8usize],
    pub __align: raw_types::c_long,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = raw_types::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [raw_types::c_char; 32usize],
    pub __align: raw_types::c_long,
    _bindgen_union_align: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_barrier_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrier_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [raw_types::c_char; 4usize],
    pub __align: raw_types::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::core::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
extern "C" {
    pub fn random() -> raw_types::c_long;
}
extern "C" {
    pub fn srandom(__seed: raw_types::c_uint);
}
extern "C" {
    pub fn initstate(
        __seed: raw_types::c_uint,
        __statebuf: *mut raw_types::c_char,
        __statelen: usize,
    ) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn setstate(__statebuf: *mut raw_types::c_char) -> *mut raw_types::c_char;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct random_data {
    pub fptr: *mut i32,
    pub rptr: *mut i32,
    pub state: *mut i32,
    pub rand_type: raw_types::c_int,
    pub rand_deg: raw_types::c_int,
    pub rand_sep: raw_types::c_int,
    pub end_ptr: *mut i32,
}
#[test]
fn bindgen_test_layout_random_data() {
    assert_eq!(
        ::core::mem::size_of::<random_data>(),
        48usize,
        concat!("Size of: ", stringify!(random_data))
    );
    assert_eq!(
        ::core::mem::align_of::<random_data>(),
        8usize,
        concat!("Alignment of ", stringify!(random_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).fptr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(fptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rptr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_deg as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_deg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).rand_sep as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(rand_sep)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<random_data>())).end_ptr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(random_data),
            "::",
            stringify!(end_ptr)
        )
    );
}
extern "C" {
    pub fn random_r(__buf: *mut random_data, __result: *mut i32) -> raw_types::c_int;
}
extern "C" {
    pub fn srandom_r(__seed: raw_types::c_uint, __buf: *mut random_data) -> raw_types::c_int;
}
extern "C" {
    pub fn initstate_r(
        __seed: raw_types::c_uint,
        __statebuf: *mut raw_types::c_char,
        __statelen: usize,
        __buf: *mut random_data,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn setstate_r(
        __statebuf: *mut raw_types::c_char,
        __buf: *mut random_data,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn rand() -> raw_types::c_int;
}
extern "C" {
    pub fn srand(__seed: raw_types::c_uint);
}
extern "C" {
    pub fn rand_r(__seed: *mut raw_types::c_uint) -> raw_types::c_int;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn erand48(__xsubi: *mut raw_types::c_ushort) -> f64;
}
extern "C" {
    pub fn lrand48() -> raw_types::c_long;
}
extern "C" {
    pub fn nrand48(__xsubi: *mut raw_types::c_ushort) -> raw_types::c_long;
}
extern "C" {
    pub fn mrand48() -> raw_types::c_long;
}
extern "C" {
    pub fn jrand48(__xsubi: *mut raw_types::c_ushort) -> raw_types::c_long;
}
extern "C" {
    pub fn srand48(__seedval: raw_types::c_long);
}
extern "C" {
    pub fn seed48(__seed16v: *mut raw_types::c_ushort) -> *mut raw_types::c_ushort;
}
extern "C" {
    pub fn lcong48(__param: *mut raw_types::c_ushort);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct drand48_data {
    pub __x: [raw_types::c_ushort; 3usize],
    pub __old_x: [raw_types::c_ushort; 3usize],
    pub __c: raw_types::c_ushort,
    pub __init: raw_types::c_ushort,
    pub __a: raw_types::c_ulonglong,
}
#[test]
fn bindgen_test_layout_drand48_data() {
    assert_eq!(
        ::core::mem::size_of::<drand48_data>(),
        24usize,
        concat!("Size of: ", stringify!(drand48_data))
    );
    assert_eq!(
        ::core::mem::align_of::<drand48_data>(),
        8usize,
        concat!("Alignment of ", stringify!(drand48_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__old_x as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__old_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__c as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__c)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__init as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__init)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<drand48_data>())).__a as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(drand48_data),
            "::",
            stringify!(__a)
        )
    );
}
extern "C" {
    pub fn drand48_r(__buffer: *mut drand48_data, __result: *mut f64) -> raw_types::c_int;
}
extern "C" {
    pub fn erand48_r(
        __xsubi: *mut raw_types::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut f64,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn lrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut raw_types::c_long,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn nrand48_r(
        __xsubi: *mut raw_types::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut raw_types::c_long,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn mrand48_r(
        __buffer: *mut drand48_data,
        __result: *mut raw_types::c_long,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn jrand48_r(
        __xsubi: *mut raw_types::c_ushort,
        __buffer: *mut drand48_data,
        __result: *mut raw_types::c_long,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn srand48_r(__seedval: raw_types::c_long, __buffer: *mut drand48_data)
        -> raw_types::c_int;
}
extern "C" {
    pub fn seed48_r(
        __seed16v: *mut raw_types::c_ushort,
        __buffer: *mut drand48_data,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn lcong48_r(
        __param: *mut raw_types::c_ushort,
        __buffer: *mut drand48_data,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn malloc(__size: usize) -> *mut raw_types::c_void;
}
extern "C" {
    pub fn calloc(__nmemb: usize, __size: usize) -> *mut raw_types::c_void;
}
extern "C" {
    pub fn realloc(__ptr: *mut raw_types::c_void, __size: usize) -> *mut raw_types::c_void;
}
extern "C" {
    pub fn free(__ptr: *mut raw_types::c_void);
}
extern "C" {
    pub fn alloca(__size: usize) -> *mut raw_types::c_void;
}
extern "C" {
    pub fn valloc(__size: usize) -> *mut raw_types::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut raw_types::c_void,
        __alignment: usize,
        __size: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn aligned_alloc(__alignment: usize, __size: usize) -> *mut raw_types::c_void;
}
extern "C" {
    pub fn abort();
}
extern "C" {
    pub fn atexit(__func: ::core::option::Option<unsafe extern "C" fn()>) -> raw_types::c_int;
}
extern "C" {
    pub fn at_quick_exit(
        __func: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn on_exit(
        __func: ::core::option::Option<
            unsafe extern "C" fn(__status: raw_types::c_int, __arg: *mut raw_types::c_void),
        >,
        __arg: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn exit(__status: raw_types::c_int);
}
extern "C" {
    pub fn quick_exit(__status: raw_types::c_int);
}
extern "C" {
    pub fn _Exit(__status: raw_types::c_int);
}
extern "C" {
    pub fn getenv(__name: *const raw_types::c_char) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn putenv(__string: *mut raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn setenv(
        __name: *const raw_types::c_char,
        __value: *const raw_types::c_char,
        __replace: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn unsetenv(__name: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn clearenv() -> raw_types::c_int;
}
extern "C" {
    pub fn mktemp(__template: *mut raw_types::c_char) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn mkstemp(__template: *mut raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn mkstemps(
        __template: *mut raw_types::c_char,
        __suffixlen: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn mkdtemp(__template: *mut raw_types::c_char) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn system(__command: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn realpath(
        __name: *const raw_types::c_char,
        __resolved: *mut raw_types::c_char,
    ) -> *mut raw_types::c_char;
}
pub type __compar_fn_t = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *const raw_types::c_void,
        arg2: *const raw_types::c_void,
    ) -> raw_types::c_int,
>;
extern "C" {
    pub fn bsearch(
        __key: *const raw_types::c_void,
        __base: *const raw_types::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    ) -> *mut raw_types::c_void;
}
extern "C" {
    pub fn qsort(
        __base: *mut raw_types::c_void,
        __nmemb: usize,
        __size: usize,
        __compar: __compar_fn_t,
    );
}
extern "C" {
    pub fn abs(__x: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn labs(__x: raw_types::c_long) -> raw_types::c_long;
}
extern "C" {
    pub fn llabs(__x: raw_types::c_longlong) -> raw_types::c_longlong;
}
extern "C" {
    pub fn div(__numer: raw_types::c_int, __denom: raw_types::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(__numer: raw_types::c_long, __denom: raw_types::c_long) -> ldiv_t;
}
extern "C" {
    pub fn lldiv(__numer: raw_types::c_longlong, __denom: raw_types::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn ecvt(
        __value: f64,
        __ndigit: raw_types::c_int,
        __decpt: *mut raw_types::c_int,
        __sign: *mut raw_types::c_int,
    ) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn fcvt(
        __value: f64,
        __ndigit: raw_types::c_int,
        __decpt: *mut raw_types::c_int,
        __sign: *mut raw_types::c_int,
    ) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn gcvt(
        __value: f64,
        __ndigit: raw_types::c_int,
        __buf: *mut raw_types::c_char,
    ) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn qecvt(
        __value: f64,
        __ndigit: raw_types::c_int,
        __decpt: *mut raw_types::c_int,
        __sign: *mut raw_types::c_int,
    ) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn qfcvt(
        __value: f64,
        __ndigit: raw_types::c_int,
        __decpt: *mut raw_types::c_int,
        __sign: *mut raw_types::c_int,
    ) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn qgcvt(
        __value: f64,
        __ndigit: raw_types::c_int,
        __buf: *mut raw_types::c_char,
    ) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn ecvt_r(
        __value: f64,
        __ndigit: raw_types::c_int,
        __decpt: *mut raw_types::c_int,
        __sign: *mut raw_types::c_int,
        __buf: *mut raw_types::c_char,
        __len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn fcvt_r(
        __value: f64,
        __ndigit: raw_types::c_int,
        __decpt: *mut raw_types::c_int,
        __sign: *mut raw_types::c_int,
        __buf: *mut raw_types::c_char,
        __len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn qecvt_r(
        __value: f64,
        __ndigit: raw_types::c_int,
        __decpt: *mut raw_types::c_int,
        __sign: *mut raw_types::c_int,
        __buf: *mut raw_types::c_char,
        __len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn qfcvt_r(
        __value: f64,
        __ndigit: raw_types::c_int,
        __decpt: *mut raw_types::c_int,
        __sign: *mut raw_types::c_int,
        __buf: *mut raw_types::c_char,
        __len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn mblen(__s: *const raw_types::c_char, __n: usize) -> raw_types::c_int;
}
extern "C" {
    pub fn mbtowc(
        __pwc: *mut wchar_t,
        __s: *const raw_types::c_char,
        __n: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn wctomb(__s: *mut raw_types::c_char, __wchar: wchar_t) -> raw_types::c_int;
}
extern "C" {
    pub fn mbstowcs(__pwcs: *mut wchar_t, __s: *const raw_types::c_char, __n: usize) -> usize;
}
extern "C" {
    pub fn wcstombs(__s: *mut raw_types::c_char, __pwcs: *const wchar_t, __n: usize) -> usize;
}
extern "C" {
    pub fn rpmatch(__response: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn getsubopt(
        __optionp: *mut *mut raw_types::c_char,
        __tokens: *const *mut raw_types::c_char,
        __valuep: *mut *mut raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn getloadavg(__loadavg: *mut f64, __nelem: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sched_param {
    pub sched_priority: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::core::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::core::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sched_param>())).sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(sched_priority)
        )
    );
}
pub type __cpu_mask = raw_types::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 16usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::core::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cpu_set_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> raw_types::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> raw_types::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> raw_types::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: raw_types::c_int,
        __param: *const sched_param,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn sched_yield() -> raw_types::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct tm {
    pub tm_sec: raw_types::c_int,
    pub tm_min: raw_types::c_int,
    pub tm_hour: raw_types::c_int,
    pub tm_mday: raw_types::c_int,
    pub tm_mon: raw_types::c_int,
    pub tm_year: raw_types::c_int,
    pub tm_wday: raw_types::c_int,
    pub tm_yday: raw_types::c_int,
    pub tm_isdst: raw_types::c_int,
    pub tm_gmtoff: raw_types::c_long,
    pub tm_zone: *const raw_types::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::core::mem::size_of::<tm>(),
        56usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::core::mem::align_of::<tm>(),
        8usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<tm>())).tm_zone as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::core::mem::size_of::<itimerspec>(),
        32usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::core::mem::align_of::<itimerspec>(),
        8usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const raw_types::c_ushort,
    pub __ctype_tolower: *const raw_types::c_int,
    pub __ctype_toupper: *const raw_types::c_int,
    pub __names: [*const raw_types::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::core::mem::size_of::<__locale_struct>(),
        232usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::core::mem::align_of::<__locale_struct>(),
        8usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut raw_types::c_char,
        __maxsize: usize,
        __format: *const raw_types::c_char,
        __tp: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn strftime_l(
        __s: *mut raw_types::c_char,
        __maxsize: usize,
        __format: *const raw_types::c_char,
        __tp: *const tm,
        __loc: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn asctime_r(__tp: *const tm, __buf: *mut raw_types::c_char) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn ctime_r(__timer: *const time_t, __buf: *mut raw_types::c_char)
        -> *mut raw_types::c_char;
}
extern "C" {
    #[link_name = "__tzname"]
    pub static mut __tzname: [*mut raw_types::c_char; 2usize];
}
extern "C" {
    #[link_name = "__daylight"]
    pub static mut __daylight: raw_types::c_int;
}
extern "C" {
    #[link_name = "__timezone"]
    pub static mut __timezone: raw_types::c_long;
}
extern "C" {
    #[link_name = "tzname"]
    pub static mut tzname: [*mut raw_types::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    #[link_name = "daylight"]
    pub static mut daylight: raw_types::c_int;
}
extern "C" {
    #[link_name = "timezone"]
    pub static mut timezone: raw_types::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> raw_types::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> raw_types::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> raw_types::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> raw_types::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: raw_types::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> raw_types::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: raw_types::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> raw_types::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> raw_types::c_int;
}
extern "C" {
    pub fn timespec_get(__ts: *mut timespec, __base: raw_types::c_int) -> raw_types::c_int;
}
pub type __jmp_buf = [raw_types::c_long; 8usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = u32;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 = 0;
pub type _bindgen_ty_2 = u32;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = u32;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 = 2;
pub type _bindgen_ty_4 = u32;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 = 0;
pub type _bindgen_ty_5 = u32;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = u32;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = u32;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::core::option::Option<unsafe extern "C" fn(arg1: *mut raw_types::c_void)>,
    pub __arg: *mut raw_types::c_void,
    pub __canceltype: raw_types::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::core::mem::size_of::<_pthread_cleanup_buffer>(),
        32usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::core::mem::align_of::<_pthread_cleanup_buffer>(),
        8usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = u32;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = u32;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut raw_types::c_void) -> *mut raw_types::c_void,
        >,
        __arg: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut raw_types::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut raw_types::c_void,
        __stacksize: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut raw_types::c_void,
        __stacksize: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: raw_types::c_int,
        __param: *const sched_param,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut raw_types::c_int,
        __param: *mut sched_param,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: raw_types::c_int,
        __oldstate: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: raw_types::c_int,
        __oldtype: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut raw_types::c_void; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: raw_types::c_int,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        72usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_unwind_buf_t>(),
        104usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::core::option::Option<unsafe extern "C" fn(arg1: *mut raw_types::c_void)>,
    pub __cancel_arg: *mut raw_types::c_void,
    pub __do_it: raw_types::c_int,
    pub __cancel_type: raw_types::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::core::mem::size_of::<__pthread_cleanup_frame>(),
        24usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::core::mem::align_of::<__pthread_cleanup_frame>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(__env: *mut __jmp_buf_tag, __savemask: raw_types::c_int)
        -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: raw_types::c_int,
        __old_ceiling: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::core::option::Option<
            unsafe extern "C" fn(arg1: *mut raw_types::c_void),
        >,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut raw_types::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::core::option::Option<unsafe extern "C" fn()>,
        __parent: ::core::option::Option<unsafe extern "C" fn()>,
        __child: ::core::option::Option<unsafe extern "C" fn()>,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct threading_mutex_t {
    pub mutex: pthread_mutex_t,
    pub is_valid: raw_types::c_char,
}
#[test]
fn bindgen_test_layout_threading_mutex_t() {
    assert_eq!(
        ::core::mem::size_of::<threading_mutex_t>(),
        48usize,
        concat!("Size of: ", stringify!(threading_mutex_t))
    );
    assert_eq!(
        ::core::mem::align_of::<threading_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(threading_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<threading_mutex_t>())).mutex as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(threading_mutex_t),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<threading_mutex_t>())).is_valid as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(threading_mutex_t),
            "::",
            stringify!(is_valid)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_mutex_init"]
    pub static mut mutex_init:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut threading_mutex_t)>;
}
extern "C" {
    #[link_name = "mbedtls_mutex_free"]
    pub static mut mutex_free:
        ::core::option::Option<unsafe extern "C" fn(mutex: *mut threading_mutex_t)>;
}
extern "C" {
    #[link_name = "mbedtls_mutex_lock"]
    pub static mut mutex_lock: ::core::option::Option<
        unsafe extern "C" fn(mutex: *mut threading_mutex_t) -> raw_types::c_int,
    >;
}
extern "C" {
    #[link_name = "mbedtls_mutex_unlock"]
    pub static mut mutex_unlock: ::core::option::Option<
        unsafe extern "C" fn(mutex: *mut threading_mutex_t) -> raw_types::c_int,
    >;
}
extern "C" {
    #[link_name = "mbedtls_mutex_trylock"]
    pub static mut mutex_trylock: ::core::option::Option<
        unsafe extern "C" fn(mutex: *mut threading_mutex_t) -> raw_types::c_int,
    >;
}
extern "C" {
    #[link_name = "mbedtls_threading_readdir_mutex"]
    pub static mut threading_readdir_mutex: threading_mutex_t;
}
extern "C" {
    #[link_name = "mbedtls_threading_gmtime_mutex"]
    pub static mut threading_gmtime_mutex: threading_mutex_t;
}
extern "C" {
    #[link_name = "mbedtls_threading_trylock"]
    pub static mut threading_trylock: raw_types::c_int;
}
pub const ECP_DP_NONE: ecp_group_id = 0;
pub const ECP_DP_SECP192R1: ecp_group_id = 1;
pub const ECP_DP_SECP224R1: ecp_group_id = 2;
pub const ECP_DP_SECP256R1: ecp_group_id = 3;
pub const ECP_DP_SECP384R1: ecp_group_id = 4;
pub const ECP_DP_SECP521R1: ecp_group_id = 5;
pub const ECP_DP_BP256R1: ecp_group_id = 6;
pub const ECP_DP_BP384R1: ecp_group_id = 7;
pub const ECP_DP_BP512R1: ecp_group_id = 8;
pub const ECP_DP_CURVE25519: ecp_group_id = 9;
pub const ECP_DP_SECP192K1: ecp_group_id = 10;
pub const ECP_DP_SECP224K1: ecp_group_id = 11;
pub const ECP_DP_SECP256K1: ecp_group_id = 12;
pub const ECP_DP_CURVE448: ecp_group_id = 13;
pub type ecp_group_id = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecp_curve_info {
    pub grp_id: ecp_group_id,
    pub tls_id: u16,
    pub bit_size: u16,
    pub name: *const raw_types::c_char,
}
#[test]
fn bindgen_test_layout_ecp_curve_info() {
    assert_eq!(
        ::core::mem::size_of::<ecp_curve_info>(),
        16usize,
        concat!("Size of: ", stringify!(ecp_curve_info))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_curve_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ecp_curve_info))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_curve_info>())).grp_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(grp_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_curve_info>())).tls_id as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(tls_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_curve_info>())).bit_size as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(bit_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_curve_info>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_curve_info),
            "::",
            stringify!(name)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecp_point {
    pub X: mpi,
    pub Y: mpi,
    pub Z: mpi,
}
#[test]
fn bindgen_test_layout_ecp_point() {
    assert_eq!(
        ::core::mem::size_of::<ecp_point>(),
        72usize,
        concat!("Size of: ", stringify!(ecp_point))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_point>(),
        8usize,
        concat!("Alignment of ", stringify!(ecp_point))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_point>())).X as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_point),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_point>())).Y as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_point),
            "::",
            stringify!(Y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_point>())).Z as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_point),
            "::",
            stringify!(Z)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecp_group {
    pub id: ecp_group_id,
    pub P: mpi,
    pub A: mpi,
    pub B: mpi,
    pub G: ecp_point,
    pub N: mpi,
    pub pbits: usize,
    pub nbits: usize,
    pub h: raw_types::c_uint,
    pub modp: ::core::option::Option<unsafe extern "C" fn(arg1: *mut mpi) -> raw_types::c_int>,
    pub t_pre: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ecp_point,
            arg2: *mut raw_types::c_void,
        ) -> raw_types::c_int,
    >,
    pub t_post: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ecp_point,
            arg2: *mut raw_types::c_void,
        ) -> raw_types::c_int,
    >,
    pub t_data: *mut raw_types::c_void,
    pub T: *mut ecp_point,
    pub T_size: usize,
}
#[test]
fn bindgen_test_layout_ecp_group() {
    assert_eq!(
        ::core::mem::size_of::<ecp_group>(),
        248usize,
        concat!("Size of: ", stringify!(ecp_group))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_group>(),
        8usize,
        concat!("Alignment of ", stringify!(ecp_group))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).P as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).A as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(A)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).B as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(B)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).G as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).N as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).pbits as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(pbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).nbits as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(nbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).h as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).modp as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(modp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).t_pre as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(t_pre)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).t_post as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(t_post)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).t_data as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(t_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).T as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(T)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_group>())).T_size as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_group),
            "::",
            stringify!(T_size)
        )
    );
}
pub type ecp_restart_ctx = raw_types::c_void;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecp_keypair {
    pub grp: ecp_group,
    pub d: mpi,
    pub Q: ecp_point,
}
#[test]
fn bindgen_test_layout_ecp_keypair() {
    assert_eq!(
        ::core::mem::size_of::<ecp_keypair>(),
        344usize,
        concat!("Size of: ", stringify!(ecp_keypair))
    );
    assert_eq!(
        ::core::mem::align_of::<ecp_keypair>(),
        8usize,
        concat!("Alignment of ", stringify!(ecp_keypair))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_keypair>())).grp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_keypair),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_keypair>())).d as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_keypair),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecp_keypair>())).Q as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ecp_keypair),
            "::",
            stringify!(Q)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ecp_curve_list"]
    pub fn ecp_curve_list() -> *const ecp_curve_info;
}
extern "C" {
    #[link_name = "mbedtls_ecp_grp_id_list"]
    pub fn ecp_grp_id_list() -> *const ecp_group_id;
}
extern "C" {
    #[link_name = "mbedtls_ecp_curve_info_from_grp_id"]
    pub fn ecp_curve_info_from_grp_id(grp_id: ecp_group_id) -> *const ecp_curve_info;
}
extern "C" {
    #[link_name = "mbedtls_ecp_curve_info_from_tls_id"]
    pub fn ecp_curve_info_from_tls_id(tls_id: u16) -> *const ecp_curve_info;
}
extern "C" {
    #[link_name = "mbedtls_ecp_curve_info_from_name"]
    pub fn ecp_curve_info_from_name(name: *const raw_types::c_char) -> *const ecp_curve_info;
}
extern "C" {
    #[link_name = "mbedtls_ecp_point_init"]
    pub fn ecp_point_init(pt: *mut ecp_point);
}
extern "C" {
    #[link_name = "mbedtls_ecp_group_init"]
    pub fn ecp_group_init(grp: *mut ecp_group);
}
extern "C" {
    #[link_name = "mbedtls_ecp_keypair_init"]
    pub fn ecp_keypair_init(key: *mut ecp_keypair);
}
extern "C" {
    #[link_name = "mbedtls_ecp_point_free"]
    pub fn ecp_point_free(pt: *mut ecp_point);
}
extern "C" {
    #[link_name = "mbedtls_ecp_group_free"]
    pub fn ecp_group_free(grp: *mut ecp_group);
}
extern "C" {
    #[link_name = "mbedtls_ecp_keypair_free"]
    pub fn ecp_keypair_free(key: *mut ecp_keypair);
}
extern "C" {
    #[link_name = "mbedtls_ecp_copy"]
    pub fn ecp_copy(P: *mut ecp_point, Q: *const ecp_point) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_group_copy"]
    pub fn ecp_group_copy(dst: *mut ecp_group, src: *const ecp_group) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_set_zero"]
    pub fn ecp_set_zero(pt: *mut ecp_point) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_is_zero"]
    pub fn ecp_is_zero(pt: *mut ecp_point) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_point_cmp"]
    pub fn ecp_point_cmp(P: *const ecp_point, Q: *const ecp_point) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_point_read_string"]
    pub fn ecp_point_read_string(
        P: *mut ecp_point,
        radix: raw_types::c_int,
        x: *const raw_types::c_char,
        y: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_point_write_binary"]
    pub fn ecp_point_write_binary(
        grp: *const ecp_group,
        P: *const ecp_point,
        format: raw_types::c_int,
        olen: *mut usize,
        buf: *mut raw_types::c_uchar,
        buflen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_point_read_binary"]
    pub fn ecp_point_read_binary(
        grp: *const ecp_group,
        P: *mut ecp_point,
        buf: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_tls_read_point"]
    pub fn ecp_tls_read_point(
        grp: *const ecp_group,
        pt: *mut ecp_point,
        buf: *mut *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_tls_write_point"]
    pub fn ecp_tls_write_point(
        grp: *const ecp_group,
        pt: *const ecp_point,
        format: raw_types::c_int,
        olen: *mut usize,
        buf: *mut raw_types::c_uchar,
        blen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_group_load"]
    pub fn ecp_group_load(grp: *mut ecp_group, id: ecp_group_id) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_tls_read_group"]
    pub fn ecp_tls_read_group(
        grp: *mut ecp_group,
        buf: *mut *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_tls_read_group_id"]
    pub fn ecp_tls_read_group_id(
        grp: *mut ecp_group_id,
        buf: *mut *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_tls_write_group"]
    pub fn ecp_tls_write_group(
        grp: *const ecp_group,
        olen: *mut usize,
        buf: *mut raw_types::c_uchar,
        blen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_mul"]
    pub fn ecp_mul(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_mul_restartable"]
    pub fn ecp_mul_restartable(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        rs_ctx: *mut ecp_restart_ctx,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_muladd"]
    pub fn ecp_muladd(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        n: *const mpi,
        Q: *const ecp_point,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_muladd_restartable"]
    pub fn ecp_muladd_restartable(
        grp: *mut ecp_group,
        R: *mut ecp_point,
        m: *const mpi,
        P: *const ecp_point,
        n: *const mpi,
        Q: *const ecp_point,
        rs_ctx: *mut ecp_restart_ctx,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_check_pubkey"]
    pub fn ecp_check_pubkey(grp: *const ecp_group, pt: *const ecp_point) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_check_privkey"]
    pub fn ecp_check_privkey(grp: *const ecp_group, d: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_gen_privkey"]
    pub fn ecp_gen_privkey(
        grp: *const ecp_group,
        d: *mut mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_gen_keypair_base"]
    pub fn ecp_gen_keypair_base(
        grp: *mut ecp_group,
        G: *const ecp_point,
        d: *mut mpi,
        Q: *mut ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_gen_keypair"]
    pub fn ecp_gen_keypair(
        grp: *mut ecp_group,
        d: *mut mpi,
        Q: *mut ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_gen_key"]
    pub fn ecp_gen_key(
        grp_id: ecp_group_id,
        key: *mut ecp_keypair,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_check_pub_priv"]
    pub fn ecp_check_pub_priv(
        pub_: *const ecp_keypair,
        prv: *const ecp_keypair,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecp_self_test"]
    pub fn ecp_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsa_context {
    pub ver: raw_types::c_int,
    pub len: usize,
    pub N: mpi,
    pub E: mpi,
    pub D: mpi,
    pub P: mpi,
    pub Q: mpi,
    pub DP: mpi,
    pub DQ: mpi,
    pub QP: mpi,
    pub RN: mpi,
    pub RP: mpi,
    pub RQ: mpi,
    pub Vi: mpi,
    pub Vf: mpi,
    pub padding: raw_types::c_int,
    pub hash_id: raw_types::c_int,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_rsa_context() {
    assert_eq!(
        ::core::mem::size_of::<rsa_context>(),
        384usize,
        concat!("Size of: ", stringify!(rsa_context))
    );
    assert_eq!(
        ::core::mem::align_of::<rsa_context>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).ver as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).N as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(N)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).E as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(E)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).D as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(D)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).P as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).Q as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(Q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).DP as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(DP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).DQ as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(DQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).QP as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(QP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).RN as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(RN)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).RP as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(RP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).RQ as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(RQ)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).Vi as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(Vi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).Vf as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(Vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).padding as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).hash_id as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(hash_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_context>())).mutex as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_context),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_rsa_init"]
    pub fn rsa_init(ctx: *mut rsa_context, padding: raw_types::c_int, hash_id: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_rsa_import"]
    pub fn rsa_import(
        ctx: *mut rsa_context,
        N: *const mpi,
        P: *const mpi,
        Q: *const mpi,
        D: *const mpi,
        E: *const mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_import_raw"]
    pub fn rsa_import_raw(
        ctx: *mut rsa_context,
        N: *const raw_types::c_uchar,
        N_len: usize,
        P: *const raw_types::c_uchar,
        P_len: usize,
        Q: *const raw_types::c_uchar,
        Q_len: usize,
        D: *const raw_types::c_uchar,
        D_len: usize,
        E: *const raw_types::c_uchar,
        E_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_complete"]
    pub fn rsa_complete(ctx: *mut rsa_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_export"]
    pub fn rsa_export(
        ctx: *const rsa_context,
        N: *mut mpi,
        P: *mut mpi,
        Q: *mut mpi,
        D: *mut mpi,
        E: *mut mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_export_raw"]
    pub fn rsa_export_raw(
        ctx: *const rsa_context,
        N: *mut raw_types::c_uchar,
        N_len: usize,
        P: *mut raw_types::c_uchar,
        P_len: usize,
        Q: *mut raw_types::c_uchar,
        Q_len: usize,
        D: *mut raw_types::c_uchar,
        D_len: usize,
        E: *mut raw_types::c_uchar,
        E_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_export_crt"]
    pub fn rsa_export_crt(
        ctx: *const rsa_context,
        DP: *mut mpi,
        DQ: *mut mpi,
        QP: *mut mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_set_padding"]
    pub fn rsa_set_padding(
        ctx: *mut rsa_context,
        padding: raw_types::c_int,
        hash_id: raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "mbedtls_rsa_get_len"]
    pub fn rsa_get_len(ctx: *const rsa_context) -> usize;
}
extern "C" {
    #[link_name = "mbedtls_rsa_gen_key"]
    pub fn rsa_gen_key(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        nbits: raw_types::c_uint,
        exponent: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_check_pubkey"]
    pub fn rsa_check_pubkey(ctx: *const rsa_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_check_privkey"]
    pub fn rsa_check_privkey(ctx: *const rsa_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_check_pub_priv"]
    pub fn rsa_check_pub_priv(
        pub_: *const rsa_context,
        prv: *const rsa_context,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_public"]
    pub fn rsa_public(
        ctx: *mut rsa_context,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_private"]
    pub fn rsa_private(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_pkcs1_encrypt"]
    pub fn rsa_pkcs1_encrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        ilen: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_rsaes_pkcs1_v15_encrypt"]
    pub fn rsa_rsaes_pkcs1_v15_encrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        ilen: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_rsaes_oaep_encrypt"]
    pub fn rsa_rsaes_oaep_encrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        label: *const raw_types::c_uchar,
        label_len: usize,
        ilen: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_pkcs1_decrypt"]
    pub fn rsa_pkcs1_decrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        olen: *mut usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
        output_max_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_rsaes_pkcs1_v15_decrypt"]
    pub fn rsa_rsaes_pkcs1_v15_decrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        olen: *mut usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
        output_max_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_rsaes_oaep_decrypt"]
    pub fn rsa_rsaes_oaep_decrypt(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        label: *const raw_types::c_uchar,
        label_len: usize,
        olen: *mut usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
        output_max_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_pkcs1_sign"]
    pub fn rsa_pkcs1_sign(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        md_alg: md_type_t,
        hashlen: raw_types::c_uint,
        hash: *const raw_types::c_uchar,
        sig: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_rsassa_pkcs1_v15_sign"]
    pub fn rsa_rsassa_pkcs1_v15_sign(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        md_alg: md_type_t,
        hashlen: raw_types::c_uint,
        hash: *const raw_types::c_uchar,
        sig: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_rsassa_pss_sign"]
    pub fn rsa_rsassa_pss_sign(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        md_alg: md_type_t,
        hashlen: raw_types::c_uint,
        hash: *const raw_types::c_uchar,
        sig: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_pkcs1_verify"]
    pub fn rsa_pkcs1_verify(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        md_alg: md_type_t,
        hashlen: raw_types::c_uint,
        hash: *const raw_types::c_uchar,
        sig: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_rsassa_pkcs1_v15_verify"]
    pub fn rsa_rsassa_pkcs1_v15_verify(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        md_alg: md_type_t,
        hashlen: raw_types::c_uint,
        hash: *const raw_types::c_uchar,
        sig: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_rsassa_pss_verify"]
    pub fn rsa_rsassa_pss_verify(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        md_alg: md_type_t,
        hashlen: raw_types::c_uint,
        hash: *const raw_types::c_uchar,
        sig: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_rsassa_pss_verify_ext"]
    pub fn rsa_rsassa_pss_verify_ext(
        ctx: *mut rsa_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        md_alg: md_type_t,
        hashlen: raw_types::c_uint,
        hash: *const raw_types::c_uchar,
        mgf1_hash_id: md_type_t,
        expected_salt_len: raw_types::c_int,
        sig: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_copy"]
    pub fn rsa_copy(dst: *mut rsa_context, src: *const rsa_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_free"]
    pub fn rsa_free(ctx: *mut rsa_context);
}
extern "C" {
    #[link_name = "mbedtls_rsa_self_test"]
    pub fn rsa_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
pub type ecdsa_context = ecp_keypair;
pub type ecdsa_restart_ctx = raw_types::c_void;
extern "C" {
    #[link_name = "mbedtls_ecdsa_sign"]
    pub fn ecdsa_sign(
        grp: *mut ecp_group,
        r: *mut mpi,
        s: *mut mpi,
        d: *const mpi,
        buf: *const raw_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_sign_det"]
    pub fn ecdsa_sign_det(
        grp: *mut ecp_group,
        r: *mut mpi,
        s: *mut mpi,
        d: *const mpi,
        buf: *const raw_types::c_uchar,
        blen: usize,
        md_alg: md_type_t,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_verify"]
    pub fn ecdsa_verify(
        grp: *mut ecp_group,
        buf: *const raw_types::c_uchar,
        blen: usize,
        Q: *const ecp_point,
        r: *const mpi,
        s: *const mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_write_signature"]
    pub fn ecdsa_write_signature(
        ctx: *mut ecdsa_context,
        md_alg: md_type_t,
        hash: *const raw_types::c_uchar,
        hlen: usize,
        sig: *mut raw_types::c_uchar,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_write_signature_restartable"]
    pub fn ecdsa_write_signature_restartable(
        ctx: *mut ecdsa_context,
        md_alg: md_type_t,
        hash: *const raw_types::c_uchar,
        hlen: usize,
        sig: *mut raw_types::c_uchar,
        slen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        rs_ctx: *mut ecdsa_restart_ctx,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_write_signature_det"]
    pub fn ecdsa_write_signature_det(
        ctx: *mut ecdsa_context,
        hash: *const raw_types::c_uchar,
        hlen: usize,
        sig: *mut raw_types::c_uchar,
        slen: *mut usize,
        md_alg: md_type_t,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_read_signature"]
    pub fn ecdsa_read_signature(
        ctx: *mut ecdsa_context,
        hash: *const raw_types::c_uchar,
        hlen: usize,
        sig: *const raw_types::c_uchar,
        slen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_read_signature_restartable"]
    pub fn ecdsa_read_signature_restartable(
        ctx: *mut ecdsa_context,
        hash: *const raw_types::c_uchar,
        hlen: usize,
        sig: *const raw_types::c_uchar,
        slen: usize,
        rs_ctx: *mut ecdsa_restart_ctx,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_genkey"]
    pub fn ecdsa_genkey(
        ctx: *mut ecdsa_context,
        gid: ecp_group_id,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_from_keypair"]
    pub fn ecdsa_from_keypair(ctx: *mut ecdsa_context, key: *const ecp_keypair)
        -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_init"]
    pub fn ecdsa_init(ctx: *mut ecdsa_context);
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_free"]
    pub fn ecdsa_free(ctx: *mut ecdsa_context);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_buf {
    pub tag: raw_types::c_int,
    pub len: usize,
    pub p: *mut raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_asn1_buf() {
    assert_eq!(
        ::core::mem::size_of::<asn1_buf>(),
        24usize,
        concat!("Size of: ", stringify!(asn1_buf))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_buf))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_buf>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_buf),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_buf>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_buf),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_buf>())).p as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_buf),
            "::",
            stringify!(p)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_bitstring {
    pub len: usize,
    pub unused_bits: raw_types::c_uchar,
    pub p: *mut raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_asn1_bitstring() {
    assert_eq!(
        ::core::mem::size_of::<asn1_bitstring>(),
        24usize,
        concat!("Size of: ", stringify!(asn1_bitstring))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_bitstring>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_bitstring))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_bitstring>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_bitstring),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_bitstring>())).unused_bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_bitstring),
            "::",
            stringify!(unused_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_bitstring>())).p as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_bitstring),
            "::",
            stringify!(p)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_sequence {
    pub buf: asn1_buf,
    pub next: *mut asn1_sequence,
}
#[test]
fn bindgen_test_layout_asn1_sequence() {
    assert_eq!(
        ::core::mem::size_of::<asn1_sequence>(),
        32usize,
        concat!("Size of: ", stringify!(asn1_sequence))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_sequence>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_sequence))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_sequence>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_sequence),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_sequence>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_sequence),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct asn1_named_data {
    pub oid: asn1_buf,
    pub val: asn1_buf,
    pub next: *mut asn1_named_data,
    pub next_merged: raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_asn1_named_data() {
    assert_eq!(
        ::core::mem::size_of::<asn1_named_data>(),
        64usize,
        concat!("Size of: ", stringify!(asn1_named_data))
    );
    assert_eq!(
        ::core::mem::align_of::<asn1_named_data>(),
        8usize,
        concat!("Alignment of ", stringify!(asn1_named_data))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_named_data>())).oid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_named_data>())).val as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_named_data>())).next as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<asn1_named_data>())).next_merged as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(asn1_named_data),
            "::",
            stringify!(next_merged)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_asn1_get_len"]
    pub fn asn1_get_len(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        len: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_get_tag"]
    pub fn asn1_get_tag(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        len: *mut usize,
        tag: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_get_bool"]
    pub fn asn1_get_bool(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        val: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_get_int"]
    pub fn asn1_get_int(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        val: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_get_bitstring"]
    pub fn asn1_get_bitstring(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        bs: *mut asn1_bitstring,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_get_bitstring_null"]
    pub fn asn1_get_bitstring_null(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        len: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_get_sequence_of"]
    pub fn asn1_get_sequence_of(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        cur: *mut asn1_sequence,
        tag: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_get_mpi"]
    pub fn asn1_get_mpi(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        X: *mut mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_get_alg"]
    pub fn asn1_get_alg(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        alg: *mut asn1_buf,
        params: *mut asn1_buf,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_get_alg_null"]
    pub fn asn1_get_alg_null(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        alg: *mut asn1_buf,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_find_named_data"]
    pub fn asn1_find_named_data(
        list: *mut asn1_named_data,
        oid: *const raw_types::c_char,
        len: usize,
    ) -> *mut asn1_named_data;
}
extern "C" {
    #[link_name = "mbedtls_asn1_free_named_data"]
    pub fn asn1_free_named_data(entry: *mut asn1_named_data);
}
extern "C" {
    #[link_name = "mbedtls_asn1_free_named_data_list"]
    pub fn asn1_free_named_data_list(head: *mut *mut asn1_named_data);
}
pub const PK_NONE: pk_type_t = 0;
pub const PK_RSA: pk_type_t = 1;
pub const PK_ECKEY: pk_type_t = 2;
pub const PK_ECKEY_DH: pk_type_t = 3;
pub const PK_ECDSA: pk_type_t = 4;
pub const PK_RSA_ALT: pk_type_t = 5;
pub const PK_RSASSA_PSS: pk_type_t = 6;
pub type pk_type_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pk_rsassa_pss_options {
    pub mgf1_hash_id: md_type_t,
    pub expected_salt_len: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_pk_rsassa_pss_options() {
    assert_eq!(
        ::core::mem::size_of::<pk_rsassa_pss_options>(),
        8usize,
        concat!("Size of: ", stringify!(pk_rsassa_pss_options))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_rsassa_pss_options>(),
        4usize,
        concat!("Alignment of ", stringify!(pk_rsassa_pss_options))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pk_rsassa_pss_options>())).mgf1_hash_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_rsassa_pss_options),
            "::",
            stringify!(mgf1_hash_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<pk_rsassa_pss_options>())).expected_salt_len as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_rsassa_pss_options),
            "::",
            stringify!(expected_salt_len)
        )
    );
}
pub const PK_DEBUG_NONE: pk_debug_type = 0;
pub const PK_DEBUG_MPI: pk_debug_type = 1;
pub const PK_DEBUG_ECP: pk_debug_type = 2;
pub type pk_debug_type = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pk_debug_item {
    pub type_: pk_debug_type,
    pub name: *const raw_types::c_char,
    pub value: *mut raw_types::c_void,
}
#[test]
fn bindgen_test_layout_pk_debug_item() {
    assert_eq!(
        ::core::mem::size_of::<pk_debug_item>(),
        24usize,
        concat!("Size of: ", stringify!(pk_debug_item))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_debug_item>(),
        8usize,
        concat!("Alignment of ", stringify!(pk_debug_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_debug_item>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_debug_item),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_debug_item>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_debug_item),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_debug_item>())).value as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_debug_item),
            "::",
            stringify!(value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pk_context {
    pub pk_info: *const pk_info_t,
    pub pk_ctx: *mut raw_types::c_void,
}
#[test]
fn bindgen_test_layout_pk_context() {
    assert_eq!(
        ::core::mem::size_of::<pk_context>(),
        16usize,
        concat!("Size of: ", stringify!(pk_context))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_context>(),
        8usize,
        concat!("Alignment of ", stringify!(pk_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_context>())).pk_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_context),
            "::",
            stringify!(pk_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_context>())).pk_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_context),
            "::",
            stringify!(pk_ctx)
        )
    );
}
pub type pk_restart_ctx = raw_types::c_void;
pub type pk_rsa_alt_decrypt_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut raw_types::c_void,
        mode: raw_types::c_int,
        olen: *mut usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
        output_max_len: usize,
    ) -> raw_types::c_int,
>;
pub type pk_rsa_alt_sign_func = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut raw_types::c_void,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        mode: raw_types::c_int,
        md_alg: md_type_t,
        hashlen: raw_types::c_uint,
        hash: *const raw_types::c_uchar,
        sig: *mut raw_types::c_uchar,
    ) -> raw_types::c_int,
>;
pub type pk_rsa_alt_key_len_func =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut raw_types::c_void) -> usize>;
extern "C" {
    #[link_name = "mbedtls_pk_info_from_type"]
    pub fn pk_info_from_type(pk_type: pk_type_t) -> *const pk_info_t;
}
extern "C" {
    #[link_name = "mbedtls_pk_init"]
    pub fn pk_init(ctx: *mut pk_context);
}
extern "C" {
    #[link_name = "mbedtls_pk_free"]
    pub fn pk_free(ctx: *mut pk_context);
}
extern "C" {
    #[link_name = "mbedtls_pk_setup"]
    pub fn pk_setup(ctx: *mut pk_context, info: *const pk_info_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_setup_rsa_alt"]
    pub fn pk_setup_rsa_alt(
        ctx: *mut pk_context,
        key: *mut raw_types::c_void,
        decrypt_func: pk_rsa_alt_decrypt_func,
        sign_func: pk_rsa_alt_sign_func,
        key_len_func: pk_rsa_alt_key_len_func,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_get_bitlen"]
    pub fn pk_get_bitlen(ctx: *const pk_context) -> usize;
}
extern "C" {
    #[link_name = "mbedtls_pk_can_do"]
    pub fn pk_can_do(ctx: *const pk_context, type_: pk_type_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_verify"]
    pub fn pk_verify(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const raw_types::c_uchar,
        hash_len: usize,
        sig: *const raw_types::c_uchar,
        sig_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_verify_restartable"]
    pub fn pk_verify_restartable(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const raw_types::c_uchar,
        hash_len: usize,
        sig: *const raw_types::c_uchar,
        sig_len: usize,
        rs_ctx: *mut pk_restart_ctx,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_verify_ext"]
    pub fn pk_verify_ext(
        type_: pk_type_t,
        options: *const raw_types::c_void,
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const raw_types::c_uchar,
        hash_len: usize,
        sig: *const raw_types::c_uchar,
        sig_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_sign"]
    pub fn pk_sign(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const raw_types::c_uchar,
        hash_len: usize,
        sig: *mut raw_types::c_uchar,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_sign_restartable"]
    pub fn pk_sign_restartable(
        ctx: *mut pk_context,
        md_alg: md_type_t,
        hash: *const raw_types::c_uchar,
        hash_len: usize,
        sig: *mut raw_types::c_uchar,
        sig_len: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        rs_ctx: *mut pk_restart_ctx,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_decrypt"]
    pub fn pk_decrypt(
        ctx: *mut pk_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_encrypt"]
    pub fn pk_encrypt(
        ctx: *mut pk_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
        olen: *mut usize,
        osize: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_check_pair"]
    pub fn pk_check_pair(pub_: *const pk_context, prv: *const pk_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_debug"]
    pub fn pk_debug(ctx: *const pk_context, items: *mut pk_debug_item) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_get_name"]
    pub fn pk_get_name(ctx: *const pk_context) -> *const raw_types::c_char;
}
extern "C" {
    #[link_name = "mbedtls_pk_get_type"]
    pub fn pk_get_type(ctx: *const pk_context) -> pk_type_t;
}
extern "C" {
    #[link_name = "mbedtls_pk_parse_key"]
    pub fn pk_parse_key(
        ctx: *mut pk_context,
        key: *const raw_types::c_uchar,
        keylen: usize,
        pwd: *const raw_types::c_uchar,
        pwdlen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_parse_public_key"]
    pub fn pk_parse_public_key(
        ctx: *mut pk_context,
        key: *const raw_types::c_uchar,
        keylen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_parse_keyfile"]
    pub fn pk_parse_keyfile(
        ctx: *mut pk_context,
        path: *const raw_types::c_char,
        password: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_parse_public_keyfile"]
    pub fn pk_parse_public_keyfile(
        ctx: *mut pk_context,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_write_key_der"]
    pub fn pk_write_key_der(
        ctx: *mut pk_context,
        buf: *mut raw_types::c_uchar,
        size: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_write_pubkey_der"]
    pub fn pk_write_pubkey_der(
        ctx: *mut pk_context,
        buf: *mut raw_types::c_uchar,
        size: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_write_pubkey_pem"]
    pub fn pk_write_pubkey_pem(
        ctx: *mut pk_context,
        buf: *mut raw_types::c_uchar,
        size: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_write_key_pem"]
    pub fn pk_write_key_pem(
        ctx: *mut pk_context,
        buf: *mut raw_types::c_uchar,
        size: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_parse_subpubkey"]
    pub fn pk_parse_subpubkey(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        pk: *mut pk_context,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_write_pubkey"]
    pub fn pk_write_pubkey(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        key: *const pk_context,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pk_load_file"]
    pub fn pk_load_file(
        path: *const raw_types::c_char,
        buf: *mut *mut raw_types::c_uchar,
        n: *mut usize,
    ) -> raw_types::c_int;
}
pub type x509_buf = asn1_buf;
pub type x509_bitstring = asn1_bitstring;
pub type x509_name = asn1_named_data;
pub type x509_sequence = asn1_sequence;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_time {
    pub year: raw_types::c_int,
    pub mon: raw_types::c_int,
    pub day: raw_types::c_int,
    pub hour: raw_types::c_int,
    pub min: raw_types::c_int,
    pub sec: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_x509_time() {
    assert_eq!(
        ::core::mem::size_of::<x509_time>(),
        24usize,
        concat!("Size of: ", stringify!(x509_time))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_time>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_time))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).year as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(year)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).mon as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).day as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(day)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).hour as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).min as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_time>())).sec as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_time),
            "::",
            stringify!(sec)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_x509_dn_gets"]
    pub fn x509_dn_gets(
        buf: *mut raw_types::c_char,
        size: usize,
        dn: *const x509_name,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_serial_gets"]
    pub fn x509_serial_gets(
        buf: *mut raw_types::c_char,
        size: usize,
        serial: *const x509_buf,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_time_is_past"]
    pub fn x509_time_is_past(to: *const x509_time) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_time_is_future"]
    pub fn x509_time_is_future(from: *const x509_time) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_self_test"]
    pub fn x509_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_get_name"]
    pub fn x509_get_name(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        cur: *mut x509_name,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_get_alg_null"]
    pub fn x509_get_alg_null(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        alg: *mut x509_buf,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_get_alg"]
    pub fn x509_get_alg(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        alg: *mut x509_buf,
        params: *mut x509_buf,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_get_rsassa_pss_params"]
    pub fn x509_get_rsassa_pss_params(
        params: *const x509_buf,
        md_alg: *mut md_type_t,
        mgf_md: *mut md_type_t,
        salt_len: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_get_sig"]
    pub fn x509_get_sig(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        sig: *mut x509_buf,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_get_sig_alg"]
    pub fn x509_get_sig_alg(
        sig_oid: *const x509_buf,
        sig_params: *const x509_buf,
        md_alg: *mut md_type_t,
        pk_alg: *mut pk_type_t,
        sig_opts: *mut *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_get_time"]
    pub fn x509_get_time(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        t: *mut x509_time,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_get_serial"]
    pub fn x509_get_serial(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        serial: *mut x509_buf,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_get_ext"]
    pub fn x509_get_ext(
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        ext: *mut x509_buf,
        tag: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_sig_alg_gets"]
    pub fn x509_sig_alg_gets(
        buf: *mut raw_types::c_char,
        size: usize,
        sig_oid: *const x509_buf,
        pk_alg: pk_type_t,
        md_alg: md_type_t,
        sig_opts: *const raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_key_size_helper"]
    pub fn x509_key_size_helper(
        buf: *mut raw_types::c_char,
        buf_size: usize,
        name: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_string_to_names"]
    pub fn x509_string_to_names(
        head: *mut *mut asn1_named_data,
        name: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_set_extension"]
    pub fn x509_set_extension(
        head: *mut *mut asn1_named_data,
        oid: *const raw_types::c_char,
        oid_len: usize,
        critical: raw_types::c_int,
        val: *const raw_types::c_uchar,
        val_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_write_extensions"]
    pub fn x509_write_extensions(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        first: *mut asn1_named_data,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_write_names"]
    pub fn x509_write_names(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        first: *mut asn1_named_data,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_write_sig"]
    pub fn x509_write_sig(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        oid: *const raw_types::c_char,
        oid_len: usize,
        sig: *mut raw_types::c_uchar,
        size: usize,
    ) -> raw_types::c_int;
}
pub type mbedtls_time_t = time_t;
extern "C" {
    #[link_name = "mbedtls_platform_zeroize"]
    pub fn platform_zeroize(buf: *mut raw_types::c_void, len: usize);
}
extern "C" {
    #[link_name = "mbedtls_platform_gmtime_r"]
    pub fn platform_gmtime_r(tt: *const mbedtls_time_t, tm_buf: *mut tm) -> *mut tm;
}
pub const CIPHER_ID_NONE: cipher_id_t = 0;
pub const CIPHER_ID_NULL: cipher_id_t = 1;
pub const CIPHER_ID_AES: cipher_id_t = 2;
pub const CIPHER_ID_DES: cipher_id_t = 3;
pub const CIPHER_ID_3DES: cipher_id_t = 4;
pub const CIPHER_ID_CAMELLIA: cipher_id_t = 5;
pub const CIPHER_ID_BLOWFISH: cipher_id_t = 6;
pub const CIPHER_ID_ARC4: cipher_id_t = 7;
pub const CIPHER_ID_ARIA: cipher_id_t = 8;
pub const CIPHER_ID_CHACHA20: cipher_id_t = 9;
pub type cipher_id_t = u32;
pub const CIPHER_NONE: cipher_type_t = 0;
pub const CIPHER_NULL: cipher_type_t = 1;
pub const CIPHER_AES_128_ECB: cipher_type_t = 2;
pub const CIPHER_AES_192_ECB: cipher_type_t = 3;
pub const CIPHER_AES_256_ECB: cipher_type_t = 4;
pub const CIPHER_AES_128_CBC: cipher_type_t = 5;
pub const CIPHER_AES_192_CBC: cipher_type_t = 6;
pub const CIPHER_AES_256_CBC: cipher_type_t = 7;
pub const CIPHER_AES_128_CFB128: cipher_type_t = 8;
pub const CIPHER_AES_192_CFB128: cipher_type_t = 9;
pub const CIPHER_AES_256_CFB128: cipher_type_t = 10;
pub const CIPHER_AES_128_CTR: cipher_type_t = 11;
pub const CIPHER_AES_192_CTR: cipher_type_t = 12;
pub const CIPHER_AES_256_CTR: cipher_type_t = 13;
pub const CIPHER_AES_128_GCM: cipher_type_t = 14;
pub const CIPHER_AES_192_GCM: cipher_type_t = 15;
pub const CIPHER_AES_256_GCM: cipher_type_t = 16;
pub const CIPHER_CAMELLIA_128_ECB: cipher_type_t = 17;
pub const CIPHER_CAMELLIA_192_ECB: cipher_type_t = 18;
pub const CIPHER_CAMELLIA_256_ECB: cipher_type_t = 19;
pub const CIPHER_CAMELLIA_128_CBC: cipher_type_t = 20;
pub const CIPHER_CAMELLIA_192_CBC: cipher_type_t = 21;
pub const CIPHER_CAMELLIA_256_CBC: cipher_type_t = 22;
pub const CIPHER_CAMELLIA_128_CFB128: cipher_type_t = 23;
pub const CIPHER_CAMELLIA_192_CFB128: cipher_type_t = 24;
pub const CIPHER_CAMELLIA_256_CFB128: cipher_type_t = 25;
pub const CIPHER_CAMELLIA_128_CTR: cipher_type_t = 26;
pub const CIPHER_CAMELLIA_192_CTR: cipher_type_t = 27;
pub const CIPHER_CAMELLIA_256_CTR: cipher_type_t = 28;
pub const CIPHER_CAMELLIA_128_GCM: cipher_type_t = 29;
pub const CIPHER_CAMELLIA_192_GCM: cipher_type_t = 30;
pub const CIPHER_CAMELLIA_256_GCM: cipher_type_t = 31;
pub const CIPHER_DES_ECB: cipher_type_t = 32;
pub const CIPHER_DES_CBC: cipher_type_t = 33;
pub const CIPHER_DES_EDE_ECB: cipher_type_t = 34;
pub const CIPHER_DES_EDE_CBC: cipher_type_t = 35;
pub const CIPHER_DES_EDE3_ECB: cipher_type_t = 36;
pub const CIPHER_DES_EDE3_CBC: cipher_type_t = 37;
pub const CIPHER_BLOWFISH_ECB: cipher_type_t = 38;
pub const CIPHER_BLOWFISH_CBC: cipher_type_t = 39;
pub const CIPHER_BLOWFISH_CFB64: cipher_type_t = 40;
pub const CIPHER_BLOWFISH_CTR: cipher_type_t = 41;
pub const CIPHER_ARC4_128: cipher_type_t = 42;
pub const CIPHER_AES_128_CCM: cipher_type_t = 43;
pub const CIPHER_AES_192_CCM: cipher_type_t = 44;
pub const CIPHER_AES_256_CCM: cipher_type_t = 45;
pub const CIPHER_CAMELLIA_128_CCM: cipher_type_t = 46;
pub const CIPHER_CAMELLIA_192_CCM: cipher_type_t = 47;
pub const CIPHER_CAMELLIA_256_CCM: cipher_type_t = 48;
pub const CIPHER_ARIA_128_ECB: cipher_type_t = 49;
pub const CIPHER_ARIA_192_ECB: cipher_type_t = 50;
pub const CIPHER_ARIA_256_ECB: cipher_type_t = 51;
pub const CIPHER_ARIA_128_CBC: cipher_type_t = 52;
pub const CIPHER_ARIA_192_CBC: cipher_type_t = 53;
pub const CIPHER_ARIA_256_CBC: cipher_type_t = 54;
pub const CIPHER_ARIA_128_CFB128: cipher_type_t = 55;
pub const CIPHER_ARIA_192_CFB128: cipher_type_t = 56;
pub const CIPHER_ARIA_256_CFB128: cipher_type_t = 57;
pub const CIPHER_ARIA_128_CTR: cipher_type_t = 58;
pub const CIPHER_ARIA_192_CTR: cipher_type_t = 59;
pub const CIPHER_ARIA_256_CTR: cipher_type_t = 60;
pub const CIPHER_ARIA_128_GCM: cipher_type_t = 61;
pub const CIPHER_ARIA_192_GCM: cipher_type_t = 62;
pub const CIPHER_ARIA_256_GCM: cipher_type_t = 63;
pub const CIPHER_ARIA_128_CCM: cipher_type_t = 64;
pub const CIPHER_ARIA_192_CCM: cipher_type_t = 65;
pub const CIPHER_ARIA_256_CCM: cipher_type_t = 66;
pub const CIPHER_AES_128_OFB: cipher_type_t = 67;
pub const CIPHER_AES_192_OFB: cipher_type_t = 68;
pub const CIPHER_AES_256_OFB: cipher_type_t = 69;
pub const CIPHER_AES_128_XTS: cipher_type_t = 70;
pub const CIPHER_AES_256_XTS: cipher_type_t = 71;
pub const CIPHER_CHACHA20: cipher_type_t = 72;
pub const CIPHER_CHACHA20_POLY1305: cipher_type_t = 73;
pub type cipher_type_t = u32;
pub const MODE_NONE: cipher_mode_t = 0;
pub const MODE_ECB: cipher_mode_t = 1;
pub const MODE_CBC: cipher_mode_t = 2;
pub const MODE_CFB: cipher_mode_t = 3;
pub const MODE_OFB: cipher_mode_t = 4;
pub const MODE_CTR: cipher_mode_t = 5;
pub const MODE_GCM: cipher_mode_t = 6;
pub const MODE_STREAM: cipher_mode_t = 7;
pub const MODE_CCM: cipher_mode_t = 8;
pub const MODE_XTS: cipher_mode_t = 9;
pub const MODE_CHACHAPOLY: cipher_mode_t = 10;
pub type cipher_mode_t = u32;
pub const PADDING_PKCS7: cipher_padding_t = 0;
pub const PADDING_ONE_AND_ZEROS: cipher_padding_t = 1;
pub const PADDING_ZEROS_AND_LEN: cipher_padding_t = 2;
pub const PADDING_ZEROS: cipher_padding_t = 3;
pub const PADDING_NONE: cipher_padding_t = 4;
pub type cipher_padding_t = u32;
pub const OPERATION_NONE: operation_t = -1;
pub const DECRYPT: operation_t = 0;
pub const ENCRYPT: operation_t = 1;
pub type operation_t = i32;
pub const KEY_LENGTH_NONE: _bindgen_ty_11 = 0;
pub const KEY_LENGTH_DES: _bindgen_ty_11 = 64;
pub const KEY_LENGTH_DES_EDE: _bindgen_ty_11 = 128;
pub const KEY_LENGTH_DES_EDE3: _bindgen_ty_11 = 192;
pub type _bindgen_ty_11 = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cipher_info_t {
    pub type_: cipher_type_t,
    pub mode: cipher_mode_t,
    pub key_bitlen: raw_types::c_uint,
    pub name: *const raw_types::c_char,
    pub iv_size: raw_types::c_uint,
    pub flags: raw_types::c_int,
    pub block_size: raw_types::c_uint,
    pub base: *const cipher_base_t,
}
#[test]
fn bindgen_test_layout_cipher_info_t() {
    assert_eq!(
        ::core::mem::size_of::<cipher_info_t>(),
        48usize,
        concat!("Size of: ", stringify!(cipher_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cipher_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).mode as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).key_bitlen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(key_bitlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).iv_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).flags as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).block_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_info_t>())).base as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_info_t),
            "::",
            stringify!(base)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cipher_context_t {
    pub cipher_info: *const cipher_info_t,
    pub key_bitlen: raw_types::c_int,
    pub operation: operation_t,
    pub add_padding: ::core::option::Option<
        unsafe extern "C" fn(output: *mut raw_types::c_uchar, olen: usize, data_len: usize),
    >,
    pub get_padding: ::core::option::Option<
        unsafe extern "C" fn(
            input: *mut raw_types::c_uchar,
            ilen: usize,
            data_len: *mut usize,
        ) -> raw_types::c_int,
    >,
    pub unprocessed_data: [raw_types::c_uchar; 16usize],
    pub unprocessed_len: usize,
    pub iv: [raw_types::c_uchar; 16usize],
    pub iv_size: usize,
    pub cipher_ctx: *mut raw_types::c_void,
}
#[test]
fn bindgen_test_layout_cipher_context_t() {
    assert_eq!(
        ::core::mem::size_of::<cipher_context_t>(),
        88usize,
        concat!("Size of: ", stringify!(cipher_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cipher_context_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).cipher_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(cipher_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).key_bitlen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(key_bitlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).operation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(operation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).add_padding as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(add_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).get_padding as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(get_padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cipher_context_t>())).unprocessed_data as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(unprocessed_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cipher_context_t>())).unprocessed_len as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(unprocessed_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).iv as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).iv_size as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(iv_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_context_t>())).cipher_ctx as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_context_t),
            "::",
            stringify!(cipher_ctx)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_cipher_list"]
    pub fn cipher_list() -> *const raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_info_from_string"]
    pub fn cipher_info_from_string(cipher_name: *const raw_types::c_char) -> *const cipher_info_t;
}
extern "C" {
    #[link_name = "mbedtls_cipher_info_from_type"]
    pub fn cipher_info_from_type(cipher_type: cipher_type_t) -> *const cipher_info_t;
}
extern "C" {
    #[link_name = "mbedtls_cipher_info_from_values"]
    pub fn cipher_info_from_values(
        cipher_id: cipher_id_t,
        key_bitlen: raw_types::c_int,
        mode: cipher_mode_t,
    ) -> *const cipher_info_t;
}
extern "C" {
    #[link_name = "mbedtls_cipher_init"]
    pub fn cipher_init(ctx: *mut cipher_context_t);
}
extern "C" {
    #[link_name = "mbedtls_cipher_free"]
    pub fn cipher_free(ctx: *mut cipher_context_t);
}
extern "C" {
    #[link_name = "mbedtls_cipher_setup"]
    pub fn cipher_setup(
        ctx: *mut cipher_context_t,
        cipher_info: *const cipher_info_t,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_setkey"]
    pub fn cipher_setkey(
        ctx: *mut cipher_context_t,
        key: *const raw_types::c_uchar,
        key_bitlen: raw_types::c_int,
        operation: operation_t,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_set_padding_mode"]
    pub fn cipher_set_padding_mode(
        ctx: *mut cipher_context_t,
        mode: cipher_padding_t,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_set_iv"]
    pub fn cipher_set_iv(
        ctx: *mut cipher_context_t,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_reset"]
    pub fn cipher_reset(ctx: *mut cipher_context_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_update_ad"]
    pub fn cipher_update_ad(
        ctx: *mut cipher_context_t,
        ad: *const raw_types::c_uchar,
        ad_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_update"]
    pub fn cipher_update(
        ctx: *mut cipher_context_t,
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_finish"]
    pub fn cipher_finish(
        ctx: *mut cipher_context_t,
        output: *mut raw_types::c_uchar,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_write_tag"]
    pub fn cipher_write_tag(
        ctx: *mut cipher_context_t,
        tag: *mut raw_types::c_uchar,
        tag_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_check_tag"]
    pub fn cipher_check_tag(
        ctx: *mut cipher_context_t,
        tag: *const raw_types::c_uchar,
        tag_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_crypt"]
    pub fn cipher_crypt(
        ctx: *mut cipher_context_t,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_auth_encrypt"]
    pub fn cipher_auth_encrypt(
        ctx: *mut cipher_context_t,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
        ad: *const raw_types::c_uchar,
        ad_len: usize,
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
        olen: *mut usize,
        tag: *mut raw_types::c_uchar,
        tag_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_auth_decrypt"]
    pub fn cipher_auth_decrypt(
        ctx: *mut cipher_context_t,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
        ad: *const raw_types::c_uchar,
        ad_len: usize,
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
        olen: *mut usize,
        tag: *const raw_types::c_uchar,
        tag_len: usize,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crl_entry {
    pub raw: x509_buf,
    pub serial: x509_buf,
    pub revocation_date: x509_time,
    pub entry_ext: x509_buf,
    pub next: *mut x509_crl_entry,
}
#[test]
fn bindgen_test_layout_x509_crl_entry() {
    assert_eq!(
        ::core::mem::size_of::<x509_crl_entry>(),
        104usize,
        concat!("Size of: ", stringify!(x509_crl_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crl_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_crl_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl_entry>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl_entry>())).serial as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl_entry>())).revocation_date as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(revocation_date)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl_entry>())).entry_ext as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(entry_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl_entry>())).next as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl_entry),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crl {
    pub raw: x509_buf,
    pub tbs: x509_buf,
    pub version: raw_types::c_int,
    pub sig_oid: x509_buf,
    pub issuer_raw: x509_buf,
    pub issuer: x509_name,
    pub this_update: x509_time,
    pub next_update: x509_time,
    pub entry: x509_crl_entry,
    pub crl_ext: x509_buf,
    pub sig_oid2: x509_buf,
    pub sig: x509_buf,
    pub sig_md: md_type_t,
    pub sig_pk: pk_type_t,
    pub sig_opts: *mut raw_types::c_void,
    pub next: *mut x509_crl,
}
#[test]
fn bindgen_test_layout_x509_crl() {
    assert_eq!(
        ::core::mem::size_of::<x509_crl>(),
        416usize,
        concat!("Size of: ", stringify!(x509_crl))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crl>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_crl))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).tbs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(tbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).version as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig_oid as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).issuer_raw as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(issuer_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).issuer as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).this_update as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(this_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).next_update as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(next_update)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).entry as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(entry)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).crl_ext as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(crl_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig_oid2 as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_oid2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig_md as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_md)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig_pk as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_pk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).sig_opts as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(sig_opts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crl>())).next as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crl),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_x509_crl_parse_der"]
    pub fn x509_crl_parse_der(
        chain: *mut x509_crl,
        buf: *const raw_types::c_uchar,
        buflen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crl_parse"]
    pub fn x509_crl_parse(
        chain: *mut x509_crl,
        buf: *const raw_types::c_uchar,
        buflen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crl_parse_file"]
    pub fn x509_crl_parse_file(
        chain: *mut x509_crl,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crl_info"]
    pub fn x509_crl_info(
        buf: *mut raw_types::c_char,
        size: usize,
        prefix: *const raw_types::c_char,
        crl: *const x509_crl,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crl_init"]
    pub fn x509_crl_init(crl: *mut x509_crl);
}
extern "C" {
    #[link_name = "mbedtls_x509_crl_free"]
    pub fn x509_crl_free(crl: *mut x509_crl);
}
pub const KEY_EXCHANGE_NONE: key_exchange_type_t = 0;
pub const KEY_EXCHANGE_RSA: key_exchange_type_t = 1;
pub const KEY_EXCHANGE_DHE_RSA: key_exchange_type_t = 2;
pub const KEY_EXCHANGE_ECDHE_RSA: key_exchange_type_t = 3;
pub const KEY_EXCHANGE_ECDHE_ECDSA: key_exchange_type_t = 4;
pub const KEY_EXCHANGE_PSK: key_exchange_type_t = 5;
pub const KEY_EXCHANGE_DHE_PSK: key_exchange_type_t = 6;
pub const KEY_EXCHANGE_RSA_PSK: key_exchange_type_t = 7;
pub const KEY_EXCHANGE_ECDHE_PSK: key_exchange_type_t = 8;
pub const KEY_EXCHANGE_ECDH_RSA: key_exchange_type_t = 9;
pub const KEY_EXCHANGE_ECDH_ECDSA: key_exchange_type_t = 10;
pub const KEY_EXCHANGE_ECJPAKE: key_exchange_type_t = 11;
pub type key_exchange_type_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_ciphersuite_t {
    pub id: raw_types::c_int,
    pub name: *const raw_types::c_char,
    pub cipher: cipher_type_t,
    pub mac: md_type_t,
    pub key_exchange: key_exchange_type_t,
    pub min_major_ver: raw_types::c_int,
    pub min_minor_ver: raw_types::c_int,
    pub max_major_ver: raw_types::c_int,
    pub max_minor_ver: raw_types::c_int,
    pub flags: raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_ssl_ciphersuite_t() {
    assert_eq!(
        ::core::mem::size_of::<ssl_ciphersuite_t>(),
        48usize,
        concat!("Size of: ", stringify!(ssl_ciphersuite_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_ciphersuite_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_ciphersuite_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).cipher as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).mac as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).key_exchange as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(key_exchange)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_ciphersuite_t>())).min_major_ver as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(min_major_ver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_ciphersuite_t>())).min_minor_ver as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(min_minor_ver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_ciphersuite_t>())).max_major_ver as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(max_major_ver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_ciphersuite_t>())).max_minor_ver as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(max_minor_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ciphersuite_t>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ciphersuite_t),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_list_ciphersuites"]
    pub fn ssl_list_ciphersuites() -> *const raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_ciphersuite_from_string"]
    pub fn ssl_ciphersuite_from_string(
        ciphersuite_name: *const raw_types::c_char,
    ) -> *const ssl_ciphersuite_t;
}
extern "C" {
    #[link_name = "mbedtls_ssl_ciphersuite_from_id"]
    pub fn ssl_ciphersuite_from_id(ciphersuite_id: raw_types::c_int) -> *const ssl_ciphersuite_t;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_ciphersuite_sig_pk_alg"]
    pub fn ssl_get_ciphersuite_sig_pk_alg(info: *const ssl_ciphersuite_t) -> pk_type_t;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_ciphersuite_sig_alg"]
    pub fn ssl_get_ciphersuite_sig_alg(info: *const ssl_ciphersuite_t) -> pk_type_t;
}
extern "C" {
    #[link_name = "mbedtls_ssl_ciphersuite_uses_ec"]
    pub fn ssl_ciphersuite_uses_ec(info: *const ssl_ciphersuite_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_ciphersuite_uses_psk"]
    pub fn ssl_ciphersuite_uses_psk(info: *const ssl_ciphersuite_t) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crt {
    pub raw: x509_buf,
    pub tbs: x509_buf,
    pub version: raw_types::c_int,
    pub serial: x509_buf,
    pub sig_oid: x509_buf,
    pub issuer_raw: x509_buf,
    pub subject_raw: x509_buf,
    pub issuer: x509_name,
    pub subject: x509_name,
    pub valid_from: x509_time,
    pub valid_to: x509_time,
    pub pk: pk_context,
    pub issuer_id: x509_buf,
    pub subject_id: x509_buf,
    pub v3_ext: x509_buf,
    pub subject_alt_names: x509_sequence,
    pub ext_types: raw_types::c_int,
    pub ca_istrue: raw_types::c_int,
    pub max_pathlen: raw_types::c_int,
    pub key_usage: raw_types::c_uint,
    pub ext_key_usage: x509_sequence,
    pub ns_cert_type: raw_types::c_uchar,
    pub sig: x509_buf,
    pub sig_md: md_type_t,
    pub sig_pk: pk_type_t,
    pub sig_opts: *mut raw_types::c_void,
    pub next: *mut x509_crt,
}
#[test]
fn bindgen_test_layout_x509_crt() {
    assert_eq!(
        ::core::mem::size_of::<x509_crt>(),
        552usize,
        concat!("Size of: ", stringify!(x509_crt))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_crt))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).tbs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(tbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).version as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).serial as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).sig_oid as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).issuer_raw as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(issuer_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).subject_raw as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).issuer as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).subject as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).valid_from as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(valid_from)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).valid_to as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(valid_to)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).pk as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(pk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).issuer_id as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(issuer_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).subject_id as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).v3_ext as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(v3_ext)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).subject_alt_names as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(subject_alt_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).ext_types as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ext_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).ca_istrue as *const _ as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ca_istrue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).max_pathlen as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(max_pathlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).key_usage as *const _ as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(key_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).ext_key_usage as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ext_key_usage)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).ns_cert_type as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(ns_cert_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).sig as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).sig_md as *const _ as usize },
        528usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_md)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).sig_pk as *const _ as usize },
        532usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_pk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).sig_opts as *const _ as usize },
        536usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(sig_opts)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt>())).next as *const _ as usize },
        544usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crt_profile {
    pub allowed_mds: u32,
    pub allowed_pks: u32,
    pub allowed_curves: u32,
    pub rsa_min_bitlen: u32,
}
#[test]
fn bindgen_test_layout_x509_crt_profile() {
    assert_eq!(
        ::core::mem::size_of::<x509_crt_profile>(),
        16usize,
        concat!("Size of: ", stringify!(x509_crt_profile))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt_profile>(),
        4usize,
        concat!("Alignment of ", stringify!(x509_crt_profile))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt_profile>())).allowed_mds as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(allowed_mds)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt_profile>())).allowed_pks as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(allowed_pks)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_crt_profile>())).allowed_curves as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(allowed_curves)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_crt_profile>())).rsa_min_bitlen as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_profile),
            "::",
            stringify!(rsa_min_bitlen)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509write_cert {
    pub version: raw_types::c_int,
    pub serial: mpi,
    pub subject_key: *mut pk_context,
    pub issuer_key: *mut pk_context,
    pub subject: *mut asn1_named_data,
    pub issuer: *mut asn1_named_data,
    pub md_alg: md_type_t,
    pub not_before: [raw_types::c_char; 16usize],
    pub not_after: [raw_types::c_char; 16usize],
    pub extensions: *mut asn1_named_data,
}
#[test]
fn bindgen_test_layout_x509write_cert() {
    assert_eq!(
        ::core::mem::size_of::<x509write_cert>(),
        112usize,
        concat!("Size of: ", stringify!(x509write_cert))
    );
    assert_eq!(
        ::core::mem::align_of::<x509write_cert>(),
        8usize,
        concat!("Alignment of ", stringify!(x509write_cert))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).version as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).serial as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).subject_key as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(subject_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).issuer_key as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(issuer_key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).subject as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).issuer as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(issuer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).md_alg as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(md_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).not_before as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(not_before)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).not_after as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(not_after)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_cert>())).extensions as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_cert),
            "::",
            stringify!(extensions)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crt_verify_chain_item {
    pub crt: *mut x509_crt,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_x509_crt_verify_chain_item() {
    assert_eq!(
        ::core::mem::size_of::<x509_crt_verify_chain_item>(),
        16usize,
        concat!("Size of: ", stringify!(x509_crt_verify_chain_item))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt_verify_chain_item>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_crt_verify_chain_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt_verify_chain_item>())).crt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain_item),
            "::",
            stringify!(crt)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<x509_crt_verify_chain_item>())).flags as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain_item),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_crt_verify_chain {
    pub items: [x509_crt_verify_chain_item; 10usize],
    pub len: raw_types::c_uint,
}
#[test]
fn bindgen_test_layout_x509_crt_verify_chain() {
    assert_eq!(
        ::core::mem::size_of::<x509_crt_verify_chain>(),
        168usize,
        concat!("Size of: ", stringify!(x509_crt_verify_chain))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_crt_verify_chain>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_crt_verify_chain))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt_verify_chain>())).items as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain),
            "::",
            stringify!(items)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_crt_verify_chain>())).len as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_crt_verify_chain),
            "::",
            stringify!(len)
        )
    );
}
pub type x509_crt_restart_ctx = raw_types::c_void;
extern "C" {
    #[link_name = "mbedtls_x509_crt_profile_default"]
    pub static x509_crt_profile_default: x509_crt_profile;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_profile_next"]
    pub static x509_crt_profile_next: x509_crt_profile;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_profile_suiteb"]
    pub static x509_crt_profile_suiteb: x509_crt_profile;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_parse_der"]
    pub fn x509_crt_parse_der(
        chain: *mut x509_crt,
        buf: *const raw_types::c_uchar,
        buflen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_parse"]
    pub fn x509_crt_parse(
        chain: *mut x509_crt,
        buf: *const raw_types::c_uchar,
        buflen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_parse_file"]
    pub fn x509_crt_parse_file(
        chain: *mut x509_crt,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_parse_path"]
    pub fn x509_crt_parse_path(
        chain: *mut x509_crt,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_info"]
    pub fn x509_crt_info(
        buf: *mut raw_types::c_char,
        size: usize,
        prefix: *const raw_types::c_char,
        crt: *const x509_crt,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_verify_info"]
    pub fn x509_crt_verify_info(
        buf: *mut raw_types::c_char,
        size: usize,
        prefix: *const raw_types::c_char,
        flags: u32,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_verify"]
    pub fn x509_crt_verify(
        crt: *mut x509_crt,
        trust_ca: *mut x509_crt,
        ca_crl: *mut x509_crl,
        cn: *const raw_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut x509_crt,
                arg3: raw_types::c_int,
                arg4: *mut u32,
            ) -> raw_types::c_int,
        >,
        p_vrfy: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_verify_with_profile"]
    pub fn x509_crt_verify_with_profile(
        crt: *mut x509_crt,
        trust_ca: *mut x509_crt,
        ca_crl: *mut x509_crl,
        profile: *const x509_crt_profile,
        cn: *const raw_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut x509_crt,
                arg3: raw_types::c_int,
                arg4: *mut u32,
            ) -> raw_types::c_int,
        >,
        p_vrfy: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_verify_restartable"]
    pub fn x509_crt_verify_restartable(
        crt: *mut x509_crt,
        trust_ca: *mut x509_crt,
        ca_crl: *mut x509_crl,
        profile: *const x509_crt_profile,
        cn: *const raw_types::c_char,
        flags: *mut u32,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut x509_crt,
                arg3: raw_types::c_int,
                arg4: *mut u32,
            ) -> raw_types::c_int,
        >,
        p_vrfy: *mut raw_types::c_void,
        rs_ctx: *mut x509_crt_restart_ctx,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_check_key_usage"]
    pub fn x509_crt_check_key_usage(
        crt: *const x509_crt,
        usage: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_check_extended_key_usage"]
    pub fn x509_crt_check_extended_key_usage(
        crt: *const x509_crt,
        usage_oid: *const raw_types::c_char,
        usage_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_is_revoked"]
    pub fn x509_crt_is_revoked(crt: *const x509_crt, crl: *const x509_crl) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_init"]
    pub fn x509_crt_init(crt: *mut x509_crt);
}
extern "C" {
    #[link_name = "mbedtls_x509_crt_free"]
    pub fn x509_crt_free(crt: *mut x509_crt);
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_init"]
    pub fn x509write_crt_init(ctx: *mut x509write_cert);
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_version"]
    pub fn x509write_crt_set_version(ctx: *mut x509write_cert, version: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_serial"]
    pub fn x509write_crt_set_serial(
        ctx: *mut x509write_cert,
        serial: *const mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_validity"]
    pub fn x509write_crt_set_validity(
        ctx: *mut x509write_cert,
        not_before: *const raw_types::c_char,
        not_after: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_issuer_name"]
    pub fn x509write_crt_set_issuer_name(
        ctx: *mut x509write_cert,
        issuer_name: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_subject_name"]
    pub fn x509write_crt_set_subject_name(
        ctx: *mut x509write_cert,
        subject_name: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_subject_key"]
    pub fn x509write_crt_set_subject_key(ctx: *mut x509write_cert, key: *mut pk_context);
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_issuer_key"]
    pub fn x509write_crt_set_issuer_key(ctx: *mut x509write_cert, key: *mut pk_context);
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_md_alg"]
    pub fn x509write_crt_set_md_alg(ctx: *mut x509write_cert, md_alg: md_type_t);
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_extension"]
    pub fn x509write_crt_set_extension(
        ctx: *mut x509write_cert,
        oid: *const raw_types::c_char,
        oid_len: usize,
        critical: raw_types::c_int,
        val: *const raw_types::c_uchar,
        val_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_basic_constraints"]
    pub fn x509write_crt_set_basic_constraints(
        ctx: *mut x509write_cert,
        is_ca: raw_types::c_int,
        max_pathlen: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_subject_key_identifier"]
    pub fn x509write_crt_set_subject_key_identifier(ctx: *mut x509write_cert) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_authority_key_identifier"]
    pub fn x509write_crt_set_authority_key_identifier(ctx: *mut x509write_cert)
        -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_key_usage"]
    pub fn x509write_crt_set_key_usage(
        ctx: *mut x509write_cert,
        key_usage: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_set_ns_cert_type"]
    pub fn x509write_crt_set_ns_cert_type(
        ctx: *mut x509write_cert,
        ns_cert_type: raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_free"]
    pub fn x509write_crt_free(ctx: *mut x509write_cert);
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_der"]
    pub fn x509write_crt_der(
        ctx: *mut x509write_cert,
        buf: *mut raw_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_crt_pem"]
    pub fn x509write_crt_pem(
        ctx: *mut x509write_cert,
        buf: *mut raw_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct dhm_context {
    pub len: usize,
    pub P: mpi,
    pub G: mpi,
    pub X: mpi,
    pub GX: mpi,
    pub GY: mpi,
    pub K: mpi,
    pub RP: mpi,
    pub Vi: mpi,
    pub Vf: mpi,
    pub pX: mpi,
}
#[test]
fn bindgen_test_layout_dhm_context() {
    assert_eq!(
        ::core::mem::size_of::<dhm_context>(),
        248usize,
        concat!("Size of: ", stringify!(dhm_context))
    );
    assert_eq!(
        ::core::mem::align_of::<dhm_context>(),
        8usize,
        concat!("Alignment of ", stringify!(dhm_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).P as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).G as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).X as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(X)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).GX as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(GX)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).GY as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(GY)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).K as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(K)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).RP as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(RP)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).Vi as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(Vi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).Vf as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(Vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<dhm_context>())).pX as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(dhm_context),
            "::",
            stringify!(pX)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_dhm_init"]
    pub fn dhm_init(ctx: *mut dhm_context);
}
extern "C" {
    #[link_name = "mbedtls_dhm_read_params"]
    pub fn dhm_read_params(
        ctx: *mut dhm_context,
        p: *mut *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_dhm_make_params"]
    pub fn dhm_make_params(
        ctx: *mut dhm_context,
        x_size: raw_types::c_int,
        output: *mut raw_types::c_uchar,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_dhm_set_group"]
    pub fn dhm_set_group(ctx: *mut dhm_context, P: *const mpi, G: *const mpi) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_dhm_read_public"]
    pub fn dhm_read_public(
        ctx: *mut dhm_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_dhm_make_public"]
    pub fn dhm_make_public(
        ctx: *mut dhm_context,
        x_size: raw_types::c_int,
        output: *mut raw_types::c_uchar,
        olen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_dhm_calc_secret"]
    pub fn dhm_calc_secret(
        ctx: *mut dhm_context,
        output: *mut raw_types::c_uchar,
        output_size: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_dhm_free"]
    pub fn dhm_free(ctx: *mut dhm_context);
}
extern "C" {
    #[link_name = "mbedtls_dhm_parse_dhm"]
    pub fn dhm_parse_dhm(
        dhm: *mut dhm_context,
        dhmin: *const raw_types::c_uchar,
        dhminlen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_dhm_parse_dhmfile"]
    pub fn dhm_parse_dhmfile(
        dhm: *mut dhm_context,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_dhm_self_test"]
    pub fn dhm_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
pub const ECDH_OURS: ecdh_side = 0;
pub const ECDH_THEIRS: ecdh_side = 1;
pub type ecdh_side = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecdh_context {
    pub grp: ecp_group,
    pub d: mpi,
    pub Q: ecp_point,
    pub Qp: ecp_point,
    pub z: mpi,
    pub point_format: raw_types::c_int,
    pub Vi: ecp_point,
    pub Vf: ecp_point,
    pub _d: mpi,
}
#[test]
fn bindgen_test_layout_ecdh_context() {
    assert_eq!(
        ::core::mem::size_of::<ecdh_context>(),
        616usize,
        concat!("Size of: ", stringify!(ecdh_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ecdh_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ecdh_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).grp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).d as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).Q as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Q)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).Qp as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).z as *const _ as usize },
        416usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(z)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).point_format as *const _ as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(point_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).Vi as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Vi)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>())).Vf as *const _ as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(Vf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecdh_context>()))._d as *const _ as usize },
        592usize,
        concat!(
            "Offset of field: ",
            stringify!(ecdh_context),
            "::",
            stringify!(_d)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ecdh_gen_public"]
    pub fn ecdh_gen_public(
        grp: *mut ecp_group,
        d: *mut mpi,
        Q: *mut ecp_point,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdh_compute_shared"]
    pub fn ecdh_compute_shared(
        grp: *mut ecp_group,
        z: *mut mpi,
        Q: *const ecp_point,
        d: *const mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdh_init"]
    pub fn ecdh_init(ctx: *mut ecdh_context);
}
extern "C" {
    #[link_name = "mbedtls_ecdh_setup"]
    pub fn ecdh_setup(ctx: *mut ecdh_context, grp_id: ecp_group_id) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdh_free"]
    pub fn ecdh_free(ctx: *mut ecdh_context);
}
extern "C" {
    #[link_name = "mbedtls_ecdh_make_params"]
    pub fn ecdh_make_params(
        ctx: *mut ecdh_context,
        olen: *mut usize,
        buf: *mut raw_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdh_read_params"]
    pub fn ecdh_read_params(
        ctx: *mut ecdh_context,
        buf: *mut *const raw_types::c_uchar,
        end: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdh_get_params"]
    pub fn ecdh_get_params(
        ctx: *mut ecdh_context,
        key: *const ecp_keypair,
        side: ecdh_side,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdh_make_public"]
    pub fn ecdh_make_public(
        ctx: *mut ecdh_context,
        olen: *mut usize,
        buf: *mut raw_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdh_read_public"]
    pub fn ecdh_read_public(
        ctx: *mut ecdh_context,
        buf: *const raw_types::c_uchar,
        blen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecdh_calc_secret"]
    pub fn ecdh_calc_secret(
        ctx: *mut ecdh_context,
        olen: *mut usize,
        buf: *mut raw_types::c_uchar,
        blen: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
pub type z_size_t = usize;
pub type Byte = raw_types::c_uchar;
pub type uInt = raw_types::c_uint;
pub type uLong = raw_types::c_ulong;
pub type Bytef = Byte;
pub type charf = raw_types::c_char;
pub type intf = raw_types::c_int;
pub type uIntf = uInt;
pub type uLongf = uLong;
pub type voidpc = *const raw_types::c_void;
pub type voidpf = *mut raw_types::c_void;
pub type voidp = *mut raw_types::c_void;
pub type z_crc_t = raw_types::c_uint;
pub type useconds_t = __useconds_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(__name: *const raw_types::c_char, __type: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: raw_types::c_int,
        __file: *const raw_types::c_char,
        __type: raw_types::c_int,
        __flag: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn lseek(__fd: raw_types::c_int, __offset: __off_t, __whence: raw_types::c_int) -> __off_t;
}
extern "C" {
    pub fn close(__fd: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn read(__fd: raw_types::c_int, __buf: *mut raw_types::c_void, __nbytes: usize) -> isize;
}
extern "C" {
    pub fn write(__fd: raw_types::c_int, __buf: *const raw_types::c_void, __n: usize) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: raw_types::c_int,
        __buf: *mut raw_types::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: raw_types::c_int,
        __buf: *const raw_types::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn alarm(__seconds: raw_types::c_uint) -> raw_types::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: raw_types::c_uint) -> raw_types::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> raw_types::c_int;
}
extern "C" {
    pub fn pause() -> raw_types::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const raw_types::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn fchown(__fd: raw_types::c_int, __owner: __uid_t, __group: __gid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const raw_types::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: raw_types::c_int,
        __file: *const raw_types::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn chdir(__path: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn fchdir(__fd: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut raw_types::c_char, __size: usize) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut raw_types::c_char) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn dup(__fd: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn dup2(__fd: raw_types::c_int, __fd2: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "__environ"]
    pub static mut __environ: *mut *mut raw_types::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const raw_types::c_char,
        __argv: *const *mut raw_types::c_char,
        __envp: *const *mut raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: raw_types::c_int,
        __argv: *const *mut raw_types::c_char,
        __envp: *const *mut raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const raw_types::c_char,
        __argv: *const *mut raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const raw_types::c_char,
        __arg: *const raw_types::c_char,
        ...
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const raw_types::c_char,
        __arg: *const raw_types::c_char,
        ...
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const raw_types::c_char,
        __argv: *const *mut raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const raw_types::c_char,
        __arg: *const raw_types::c_char,
        ...
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn nice(__inc: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn _exit(__status: raw_types::c_int);
}
pub const _PC_LINK_MAX: _bindgen_ty_12 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_12 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_12 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_12 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_12 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_12 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_12 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_12 = 7;
pub const _PC_VDISABLE: _bindgen_ty_12 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_12 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_12 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_12 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_12 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_12 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_12 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_12 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_12 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_12 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_12 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_12 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_12 = 20;
pub type _bindgen_ty_12 = u32;
pub const _SC_ARG_MAX: _bindgen_ty_13 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_13 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_13 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_13 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_13 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_13 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_13 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_13 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_13 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_13 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_13 = 10;
pub const _SC_TIMERS: _bindgen_ty_13 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_13 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_13 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_13 = 14;
pub const _SC_FSYNC: _bindgen_ty_13 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_13 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_13 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_13 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_13 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_13 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_13 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_13 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_13 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_13 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_13 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_13 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_13 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_13 = 28;
pub const _SC_VERSION: _bindgen_ty_13 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_13 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_13 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_13 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_13 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_13 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_13 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_13 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_13 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_13 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_13 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_13 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_13 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_13 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_13 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_13 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_13 = 45;
pub const _SC_2_VERSION: _bindgen_ty_13 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_13 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_13 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_13 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_13 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_13 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_13 = 52;
pub const _SC_PII: _bindgen_ty_13 = 53;
pub const _SC_PII_XTI: _bindgen_ty_13 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_13 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_13 = 56;
pub const _SC_PII_OSI: _bindgen_ty_13 = 57;
pub const _SC_POLL: _bindgen_ty_13 = 58;
pub const _SC_SELECT: _bindgen_ty_13 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_13 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_13 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_13 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_13 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_13 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_13 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_13 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_13 = 66;
pub const _SC_THREADS: _bindgen_ty_13 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_13 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_13 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_13 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_13 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_13 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_13 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_13 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_13 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_13 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_13 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_13 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_13 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_13 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_13 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_13 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_13 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_13 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_13 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_13 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_13 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_13 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_13 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_13 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_13 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_13 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_13 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_13 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_13 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_13 = 96;
pub const _SC_2_UPE: _bindgen_ty_13 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_13 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_13 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_13 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_13 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_13 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_13 = 103;
pub const _SC_INT_MAX: _bindgen_ty_13 = 104;
pub const _SC_INT_MIN: _bindgen_ty_13 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_13 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_13 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_13 = 108;
pub const _SC_NZERO: _bindgen_ty_13 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_13 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_13 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_13 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_13 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_13 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_13 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_13 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_13 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_13 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_13 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_13 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_13 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_13 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_13 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_13 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_13 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_13 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_13 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_13 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_13 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_13 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_13 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_13 = 132;
pub const _SC_BARRIERS: _bindgen_ty_13 = 133;
pub const _SC_BASE: _bindgen_ty_13 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_13 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_13 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_13 = 137;
pub const _SC_CPUTIME: _bindgen_ty_13 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_13 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_13 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_13 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_13 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_13 = 143;
pub const _SC_FIFO: _bindgen_ty_13 = 144;
pub const _SC_PIPE: _bindgen_ty_13 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_13 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_13 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_13 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_13 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_13 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_13 = 151;
pub const _SC_NETWORKING: _bindgen_ty_13 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_13 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_13 = 154;
pub const _SC_REGEXP: _bindgen_ty_13 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_13 = 156;
pub const _SC_SHELL: _bindgen_ty_13 = 157;
pub const _SC_SIGNALS: _bindgen_ty_13 = 158;
pub const _SC_SPAWN: _bindgen_ty_13 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_13 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_13 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_13 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_13 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_13 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_13 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_13 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_13 = 167;
pub const _SC_2_PBS: _bindgen_ty_13 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_13 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_13 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_13 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_13 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_13 = 173;
pub const _SC_STREAMS: _bindgen_ty_13 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_13 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_13 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_13 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_13 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_13 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_13 = 180;
pub const _SC_TRACE: _bindgen_ty_13 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_13 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_13 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_13 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_13 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_13 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_13 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_13 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_13 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_13 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_13 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_13 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_13 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_13 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_13 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_13 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_13 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_13 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_13 = 199;
pub const _SC_IPV6: _bindgen_ty_13 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_13 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_13 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_13 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_13 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_13 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_13 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_13 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_13 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_13 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_13 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_13 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_13 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_13 = 248;
pub type _bindgen_ty_13 = u32;
pub const _CS_PATH: _bindgen_ty_14 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_14 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_14 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_14 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_14 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_14 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_14 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_14 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_14 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_14 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_14 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_14 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_14 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_14 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_14 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_14 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_14 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_14 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_14 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_14 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_14 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_14 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_14 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_14 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_14 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_14 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_14 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_14 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_14 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_14 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_14 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_14 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_14 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_14 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_14 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_14 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_14 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_14 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_14 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_14 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_14 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_14 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_14 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_14 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_14 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_14 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_14 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_14 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_14 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_14 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_14 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_14 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_14 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_14 = 1149;
pub type _bindgen_ty_14 = u32;
extern "C" {
    pub fn pathconf(
        __path: *const raw_types::c_char,
        __name: raw_types::c_int,
    ) -> raw_types::c_long;
}
extern "C" {
    pub fn fpathconf(__fd: raw_types::c_int, __name: raw_types::c_int) -> raw_types::c_long;
}
extern "C" {
    pub fn sysconf(__name: raw_types::c_int) -> raw_types::c_long;
}
extern "C" {
    pub fn confstr(__name: raw_types::c_int, __buf: *mut raw_types::c_char, __len: usize) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn setpgrp() -> raw_types::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: raw_types::c_int, __list: *mut __gid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> raw_types::c_int;
}
extern "C" {
    pub fn ttyname(__fd: raw_types::c_int) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: raw_types::c_int,
        __buf: *mut raw_types::c_char,
        __buflen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn isatty(__fd: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn ttyslot() -> raw_types::c_int;
}
extern "C" {
    pub fn link(
        __from: *const raw_types::c_char,
        __to: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: raw_types::c_int,
        __from: *const raw_types::c_char,
        __tofd: raw_types::c_int,
        __to: *const raw_types::c_char,
        __flags: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const raw_types::c_char,
        __to: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const raw_types::c_char,
        __buf: *mut raw_types::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const raw_types::c_char,
        __tofd: raw_types::c_int,
        __to: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: raw_types::c_int,
        __path: *const raw_types::c_char,
        __buf: *mut raw_types::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: raw_types::c_int,
        __name: *const raw_types::c_char,
        __flag: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: raw_types::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: raw_types::c_int, __pgrp_id: __pid_t) -> raw_types::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut raw_types::c_char;
}
extern "C" {
    pub fn getlogin_r(__name: *mut raw_types::c_char, __name_len: usize) -> raw_types::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "optarg"]
    pub static mut optarg: *mut raw_types::c_char;
}
extern "C" {
    #[link_name = "optind"]
    pub static mut optind: raw_types::c_int;
}
extern "C" {
    #[link_name = "opterr"]
    pub static mut opterr: raw_types::c_int;
}
extern "C" {
    #[link_name = "optopt"]
    pub static mut optopt: raw_types::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: raw_types::c_int,
        ___argv: *const *mut raw_types::c_char,
        __shortopts: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut raw_types::c_char, __len: usize) -> raw_types::c_int;
}
extern "C" {
    pub fn sethostname(__name: *const raw_types::c_char, __len: usize) -> raw_types::c_int;
}
extern "C" {
    pub fn sethostid(__id: raw_types::c_long) -> raw_types::c_int;
}
extern "C" {
    pub fn getdomainname(__name: *mut raw_types::c_char, __len: usize) -> raw_types::c_int;
}
extern "C" {
    pub fn setdomainname(__name: *const raw_types::c_char, __len: usize) -> raw_types::c_int;
}
extern "C" {
    pub fn vhangup() -> raw_types::c_int;
}
extern "C" {
    pub fn revoke(__file: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut raw_types::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn acct(__name: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut raw_types::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(__nochdir: raw_types::c_int, __noclose: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn chroot(__path: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const raw_types::c_char) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn fsync(__fd: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn gethostid() -> raw_types::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> raw_types::c_int;
}
extern "C" {
    pub fn getdtablesize() -> raw_types::c_int;
}
extern "C" {
    pub fn truncate(__file: *const raw_types::c_char, __length: __off_t) -> raw_types::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: raw_types::c_int, __length: __off_t) -> raw_types::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut raw_types::c_void) -> raw_types::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut raw_types::c_void;
}
extern "C" {
    pub fn syscall(__sysno: raw_types::c_long, ...) -> raw_types::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: raw_types::c_int,
        __cmd: raw_types::c_int,
        __len: __off_t,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn getentropy(__buffer: *mut raw_types::c_void, __length: usize) -> raw_types::c_int;
}
pub type alloc_func =
    ::core::option::Option<unsafe extern "C" fn(opaque: voidpf, items: uInt, size: uInt) -> voidpf>;
pub type free_func = ::core::option::Option<unsafe extern "C" fn(opaque: voidpf, address: voidpf)>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct internal_state {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct z_stream_s {
    pub next_in: *mut Bytef,
    pub avail_in: uInt,
    pub total_in: uLong,
    pub next_out: *mut Bytef,
    pub avail_out: uInt,
    pub total_out: uLong,
    pub msg: *mut raw_types::c_char,
    pub state: *mut internal_state,
    pub zalloc: alloc_func,
    pub zfree: free_func,
    pub opaque: voidpf,
    pub data_type: raw_types::c_int,
    pub adler: uLong,
    pub reserved: uLong,
}
#[test]
fn bindgen_test_layout_z_stream_s() {
    assert_eq!(
        ::core::mem::size_of::<z_stream_s>(),
        112usize,
        concat!("Size of: ", stringify!(z_stream_s))
    );
    assert_eq!(
        ::core::mem::align_of::<z_stream_s>(),
        8usize,
        concat!("Alignment of ", stringify!(z_stream_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).next_in as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(next_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).avail_in as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(avail_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).total_in as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(total_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).next_out as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(next_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).avail_out as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(avail_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).total_out as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(total_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).msg as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).zalloc as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(zalloc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).zfree as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(zfree)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).opaque as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(opaque)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).data_type as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(data_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).adler as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(adler)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<z_stream_s>())).reserved as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(z_stream_s),
            "::",
            stringify!(reserved)
        )
    );
}
pub type z_stream = z_stream_s;
pub type z_streamp = *mut z_stream;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gz_header_s {
    pub text: raw_types::c_int,
    pub time: uLong,
    pub xflags: raw_types::c_int,
    pub os: raw_types::c_int,
    pub extra: *mut Bytef,
    pub extra_len: uInt,
    pub extra_max: uInt,
    pub name: *mut Bytef,
    pub name_max: uInt,
    pub comment: *mut Bytef,
    pub comm_max: uInt,
    pub hcrc: raw_types::c_int,
    pub done: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_gz_header_s() {
    assert_eq!(
        ::core::mem::size_of::<gz_header_s>(),
        80usize,
        concat!("Size of: ", stringify!(gz_header_s))
    );
    assert_eq!(
        ::core::mem::align_of::<gz_header_s>(),
        8usize,
        concat!("Alignment of ", stringify!(gz_header_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).text as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(text)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).time as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).xflags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(xflags)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).os as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(os)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).extra as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(extra)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).extra_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(extra_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).extra_max as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(extra_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).name as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).name_max as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(name_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).comment as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(comment)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).comm_max as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(comm_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).hcrc as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(hcrc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gz_header_s>())).done as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(gz_header_s),
            "::",
            stringify!(done)
        )
    );
}
pub type gz_header = gz_header_s;
pub type gz_headerp = *mut gz_header;
extern "C" {
    pub fn zlibVersion() -> *const raw_types::c_char;
}
extern "C" {
    pub fn deflate(strm: z_streamp, flush: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateEnd(strm: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn inflate(strm: z_streamp, flush: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateEnd(strm: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateSetDictionary(
        strm: z_streamp,
        dictionary: *const Bytef,
        dictLength: uInt,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateGetDictionary(
        strm: z_streamp,
        dictionary: *mut Bytef,
        dictLength: *mut uInt,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateCopy(dest: z_streamp, source: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateReset(strm: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateParams(
        strm: z_streamp,
        level: raw_types::c_int,
        strategy: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateTune(
        strm: z_streamp,
        good_length: raw_types::c_int,
        max_lazy: raw_types::c_int,
        nice_length: raw_types::c_int,
        max_chain: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateBound(strm: z_streamp, sourceLen: uLong) -> uLong;
}
extern "C" {
    pub fn deflatePending(
        strm: z_streamp,
        pending: *mut raw_types::c_uint,
        bits: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn deflatePrime(
        strm: z_streamp,
        bits: raw_types::c_int,
        value: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateSetHeader(strm: z_streamp, head: gz_headerp) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateSetDictionary(
        strm: z_streamp,
        dictionary: *const Bytef,
        dictLength: uInt,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateGetDictionary(
        strm: z_streamp,
        dictionary: *mut Bytef,
        dictLength: *mut uInt,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateSync(strm: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateCopy(dest: z_streamp, source: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateReset(strm: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateReset2(strm: z_streamp, windowBits: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn inflatePrime(
        strm: z_streamp,
        bits: raw_types::c_int,
        value: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateMark(strm: z_streamp) -> raw_types::c_long;
}
extern "C" {
    pub fn inflateGetHeader(strm: z_streamp, head: gz_headerp) -> raw_types::c_int;
}
pub type in_func = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut raw_types::c_void,
        arg2: *mut *mut raw_types::c_uchar,
    ) -> raw_types::c_uint,
>;
pub type out_func = ::core::option::Option<
    unsafe extern "C" fn(
        arg1: *mut raw_types::c_void,
        arg2: *mut raw_types::c_uchar,
        arg3: raw_types::c_uint,
    ) -> raw_types::c_int,
>;
extern "C" {
    pub fn inflateBack(
        strm: z_streamp,
        in_: in_func,
        in_desc: *mut raw_types::c_void,
        out: out_func,
        out_desc: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateBackEnd(strm: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn zlibCompileFlags() -> uLong;
}
extern "C" {
    pub fn compress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn compress2(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
        level: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn compressBound(sourceLen: uLong) -> uLong;
}
extern "C" {
    pub fn uncompress(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: uLong,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn uncompress2(
        dest: *mut Bytef,
        destLen: *mut uLongf,
        source: *const Bytef,
        sourceLen: *mut uLong,
    ) -> raw_types::c_int;
}
pub type gzFile = *mut gzFile_s;
extern "C" {
    pub fn gzdopen(fd: raw_types::c_int, mode: *const raw_types::c_char) -> gzFile;
}
extern "C" {
    pub fn gzbuffer(file: gzFile, size: raw_types::c_uint) -> raw_types::c_int;
}
extern "C" {
    pub fn gzsetparams(
        file: gzFile,
        level: raw_types::c_int,
        strategy: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn gzread(file: gzFile, buf: voidp, len: raw_types::c_uint) -> raw_types::c_int;
}
extern "C" {
    pub fn gzfread(buf: voidp, size: z_size_t, nitems: z_size_t, file: gzFile) -> z_size_t;
}
extern "C" {
    pub fn gzwrite(file: gzFile, buf: voidpc, len: raw_types::c_uint) -> raw_types::c_int;
}
extern "C" {
    pub fn gzfwrite(buf: voidpc, size: z_size_t, nitems: z_size_t, file: gzFile) -> z_size_t;
}
extern "C" {
    pub fn gzprintf(file: gzFile, format: *const raw_types::c_char, ...) -> raw_types::c_int;
}
extern "C" {
    pub fn gzputs(file: gzFile, s: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    pub fn gzgets(
        file: gzFile,
        buf: *mut raw_types::c_char,
        len: raw_types::c_int,
    ) -> *mut raw_types::c_char;
}
extern "C" {
    pub fn gzputc(file: gzFile, c: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn gzgetc(file: gzFile) -> raw_types::c_int;
}
extern "C" {
    pub fn gzungetc(c: raw_types::c_int, file: gzFile) -> raw_types::c_int;
}
extern "C" {
    pub fn gzflush(file: gzFile, flush: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn gzrewind(file: gzFile) -> raw_types::c_int;
}
extern "C" {
    pub fn gzeof(file: gzFile) -> raw_types::c_int;
}
extern "C" {
    pub fn gzdirect(file: gzFile) -> raw_types::c_int;
}
extern "C" {
    pub fn gzclose(file: gzFile) -> raw_types::c_int;
}
extern "C" {
    pub fn gzclose_r(file: gzFile) -> raw_types::c_int;
}
extern "C" {
    pub fn gzclose_w(file: gzFile) -> raw_types::c_int;
}
extern "C" {
    pub fn gzerror(file: gzFile, errnum: *mut raw_types::c_int) -> *const raw_types::c_char;
}
extern "C" {
    pub fn gzclearerr(file: gzFile);
}
extern "C" {
    pub fn adler32(adler: uLong, buf: *const Bytef, len: uInt) -> uLong;
}
extern "C" {
    pub fn adler32_z(adler: uLong, buf: *const Bytef, len: z_size_t) -> uLong;
}
extern "C" {
    pub fn crc32(crc: uLong, buf: *const Bytef, len: uInt) -> uLong;
}
extern "C" {
    pub fn crc32_z(adler: uLong, buf: *const Bytef, len: z_size_t) -> uLong;
}
extern "C" {
    pub fn deflateInit_(
        strm: z_streamp,
        level: raw_types::c_int,
        version: *const raw_types::c_char,
        stream_size: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateInit_(
        strm: z_streamp,
        version: *const raw_types::c_char,
        stream_size: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateInit2_(
        strm: z_streamp,
        level: raw_types::c_int,
        method: raw_types::c_int,
        windowBits: raw_types::c_int,
        memLevel: raw_types::c_int,
        strategy: raw_types::c_int,
        version: *const raw_types::c_char,
        stream_size: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateInit2_(
        strm: z_streamp,
        windowBits: raw_types::c_int,
        version: *const raw_types::c_char,
        stream_size: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateBackInit_(
        strm: z_streamp,
        windowBits: raw_types::c_int,
        window: *mut raw_types::c_uchar,
        version: *const raw_types::c_char,
        stream_size: raw_types::c_int,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gzFile_s {
    pub have: raw_types::c_uint,
    pub next: *mut raw_types::c_uchar,
    pub pos: off_t,
}
#[test]
fn bindgen_test_layout_gzFile_s() {
    assert_eq!(
        ::core::mem::size_of::<gzFile_s>(),
        24usize,
        concat!("Size of: ", stringify!(gzFile_s))
    );
    assert_eq!(
        ::core::mem::align_of::<gzFile_s>(),
        8usize,
        concat!("Alignment of ", stringify!(gzFile_s))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gzFile_s>())).have as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gzFile_s),
            "::",
            stringify!(have)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gzFile_s>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(gzFile_s),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gzFile_s>())).pos as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(gzFile_s),
            "::",
            stringify!(pos)
        )
    );
}
extern "C" {
    pub fn gzgetc_(file: gzFile) -> raw_types::c_int;
}
extern "C" {
    pub fn gzopen(arg1: *const raw_types::c_char, arg2: *const raw_types::c_char) -> gzFile;
}
extern "C" {
    pub fn gzseek(arg1: gzFile, arg2: off_t, arg3: raw_types::c_int) -> off_t;
}
extern "C" {
    pub fn gztell(arg1: gzFile) -> off_t;
}
extern "C" {
    pub fn gzoffset(arg1: gzFile) -> off_t;
}
extern "C" {
    pub fn adler32_combine(arg1: uLong, arg2: uLong, arg3: off_t) -> uLong;
}
extern "C" {
    pub fn crc32_combine(arg1: uLong, arg2: uLong, arg3: off_t) -> uLong;
}
extern "C" {
    pub fn zError(arg1: raw_types::c_int) -> *const raw_types::c_char;
}
extern "C" {
    pub fn inflateSyncPoint(arg1: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn get_crc_table() -> *const z_crc_t;
}
extern "C" {
    pub fn inflateUndermine(arg1: z_streamp, arg2: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateValidate(arg1: z_streamp, arg2: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    pub fn inflateCodesUsed(arg1: z_streamp) -> raw_types::c_ulong;
}
extern "C" {
    pub fn inflateResetKeep(arg1: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn deflateResetKeep(arg1: z_streamp) -> raw_types::c_int;
}
extern "C" {
    pub fn gzvprintf(
        file: gzFile,
        format: *const raw_types::c_char,
        va: *mut __va_list_tag,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ssl_premaster_secret {
    pub _pms_rsa: [raw_types::c_uchar; 48usize],
    pub _pms_dhm: [raw_types::c_uchar; 1024usize],
    pub _pms_ecdh: [raw_types::c_uchar; 66usize],
    pub _pms_psk: [raw_types::c_uchar; 68usize],
    pub _pms_dhe_psk: [raw_types::c_uchar; 1060usize],
    pub _pms_rsa_psk: [raw_types::c_uchar; 84usize],
    pub _pms_ecdhe_psk: [raw_types::c_uchar; 102usize],
    _bindgen_union_align: [u8; 1060usize],
}
#[test]
fn bindgen_test_layout_ssl_premaster_secret() {
    assert_eq!(
        ::core::mem::size_of::<ssl_premaster_secret>(),
        1060usize,
        concat!("Size of: ", stringify!(ssl_premaster_secret))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_premaster_secret>(),
        1usize,
        concat!("Alignment of ", stringify!(ssl_premaster_secret))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_rsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_rsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_dhm as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_dhm)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_ecdh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_ecdh)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_psk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_psk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_dhe_psk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_dhe_psk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_rsa_psk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_rsa_psk)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_premaster_secret>()))._pms_ecdhe_psk as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_premaster_secret),
            "::",
            stringify!(_pms_ecdhe_psk)
        )
    );
}
pub const SSL_HELLO_REQUEST: ssl_states = 0;
pub const SSL_CLIENT_HELLO: ssl_states = 1;
pub const SSL_SERVER_HELLO: ssl_states = 2;
pub const SSL_SERVER_CERTIFICATE: ssl_states = 3;
pub const SSL_SERVER_KEY_EXCHANGE: ssl_states = 4;
pub const SSL_CERTIFICATE_REQUEST: ssl_states = 5;
pub const SSL_SERVER_HELLO_DONE: ssl_states = 6;
pub const SSL_CLIENT_CERTIFICATE: ssl_states = 7;
pub const SSL_CLIENT_KEY_EXCHANGE: ssl_states = 8;
pub const SSL_CERTIFICATE_VERIFY: ssl_states = 9;
pub const SSL_CLIENT_CHANGE_CIPHER_SPEC: ssl_states = 10;
pub const SSL_CLIENT_FINISHED: ssl_states = 11;
pub const SSL_SERVER_CHANGE_CIPHER_SPEC: ssl_states = 12;
pub const SSL_SERVER_FINISHED: ssl_states = 13;
pub const SSL_FLUSH_BUFFERS: ssl_states = 14;
pub const SSL_HANDSHAKE_WRAPUP: ssl_states = 15;
pub const SSL_HANDSHAKE_OVER: ssl_states = 16;
pub const SSL_SERVER_NEW_SESSION_TICKET: ssl_states = 17;
pub const SSL_SERVER_HELLO_VERIFY_REQUEST_SENT: ssl_states = 18;
pub type ssl_states = u32;
pub type ssl_send_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut raw_types::c_void,
        buf: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int,
>;
pub type ssl_recv_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut raw_types::c_void,
        buf: *mut raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int,
>;
pub type ssl_recv_timeout_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut raw_types::c_void,
        buf: *mut raw_types::c_uchar,
        len: usize,
        timeout: u32,
    ) -> raw_types::c_int,
>;
pub type ssl_set_timer_t = ::core::option::Option<
    unsafe extern "C" fn(ctx: *mut raw_types::c_void, int_ms: u32, fin_ms: u32),
>;
pub type ssl_get_timer_t =
    ::core::option::Option<unsafe extern "C" fn(ctx: *mut raw_types::c_void) -> raw_types::c_int>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_session {
    pub start: mbedtls_time_t,
    pub ciphersuite: raw_types::c_int,
    pub compression: raw_types::c_int,
    pub id_len: usize,
    pub id: [raw_types::c_uchar; 32usize],
    pub master: [raw_types::c_uchar; 48usize],
    pub peer_cert: *mut x509_crt,
    pub verify_result: u32,
    pub ticket: *mut raw_types::c_uchar,
    pub ticket_len: usize,
    pub ticket_lifetime: u32,
    pub mfl_code: raw_types::c_uchar,
    pub trunc_hmac: raw_types::c_int,
    pub encrypt_then_mac: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_ssl_session() {
    assert_eq!(
        ::core::mem::size_of::<ssl_session>(),
        152usize,
        concat!("Size of: ", stringify!(ssl_session))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_session>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_session))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).start as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).ciphersuite as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ciphersuite)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).compression as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(compression)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).id_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(id_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).master as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(master)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).peer_cert as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(peer_cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).verify_result as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(verify_result)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).ticket as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ticket)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).ticket_len as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ticket_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).ticket_lifetime as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(ticket_lifetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).mfl_code as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(mfl_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).trunc_hmac as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(trunc_hmac)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_session>())).encrypt_then_mac as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_session),
            "::",
            stringify!(encrypt_then_mac)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_config {
    pub ciphersuite_list: [*const raw_types::c_int; 4usize],
    pub f_dbg: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: raw_types::c_int,
            arg3: *const raw_types::c_char,
            arg4: raw_types::c_int,
            arg5: *const raw_types::c_char,
        ),
    >,
    pub p_dbg: *mut raw_types::c_void,
    pub f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *mut raw_types::c_uchar,
            arg3: usize,
        ) -> raw_types::c_int,
    >,
    pub p_rng: *mut raw_types::c_void,
    pub f_get_cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *mut ssl_session,
        ) -> raw_types::c_int,
    >,
    pub f_set_cache: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *const ssl_session,
        ) -> raw_types::c_int,
    >,
    pub p_cache: *mut raw_types::c_void,
    pub f_sni: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *mut ssl_context,
            arg3: *const raw_types::c_uchar,
            arg4: usize,
        ) -> raw_types::c_int,
    >,
    pub p_sni: *mut raw_types::c_void,
    pub f_vrfy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *mut x509_crt,
            arg3: raw_types::c_int,
            arg4: *mut u32,
        ) -> raw_types::c_int,
    >,
    pub p_vrfy: *mut raw_types::c_void,
    pub f_psk: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *mut ssl_context,
            arg3: *const raw_types::c_uchar,
            arg4: usize,
        ) -> raw_types::c_int,
    >,
    pub p_psk: *mut raw_types::c_void,
    pub f_cookie_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *mut *mut raw_types::c_uchar,
            arg3: *mut raw_types::c_uchar,
            arg4: *const raw_types::c_uchar,
            arg5: usize,
        ) -> raw_types::c_int,
    >,
    pub f_cookie_check: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *const raw_types::c_uchar,
            arg3: usize,
            arg4: *const raw_types::c_uchar,
            arg5: usize,
        ) -> raw_types::c_int,
    >,
    pub p_cookie: *mut raw_types::c_void,
    pub f_ticket_write: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *const ssl_session,
            arg3: *mut raw_types::c_uchar,
            arg4: *const raw_types::c_uchar,
            arg5: *mut usize,
            arg6: *mut u32,
        ) -> raw_types::c_int,
    >,
    pub f_ticket_parse: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *mut ssl_session,
            arg3: *mut raw_types::c_uchar,
            arg4: usize,
        ) -> raw_types::c_int,
    >,
    pub p_ticket: *mut raw_types::c_void,
    pub f_export_keys: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *const raw_types::c_uchar,
            arg3: *const raw_types::c_uchar,
            arg4: usize,
            arg5: usize,
            arg6: usize,
        ) -> raw_types::c_int,
    >,
    pub p_export_keys: *mut raw_types::c_void,
    pub cert_profile: *const x509_crt_profile,
    pub key_cert: *mut ssl_key_cert,
    pub ca_chain: *mut x509_crt,
    pub ca_crl: *mut x509_crl,
    pub sig_hashes: *const raw_types::c_int,
    pub curve_list: *const ecp_group_id,
    pub dhm_P: mpi,
    pub dhm_G: mpi,
    pub psk: *mut raw_types::c_uchar,
    pub psk_len: usize,
    pub psk_identity: *mut raw_types::c_uchar,
    pub psk_identity_len: usize,
    pub alpn_list: *mut *const raw_types::c_char,
    pub read_timeout: u32,
    pub hs_timeout_min: u32,
    pub hs_timeout_max: u32,
    pub renego_max_records: raw_types::c_int,
    pub renego_period: [raw_types::c_uchar; 8usize],
    pub badmac_limit: raw_types::c_uint,
    pub dhm_min_bitlen: raw_types::c_uint,
    pub max_major_ver: raw_types::c_uchar,
    pub max_minor_ver: raw_types::c_uchar,
    pub min_major_ver: raw_types::c_uchar,
    pub min_minor_ver: raw_types::c_uchar,
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 3usize], u8>,
    pub __bindgen_padding_0: u8,
}
#[test]
fn bindgen_test_layout_ssl_config() {
    assert_eq!(
        ::core::mem::size_of::<ssl_config>(),
        376usize,
        concat!("Size of: ", stringify!(ssl_config))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_config>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_config))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).ciphersuite_list as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(ciphersuite_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_dbg as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_dbg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_dbg as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_dbg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_rng as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_rng)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_rng as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_rng)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_get_cache as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_get_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_set_cache as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_set_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_cache as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_cache)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_sni as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_sni)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_sni as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_sni)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_vrfy as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_vrfy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_vrfy as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_vrfy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_psk as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_psk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_psk as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_psk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_cookie_write as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_cookie_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_cookie_check as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_cookie_check)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_cookie as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_cookie)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_ticket_write as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_ticket_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_ticket_parse as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_ticket_parse)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_ticket as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_ticket)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).f_export_keys as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(f_export_keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).p_export_keys as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(p_export_keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).cert_profile as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(cert_profile)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).key_cert as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(key_cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).ca_chain as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(ca_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).ca_crl as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(ca_crl)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).sig_hashes as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(sig_hashes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).curve_list as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(curve_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).dhm_P as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(dhm_P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).dhm_G as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(dhm_G)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).psk as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).psk_len as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).psk_identity as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk_identity)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).psk_identity_len as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(psk_identity_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).alpn_list as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(alpn_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).read_timeout as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(read_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).hs_timeout_min as *const _ as usize },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(hs_timeout_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).hs_timeout_max as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(hs_timeout_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).renego_max_records as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(renego_max_records)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).renego_period as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(renego_period)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).badmac_limit as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(badmac_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).dhm_min_bitlen as *const _ as usize },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(dhm_min_bitlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).max_major_ver as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(max_major_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).max_minor_ver as *const _ as usize },
        369usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(max_minor_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).min_major_ver as *const _ as usize },
        370usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(min_major_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_config>())).min_minor_ver as *const _ as usize },
        371usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_config),
            "::",
            stringify!(min_minor_ver)
        )
    );
}
impl ssl_config {
    #[inline]
    pub fn endpoint(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_endpoint(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn transport(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_transport(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn authmode(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_authmode(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn allow_legacy_renegotiation(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(5usize, 2u8) as u32) }
    }
    #[inline]
    pub fn set_allow_legacy_renegotiation(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(5usize, 2u8, val as u64)
        }
    }
    #[inline]
    pub fn arc4_disabled(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_arc4_disabled(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn mfl_code(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(8usize, 3u8) as u32) }
    }
    #[inline]
    pub fn set_mfl_code(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(8usize, 3u8, val as u64)
        }
    }
    #[inline]
    pub fn encrypt_then_mac(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(11usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_encrypt_then_mac(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(11usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn extended_ms(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(12usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_extended_ms(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(12usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn anti_replay(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(13usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_anti_replay(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(13usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cbc_record_splitting(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(14usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cbc_record_splitting(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(14usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn disable_renegotiation(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(15usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_disable_renegotiation(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(15usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn trunc_hmac(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_trunc_hmac(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(16usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn session_tickets(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(17usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_session_tickets(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(17usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn fallback(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(18usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_fallback(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(18usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn cert_req_ca_list(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(19usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_cert_req_ca_list(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(19usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        endpoint: raw_types::c_uint,
        transport: raw_types::c_uint,
        authmode: raw_types::c_uint,
        allow_legacy_renegotiation: raw_types::c_uint,
        arc4_disabled: raw_types::c_uint,
        mfl_code: raw_types::c_uint,
        encrypt_then_mac: raw_types::c_uint,
        extended_ms: raw_types::c_uint,
        anti_replay: raw_types::c_uint,
        cbc_record_splitting: raw_types::c_uint,
        disable_renegotiation: raw_types::c_uint,
        trunc_hmac: raw_types::c_uint,
        session_tickets: raw_types::c_uint,
        fallback: raw_types::c_uint,
        cert_req_ca_list: raw_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 3usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 3usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let endpoint: u32 = unsafe { ::core::mem::transmute(endpoint) };
            endpoint as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let transport: u32 = unsafe { ::core::mem::transmute(transport) };
            transport as u64
        });
        __bindgen_bitfield_unit.set(2usize, 3u8, {
            let authmode: u32 = unsafe { ::core::mem::transmute(authmode) };
            authmode as u64
        });
        __bindgen_bitfield_unit.set(5usize, 2u8, {
            let allow_legacy_renegotiation: u32 =
                unsafe { ::core::mem::transmute(allow_legacy_renegotiation) };
            allow_legacy_renegotiation as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let arc4_disabled: u32 = unsafe { ::core::mem::transmute(arc4_disabled) };
            arc4_disabled as u64
        });
        __bindgen_bitfield_unit.set(8usize, 3u8, {
            let mfl_code: u32 = unsafe { ::core::mem::transmute(mfl_code) };
            mfl_code as u64
        });
        __bindgen_bitfield_unit.set(11usize, 1u8, {
            let encrypt_then_mac: u32 = unsafe { ::core::mem::transmute(encrypt_then_mac) };
            encrypt_then_mac as u64
        });
        __bindgen_bitfield_unit.set(12usize, 1u8, {
            let extended_ms: u32 = unsafe { ::core::mem::transmute(extended_ms) };
            extended_ms as u64
        });
        __bindgen_bitfield_unit.set(13usize, 1u8, {
            let anti_replay: u32 = unsafe { ::core::mem::transmute(anti_replay) };
            anti_replay as u64
        });
        __bindgen_bitfield_unit.set(14usize, 1u8, {
            let cbc_record_splitting: u32 = unsafe { ::core::mem::transmute(cbc_record_splitting) };
            cbc_record_splitting as u64
        });
        __bindgen_bitfield_unit.set(15usize, 1u8, {
            let disable_renegotiation: u32 =
                unsafe { ::core::mem::transmute(disable_renegotiation) };
            disable_renegotiation as u64
        });
        __bindgen_bitfield_unit.set(16usize, 1u8, {
            let trunc_hmac: u32 = unsafe { ::core::mem::transmute(trunc_hmac) };
            trunc_hmac as u64
        });
        __bindgen_bitfield_unit.set(17usize, 1u8, {
            let session_tickets: u32 = unsafe { ::core::mem::transmute(session_tickets) };
            session_tickets as u64
        });
        __bindgen_bitfield_unit.set(18usize, 1u8, {
            let fallback: u32 = unsafe { ::core::mem::transmute(fallback) };
            fallback as u64
        });
        __bindgen_bitfield_unit.set(19usize, 1u8, {
            let cert_req_ca_list: u32 = unsafe { ::core::mem::transmute(cert_req_ca_list) };
            cert_req_ca_list as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_context {
    pub conf: *const ssl_config,
    pub state: raw_types::c_int,
    pub renego_status: raw_types::c_int,
    pub renego_records_seen: raw_types::c_int,
    pub major_ver: raw_types::c_int,
    pub minor_ver: raw_types::c_int,
    pub badmac_seen: raw_types::c_uint,
    pub f_send: ssl_send_t,
    pub f_recv: ssl_recv_t,
    pub f_recv_timeout: ssl_recv_timeout_t,
    pub p_bio: *mut raw_types::c_void,
    pub session_in: *mut ssl_session,
    pub session_out: *mut ssl_session,
    pub session: *mut ssl_session,
    pub session_negotiate: *mut ssl_session,
    pub handshake: *mut ssl_handshake_params,
    pub transform_in: *mut ssl_transform,
    pub transform_out: *mut ssl_transform,
    pub transform: *mut ssl_transform,
    pub transform_negotiate: *mut ssl_transform,
    pub p_timer: *mut raw_types::c_void,
    pub f_set_timer: ssl_set_timer_t,
    pub f_get_timer: ssl_get_timer_t,
    pub in_buf: *mut raw_types::c_uchar,
    pub in_ctr: *mut raw_types::c_uchar,
    pub in_hdr: *mut raw_types::c_uchar,
    pub in_len: *mut raw_types::c_uchar,
    pub in_iv: *mut raw_types::c_uchar,
    pub in_msg: *mut raw_types::c_uchar,
    pub in_offt: *mut raw_types::c_uchar,
    pub in_msgtype: raw_types::c_int,
    pub in_msglen: usize,
    pub in_left: usize,
    pub in_epoch: u16,
    pub next_record_offset: usize,
    pub in_window_top: u64,
    pub in_window: u64,
    pub in_hslen: usize,
    pub nb_zero: raw_types::c_int,
    pub keep_current_message: raw_types::c_int,
    pub disable_datagram_packing: u8,
    pub out_buf: *mut raw_types::c_uchar,
    pub out_ctr: *mut raw_types::c_uchar,
    pub out_hdr: *mut raw_types::c_uchar,
    pub out_len: *mut raw_types::c_uchar,
    pub out_iv: *mut raw_types::c_uchar,
    pub out_msg: *mut raw_types::c_uchar,
    pub out_msgtype: raw_types::c_int,
    pub out_msglen: usize,
    pub out_left: usize,
    pub cur_out_ctr: [raw_types::c_uchar; 8usize],
    pub mtu: u16,
    pub compress_buf: *mut raw_types::c_uchar,
    pub split_done: raw_types::c_schar,
    pub out_mutex: threading_mutex_t,
    pub client_auth: raw_types::c_int,
    pub hostname: *mut raw_types::c_char,
    pub alpn_chosen: *const raw_types::c_char,
    pub cli_id: *mut raw_types::c_uchar,
    pub cli_id_len: usize,
    pub secure_renegotiation: raw_types::c_int,
    pub verify_data_len: usize,
    pub own_verify_data: [raw_types::c_char; 36usize],
    pub peer_verify_data: [raw_types::c_char; 36usize],
}
#[test]
fn bindgen_test_layout_ssl_context() {
    assert_eq!(
        ::core::mem::size_of::<ssl_context>(),
        576usize,
        concat!("Size of: ", stringify!(ssl_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).conf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).renego_status as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(renego_status)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_context>())).renego_records_seen as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(renego_records_seen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).major_ver as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(major_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).minor_ver as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(minor_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).badmac_seen as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(badmac_seen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_send as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_send)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_recv as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_recv_timeout as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_recv_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).p_bio as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(p_bio)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).session_in as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).session_out as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).session as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).session_negotiate as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(session_negotiate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).handshake as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(handshake)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).transform_in as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform_in)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).transform_out as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform_out)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).transform as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_context>())).transform_negotiate as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(transform_negotiate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).p_timer as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(p_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_set_timer as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_set_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).f_get_timer as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(f_get_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_buf as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_ctr as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_hdr as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_len as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_iv as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_msg as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_offt as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_offt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_msgtype as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_msgtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_msglen as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_msglen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_left as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_epoch as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_epoch)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).next_record_offset as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(next_record_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_window_top as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_window_top)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_window as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_window)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).in_hslen as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(in_hslen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).nb_zero as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(nb_zero)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_context>())).keep_current_message as *const _ as usize
        },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(keep_current_message)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_context>())).disable_datagram_packing as *const _ as usize
        },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(disable_datagram_packing)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_buf as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_ctr as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_hdr as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_len as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_iv as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_iv)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_msg as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_msgtype as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_msgtype)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_msglen as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_msglen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_left as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_left)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).cur_out_ctr as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(cur_out_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).mtu as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).compress_buf as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(compress_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).split_done as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(split_done)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).out_mutex as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(out_mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).client_auth as *const _ as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(client_auth)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).hostname as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(hostname)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).alpn_chosen as *const _ as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(alpn_chosen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).cli_id as *const _ as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(cli_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).cli_id_len as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(cli_id_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_context>())).secure_renegotiation as *const _ as usize
        },
        488usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(secure_renegotiation)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).verify_data_len as *const _ as usize },
        496usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(verify_data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).own_verify_data as *const _ as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(own_verify_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_context>())).peer_verify_data as *const _ as usize },
        540usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_context),
            "::",
            stringify!(peer_verify_data)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_ciphersuite_name"]
    pub fn ssl_get_ciphersuite_name(ciphersuite_id: raw_types::c_int) -> *const raw_types::c_char;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_ciphersuite_id"]
    pub fn ssl_get_ciphersuite_id(ciphersuite_name: *const raw_types::c_char) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_init"]
    pub fn ssl_init(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_setup"]
    pub fn ssl_setup(ssl: *mut ssl_context, conf: *const ssl_config) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_session_reset"]
    pub fn ssl_session_reset(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_endpoint"]
    pub fn ssl_conf_endpoint(conf: *mut ssl_config, endpoint: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_transport"]
    pub fn ssl_conf_transport(conf: *mut ssl_config, transport: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_authmode"]
    pub fn ssl_conf_authmode(conf: *mut ssl_config, authmode: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_verify"]
    pub fn ssl_conf_verify(
        conf: *mut ssl_config,
        f_vrfy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut x509_crt,
                arg3: raw_types::c_int,
                arg4: *mut u32,
            ) -> raw_types::c_int,
        >,
        p_vrfy: *mut raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_rng"]
    pub fn ssl_conf_rng(
        conf: *mut ssl_config,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_dbg"]
    pub fn ssl_conf_dbg(
        conf: *mut ssl_config,
        f_dbg: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: raw_types::c_int,
                arg3: *const raw_types::c_char,
                arg4: raw_types::c_int,
                arg5: *const raw_types::c_char,
            ),
        >,
        p_dbg: *mut raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_bio"]
    pub fn ssl_set_bio(
        ssl: *mut ssl_context,
        p_bio: *mut raw_types::c_void,
        f_send: ssl_send_t,
        f_recv: ssl_recv_t,
        f_recv_timeout: ssl_recv_timeout_t,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_mtu"]
    pub fn ssl_set_mtu(ssl: *mut ssl_context, mtu: u16);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_read_timeout"]
    pub fn ssl_conf_read_timeout(conf: *mut ssl_config, timeout: u32);
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_timer_cb"]
    pub fn ssl_set_timer_cb(
        ssl: *mut ssl_context,
        p_timer: *mut raw_types::c_void,
        f_set_timer: ssl_set_timer_t,
        f_get_timer: ssl_get_timer_t,
    );
}
pub type ssl_ticket_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut raw_types::c_void,
        session: *const ssl_session,
        start: *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        tlen: *mut usize,
        lifetime: *mut u32,
    ) -> raw_types::c_int,
>;
pub type ssl_export_keys_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_expkey: *mut raw_types::c_void,
        ms: *const raw_types::c_uchar,
        kb: *const raw_types::c_uchar,
        maclen: usize,
        keylen: usize,
        ivlen: usize,
    ) -> raw_types::c_int,
>;
pub type ssl_ticket_parse_t = ::core::option::Option<
    unsafe extern "C" fn(
        p_ticket: *mut raw_types::c_void,
        session: *mut ssl_session,
        buf: *mut raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int,
>;
extern "C" {
    #[link_name = "mbedtls_ssl_conf_session_tickets_cb"]
    pub fn ssl_conf_session_tickets_cb(
        conf: *mut ssl_config,
        f_ticket_write: ssl_ticket_write_t,
        f_ticket_parse: ssl_ticket_parse_t,
        p_ticket: *mut raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_export_keys_cb"]
    pub fn ssl_conf_export_keys_cb(
        conf: *mut ssl_config,
        f_export_keys: ssl_export_keys_t,
        p_export_keys: *mut raw_types::c_void,
    );
}
pub type ssl_cookie_write_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut raw_types::c_void,
        p: *mut *mut raw_types::c_uchar,
        end: *mut raw_types::c_uchar,
        info: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int,
>;
pub type ssl_cookie_check_t = ::core::option::Option<
    unsafe extern "C" fn(
        ctx: *mut raw_types::c_void,
        cookie: *const raw_types::c_uchar,
        clen: usize,
        info: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int,
>;
extern "C" {
    #[link_name = "mbedtls_ssl_conf_dtls_cookies"]
    pub fn ssl_conf_dtls_cookies(
        conf: *mut ssl_config,
        f_cookie_write: ssl_cookie_write_t,
        f_cookie_check: ssl_cookie_check_t,
        p_cookie: *mut raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_client_transport_id"]
    pub fn ssl_set_client_transport_id(
        ssl: *mut ssl_context,
        info: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_dtls_anti_replay"]
    pub fn ssl_conf_dtls_anti_replay(conf: *mut ssl_config, mode: raw_types::c_char);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_dtls_badmac_limit"]
    pub fn ssl_conf_dtls_badmac_limit(conf: *mut ssl_config, limit: raw_types::c_uint);
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_datagram_packing"]
    pub fn ssl_set_datagram_packing(ssl: *mut ssl_context, allow_packing: raw_types::c_uint);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_handshake_timeout"]
    pub fn ssl_conf_handshake_timeout(conf: *mut ssl_config, min: u32, max: u32);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_session_cache"]
    pub fn ssl_conf_session_cache(
        conf: *mut ssl_config,
        p_cache: *mut raw_types::c_void,
        f_get_cache: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut ssl_session,
            ) -> raw_types::c_int,
        >,
        f_set_cache: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *const ssl_session,
            ) -> raw_types::c_int,
        >,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_session"]
    pub fn ssl_set_session(ssl: *mut ssl_context, session: *const ssl_session) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_ciphersuites"]
    pub fn ssl_conf_ciphersuites(conf: *mut ssl_config, ciphersuites: *const raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_ciphersuites_for_version"]
    pub fn ssl_conf_ciphersuites_for_version(
        conf: *mut ssl_config,
        ciphersuites: *const raw_types::c_int,
        major: raw_types::c_int,
        minor: raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_cert_profile"]
    pub fn ssl_conf_cert_profile(conf: *mut ssl_config, profile: *const x509_crt_profile);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_ca_chain"]
    pub fn ssl_conf_ca_chain(conf: *mut ssl_config, ca_chain: *mut x509_crt, ca_crl: *mut x509_crl);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_own_cert"]
    pub fn ssl_conf_own_cert(
        conf: *mut ssl_config,
        own_cert: *mut x509_crt,
        pk_key: *mut pk_context,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_psk"]
    pub fn ssl_conf_psk(
        conf: *mut ssl_config,
        psk: *const raw_types::c_uchar,
        psk_len: usize,
        psk_identity: *const raw_types::c_uchar,
        psk_identity_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_hs_psk"]
    pub fn ssl_set_hs_psk(
        ssl: *mut ssl_context,
        psk: *const raw_types::c_uchar,
        psk_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_psk_cb"]
    pub fn ssl_conf_psk_cb(
        conf: *mut ssl_config,
        f_psk: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut ssl_context,
                arg3: *const raw_types::c_uchar,
                arg4: usize,
            ) -> raw_types::c_int,
        >,
        p_psk: *mut raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_dh_param"]
    pub fn ssl_conf_dh_param(
        conf: *mut ssl_config,
        dhm_P: *const raw_types::c_char,
        dhm_G: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_dh_param_bin"]
    pub fn ssl_conf_dh_param_bin(
        conf: *mut ssl_config,
        dhm_P: *const raw_types::c_uchar,
        P_len: usize,
        dhm_G: *const raw_types::c_uchar,
        G_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_dh_param_ctx"]
    pub fn ssl_conf_dh_param_ctx(
        conf: *mut ssl_config,
        dhm_ctx: *mut dhm_context,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_dhm_min_bitlen"]
    pub fn ssl_conf_dhm_min_bitlen(conf: *mut ssl_config, bitlen: raw_types::c_uint);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_curves"]
    pub fn ssl_conf_curves(conf: *mut ssl_config, curves: *const ecp_group_id);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_sig_hashes"]
    pub fn ssl_conf_sig_hashes(conf: *mut ssl_config, hashes: *const raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_hostname"]
    pub fn ssl_set_hostname(
        ssl: *mut ssl_context,
        hostname: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_hs_own_cert"]
    pub fn ssl_set_hs_own_cert(
        ssl: *mut ssl_context,
        own_cert: *mut x509_crt,
        pk_key: *mut pk_context,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_hs_ca_chain"]
    pub fn ssl_set_hs_ca_chain(
        ssl: *mut ssl_context,
        ca_chain: *mut x509_crt,
        ca_crl: *mut x509_crl,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_hs_authmode"]
    pub fn ssl_set_hs_authmode(ssl: *mut ssl_context, authmode: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_sni"]
    pub fn ssl_conf_sni(
        conf: *mut ssl_config,
        f_sni: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut ssl_context,
                arg3: *const raw_types::c_uchar,
                arg4: usize,
            ) -> raw_types::c_int,
        >,
        p_sni: *mut raw_types::c_void,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_alpn_protocols"]
    pub fn ssl_conf_alpn_protocols(
        conf: *mut ssl_config,
        protos: *mut *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_alpn_protocol"]
    pub fn ssl_get_alpn_protocol(ssl: *const ssl_context) -> *const raw_types::c_char;
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_max_version"]
    pub fn ssl_conf_max_version(
        conf: *mut ssl_config,
        major: raw_types::c_int,
        minor: raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_min_version"]
    pub fn ssl_conf_min_version(
        conf: *mut ssl_config,
        major: raw_types::c_int,
        minor: raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_fallback"]
    pub fn ssl_conf_fallback(conf: *mut ssl_config, fallback: raw_types::c_char);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_encrypt_then_mac"]
    pub fn ssl_conf_encrypt_then_mac(conf: *mut ssl_config, etm: raw_types::c_char);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_extended_master_secret"]
    pub fn ssl_conf_extended_master_secret(conf: *mut ssl_config, ems: raw_types::c_char);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_arc4_support"]
    pub fn ssl_conf_arc4_support(conf: *mut ssl_config, arc4: raw_types::c_char);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_cert_req_ca_list"]
    pub fn ssl_conf_cert_req_ca_list(conf: *mut ssl_config, cert_req_ca_list: raw_types::c_char);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_max_frag_len"]
    pub fn ssl_conf_max_frag_len(
        conf: *mut ssl_config,
        mfl_code: raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_truncated_hmac"]
    pub fn ssl_conf_truncated_hmac(conf: *mut ssl_config, truncate: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_cbc_record_splitting"]
    pub fn ssl_conf_cbc_record_splitting(conf: *mut ssl_config, split: raw_types::c_char);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_session_tickets"]
    pub fn ssl_conf_session_tickets(conf: *mut ssl_config, use_tickets: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_renegotiation"]
    pub fn ssl_conf_renegotiation(conf: *mut ssl_config, renegotiation: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_legacy_renegotiation"]
    pub fn ssl_conf_legacy_renegotiation(conf: *mut ssl_config, allow_legacy: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_renegotiation_enforced"]
    pub fn ssl_conf_renegotiation_enforced(conf: *mut ssl_config, max_records: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_conf_renegotiation_period"]
    pub fn ssl_conf_renegotiation_period(conf: *mut ssl_config, period: *const raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_ssl_check_pending"]
    pub fn ssl_check_pending(ssl: *const ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_bytes_avail"]
    pub fn ssl_get_bytes_avail(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_verify_result"]
    pub fn ssl_get_verify_result(ssl: *const ssl_context) -> u32;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_ciphersuite"]
    pub fn ssl_get_ciphersuite(ssl: *const ssl_context) -> *const raw_types::c_char;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_version"]
    pub fn ssl_get_version(ssl: *const ssl_context) -> *const raw_types::c_char;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_record_expansion"]
    pub fn ssl_get_record_expansion(ssl: *const ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_max_frag_len"]
    pub fn ssl_get_max_frag_len(ssl: *const ssl_context) -> usize;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_max_out_record_payload"]
    pub fn ssl_get_max_out_record_payload(ssl: *const ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_peer_cert"]
    pub fn ssl_get_peer_cert(ssl: *const ssl_context) -> *const x509_crt;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_session"]
    pub fn ssl_get_session(ssl: *const ssl_context, session: *mut ssl_session) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_handshake"]
    pub fn ssl_handshake(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_handshake_step"]
    pub fn ssl_handshake_step(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_renegotiate"]
    pub fn ssl_renegotiate(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_read"]
    pub fn ssl_read(
        ssl: *mut ssl_context,
        buf: *mut raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_write"]
    pub fn ssl_write(
        ssl: *mut ssl_context,
        buf: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_send_alert_message"]
    pub fn ssl_send_alert_message(
        ssl: *mut ssl_context,
        level: raw_types::c_uchar,
        message: raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_close_notify"]
    pub fn ssl_close_notify(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_free"]
    pub fn ssl_free(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_config_init"]
    pub fn ssl_config_init(conf: *mut ssl_config);
}
extern "C" {
    #[link_name = "mbedtls_ssl_config_defaults"]
    pub fn ssl_config_defaults(
        conf: *mut ssl_config,
        endpoint: raw_types::c_int,
        transport: raw_types::c_int,
        preset: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_config_free"]
    pub fn ssl_config_free(conf: *mut ssl_config);
}
extern "C" {
    #[link_name = "mbedtls_ssl_session_init"]
    pub fn ssl_session_init(session: *mut ssl_session);
}
extern "C" {
    #[link_name = "mbedtls_ssl_session_free"]
    pub fn ssl_session_free(session: *mut ssl_session);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md5_context {
    pub total: [u32; 2usize],
    pub state: [u32; 4usize],
    pub buffer: [raw_types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md5_context() {
    assert_eq!(
        ::core::mem::size_of::<md5_context>(),
        88usize,
        concat!("Size of: ", stringify!(md5_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md5_context>(),
        4usize,
        concat!("Alignment of ", stringify!(md5_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md5_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md5_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md5_context>())).buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md5_context),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_md5_init"]
    pub fn md5_init(ctx: *mut md5_context);
}
extern "C" {
    #[link_name = "mbedtls_md5_free"]
    pub fn md5_free(ctx: *mut md5_context);
}
extern "C" {
    #[link_name = "mbedtls_md5_clone"]
    pub fn md5_clone(dst: *mut md5_context, src: *const md5_context);
}
extern "C" {
    #[link_name = "mbedtls_md5_starts_ret"]
    pub fn md5_starts_ret(ctx: *mut md5_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md5_update_ret"]
    pub fn md5_update_ret(
        ctx: *mut md5_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md5_finish_ret"]
    pub fn md5_finish_ret(
        ctx: *mut md5_context,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_internal_md5_process"]
    pub fn internal_md5_process(
        ctx: *mut md5_context,
        data: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md5_starts"]
    pub fn md5_starts(ctx: *mut md5_context);
}
extern "C" {
    #[link_name = "mbedtls_md5_update"]
    pub fn md5_update(ctx: *mut md5_context, input: *const raw_types::c_uchar, ilen: usize);
}
extern "C" {
    #[link_name = "mbedtls_md5_finish"]
    pub fn md5_finish(ctx: *mut md5_context, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_md5_process"]
    pub fn md5_process(ctx: *mut md5_context, data: *const raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_md5_ret"]
    pub fn md5_ret(
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md5"]
    pub fn md5(input: *const raw_types::c_uchar, ilen: usize, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_md5_self_test"]
    pub fn md5_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha1_context {
    pub total: [u32; 2usize],
    pub state: [u32; 5usize],
    pub buffer: [raw_types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_sha1_context() {
    assert_eq!(
        ::core::mem::size_of::<sha1_context>(),
        92usize,
        concat!("Size of: ", stringify!(sha1_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha1_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sha1_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha1_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha1_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha1_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha1_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha1_context>())).buffer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(sha1_context),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_sha1_init"]
    pub fn sha1_init(ctx: *mut sha1_context);
}
extern "C" {
    #[link_name = "mbedtls_sha1_free"]
    pub fn sha1_free(ctx: *mut sha1_context);
}
extern "C" {
    #[link_name = "mbedtls_sha1_clone"]
    pub fn sha1_clone(dst: *mut sha1_context, src: *const sha1_context);
}
extern "C" {
    #[link_name = "mbedtls_sha1_starts_ret"]
    pub fn sha1_starts_ret(ctx: *mut sha1_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha1_update_ret"]
    pub fn sha1_update_ret(
        ctx: *mut sha1_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha1_finish_ret"]
    pub fn sha1_finish_ret(
        ctx: *mut sha1_context,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_internal_sha1_process"]
    pub fn internal_sha1_process(
        ctx: *mut sha1_context,
        data: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha1_starts"]
    pub fn sha1_starts(ctx: *mut sha1_context);
}
extern "C" {
    #[link_name = "mbedtls_sha1_update"]
    pub fn sha1_update(ctx: *mut sha1_context, input: *const raw_types::c_uchar, ilen: usize);
}
extern "C" {
    #[link_name = "mbedtls_sha1_finish"]
    pub fn sha1_finish(ctx: *mut sha1_context, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_sha1_process"]
    pub fn sha1_process(ctx: *mut sha1_context, data: *const raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_sha1_ret"]
    pub fn sha1_ret(
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha1"]
    pub fn sha1(input: *const raw_types::c_uchar, ilen: usize, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_sha1_self_test"]
    pub fn sha1_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha256_context {
    pub total: [u32; 2usize],
    pub state: [u32; 8usize],
    pub buffer: [raw_types::c_uchar; 64usize],
    pub is224: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_sha256_context() {
    assert_eq!(
        ::core::mem::size_of::<sha256_context>(),
        108usize,
        concat!("Size of: ", stringify!(sha256_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha256_context>(),
        4usize,
        concat!("Alignment of ", stringify!(sha256_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha256_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha256_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha256_context>())).buffer as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha256_context>())).is224 as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(sha256_context),
            "::",
            stringify!(is224)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_sha256_init"]
    pub fn sha256_init(ctx: *mut sha256_context);
}
extern "C" {
    #[link_name = "mbedtls_sha256_free"]
    pub fn sha256_free(ctx: *mut sha256_context);
}
extern "C" {
    #[link_name = "mbedtls_sha256_clone"]
    pub fn sha256_clone(dst: *mut sha256_context, src: *const sha256_context);
}
extern "C" {
    #[link_name = "mbedtls_sha256_starts_ret"]
    pub fn sha256_starts_ret(ctx: *mut sha256_context, is224: raw_types::c_int)
        -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha256_update_ret"]
    pub fn sha256_update_ret(
        ctx: *mut sha256_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha256_finish_ret"]
    pub fn sha256_finish_ret(
        ctx: *mut sha256_context,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_internal_sha256_process"]
    pub fn internal_sha256_process(
        ctx: *mut sha256_context,
        data: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha256_starts"]
    pub fn sha256_starts(ctx: *mut sha256_context, is224: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_sha256_update"]
    pub fn sha256_update(ctx: *mut sha256_context, input: *const raw_types::c_uchar, ilen: usize);
}
extern "C" {
    #[link_name = "mbedtls_sha256_finish"]
    pub fn sha256_finish(ctx: *mut sha256_context, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_sha256_process"]
    pub fn sha256_process(ctx: *mut sha256_context, data: *const raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_sha256_ret"]
    pub fn sha256_ret(
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
        is224: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha256"]
    pub fn sha256(
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
        is224: raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "mbedtls_sha256_self_test"]
    pub fn sha256_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sha512_context {
    pub total: [u64; 2usize],
    pub state: [u64; 8usize],
    pub buffer: [raw_types::c_uchar; 128usize],
    pub is384: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_sha512_context() {
    assert_eq!(
        ::core::mem::size_of::<sha512_context>(),
        216usize,
        concat!("Size of: ", stringify!(sha512_context))
    );
    assert_eq!(
        ::core::mem::align_of::<sha512_context>(),
        8usize,
        concat!("Alignment of ", stringify!(sha512_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha512_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha512_context>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha512_context>())).buffer as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<sha512_context>())).is384 as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(sha512_context),
            "::",
            stringify!(is384)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_sha512_init"]
    pub fn sha512_init(ctx: *mut sha512_context);
}
extern "C" {
    #[link_name = "mbedtls_sha512_free"]
    pub fn sha512_free(ctx: *mut sha512_context);
}
extern "C" {
    #[link_name = "mbedtls_sha512_clone"]
    pub fn sha512_clone(dst: *mut sha512_context, src: *const sha512_context);
}
extern "C" {
    #[link_name = "mbedtls_sha512_starts_ret"]
    pub fn sha512_starts_ret(ctx: *mut sha512_context, is384: raw_types::c_int)
        -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha512_update_ret"]
    pub fn sha512_update_ret(
        ctx: *mut sha512_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha512_finish_ret"]
    pub fn sha512_finish_ret(
        ctx: *mut sha512_context,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_internal_sha512_process"]
    pub fn internal_sha512_process(
        ctx: *mut sha512_context,
        data: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha512_starts"]
    pub fn sha512_starts(ctx: *mut sha512_context, is384: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_sha512_update"]
    pub fn sha512_update(ctx: *mut sha512_context, input: *const raw_types::c_uchar, ilen: usize);
}
extern "C" {
    #[link_name = "mbedtls_sha512_finish"]
    pub fn sha512_finish(ctx: *mut sha512_context, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_sha512_process"]
    pub fn sha512_process(ctx: *mut sha512_context, data: *const raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_sha512_ret"]
    pub fn sha512_ret(
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
        is384: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_sha512"]
    pub fn sha512(
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
        is384: raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "mbedtls_sha512_self_test"]
    pub fn sha512_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
pub const ECJPAKE_CLIENT: ecjpake_role = 0;
pub const ECJPAKE_SERVER: ecjpake_role = 1;
pub type ecjpake_role = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ecjpake_context {
    pub md_info: *const md_info_t,
    pub grp: ecp_group,
    pub role: ecjpake_role,
    pub point_format: raw_types::c_int,
    pub Xm1: ecp_point,
    pub Xm2: ecp_point,
    pub Xp1: ecp_point,
    pub Xp2: ecp_point,
    pub Xp: ecp_point,
    pub xm1: mpi,
    pub xm2: mpi,
    pub s: mpi,
}
#[test]
fn bindgen_test_layout_ecjpake_context() {
    assert_eq!(
        ::core::mem::size_of::<ecjpake_context>(),
        696usize,
        concat!("Size of: ", stringify!(ecjpake_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ecjpake_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ecjpake_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).md_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(md_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).grp as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(grp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).role as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).point_format as *const _ as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(point_format)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).Xm1 as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xm1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).Xm2 as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xm2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).Xp1 as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xp1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).Xp2 as *const _ as usize },
        480usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xp2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).Xp as *const _ as usize },
        552usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(Xp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).xm1 as *const _ as usize },
        624usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(xm1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).xm2 as *const _ as usize },
        648usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(xm2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ecjpake_context>())).s as *const _ as usize },
        672usize,
        concat!(
            "Offset of field: ",
            stringify!(ecjpake_context),
            "::",
            stringify!(s)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ecjpake_init"]
    pub fn ecjpake_init(ctx: *mut ecjpake_context);
}
extern "C" {
    #[link_name = "mbedtls_ecjpake_setup"]
    pub fn ecjpake_setup(
        ctx: *mut ecjpake_context,
        role: ecjpake_role,
        hash: md_type_t,
        curve: ecp_group_id,
        secret: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecjpake_check"]
    pub fn ecjpake_check(ctx: *const ecjpake_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecjpake_write_round_one"]
    pub fn ecjpake_write_round_one(
        ctx: *mut ecjpake_context,
        buf: *mut raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecjpake_read_round_one"]
    pub fn ecjpake_read_round_one(
        ctx: *mut ecjpake_context,
        buf: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecjpake_write_round_two"]
    pub fn ecjpake_write_round_two(
        ctx: *mut ecjpake_context,
        buf: *mut raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecjpake_read_round_two"]
    pub fn ecjpake_read_round_two(
        ctx: *mut ecjpake_context,
        buf: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecjpake_derive_secret"]
    pub fn ecjpake_derive_secret(
        ctx: *mut ecjpake_context,
        buf: *mut raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ecjpake_free"]
    pub fn ecjpake_free(ctx: *mut ecjpake_context);
}
extern "C" {
    #[link_name = "mbedtls_ecjpake_self_test"]
    pub fn ecjpake_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aes_context {
    pub nr: raw_types::c_int,
    pub rk: *mut u32,
    pub buf: [u32; 68usize],
}
#[test]
fn bindgen_test_layout_aes_context() {
    assert_eq!(
        ::core::mem::size_of::<aes_context>(),
        288usize,
        concat!("Size of: ", stringify!(aes_context))
    );
    assert_eq!(
        ::core::mem::align_of::<aes_context>(),
        8usize,
        concat!("Alignment of ", stringify!(aes_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_context>())).nr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_context),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_context>())).rk as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_context),
            "::",
            stringify!(rk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_context>())).buf as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_context),
            "::",
            stringify!(buf)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aes_xts_context {
    pub crypt: aes_context,
    pub tweak: aes_context,
}
#[test]
fn bindgen_test_layout_aes_xts_context() {
    assert_eq!(
        ::core::mem::size_of::<aes_xts_context>(),
        576usize,
        concat!("Size of: ", stringify!(aes_xts_context))
    );
    assert_eq!(
        ::core::mem::align_of::<aes_xts_context>(),
        8usize,
        concat!("Alignment of ", stringify!(aes_xts_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_xts_context>())).crypt as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_xts_context),
            "::",
            stringify!(crypt)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aes_xts_context>())).tweak as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(aes_xts_context),
            "::",
            stringify!(tweak)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_aes_init"]
    pub fn aes_init(ctx: *mut aes_context);
}
extern "C" {
    #[link_name = "mbedtls_aes_free"]
    pub fn aes_free(ctx: *mut aes_context);
}
extern "C" {
    #[link_name = "mbedtls_aes_xts_init"]
    pub fn aes_xts_init(ctx: *mut aes_xts_context);
}
extern "C" {
    #[link_name = "mbedtls_aes_xts_free"]
    pub fn aes_xts_free(ctx: *mut aes_xts_context);
}
extern "C" {
    #[link_name = "mbedtls_aes_setkey_enc"]
    pub fn aes_setkey_enc(
        ctx: *mut aes_context,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_setkey_dec"]
    pub fn aes_setkey_dec(
        ctx: *mut aes_context,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_xts_setkey_enc"]
    pub fn aes_xts_setkey_enc(
        ctx: *mut aes_xts_context,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_xts_setkey_dec"]
    pub fn aes_xts_setkey_dec(
        ctx: *mut aes_xts_context,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_crypt_ecb"]
    pub fn aes_crypt_ecb(
        ctx: *mut aes_context,
        mode: raw_types::c_int,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_crypt_cbc"]
    pub fn aes_crypt_cbc(
        ctx: *mut aes_context,
        mode: raw_types::c_int,
        length: usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_crypt_xts"]
    pub fn aes_crypt_xts(
        ctx: *mut aes_xts_context,
        mode: raw_types::c_int,
        length: usize,
        data_unit: *const raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_crypt_cfb128"]
    pub fn aes_crypt_cfb128(
        ctx: *mut aes_context,
        mode: raw_types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_crypt_cfb8"]
    pub fn aes_crypt_cfb8(
        ctx: *mut aes_context,
        mode: raw_types::c_int,
        length: usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_crypt_ofb"]
    pub fn aes_crypt_ofb(
        ctx: *mut aes_context,
        length: usize,
        iv_off: *mut usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_crypt_ctr"]
    pub fn aes_crypt_ctr(
        ctx: *mut aes_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut raw_types::c_uchar,
        stream_block: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_internal_aes_encrypt"]
    pub fn internal_aes_encrypt(
        ctx: *mut aes_context,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_internal_aes_decrypt"]
    pub fn internal_aes_decrypt(
        ctx: *mut aes_context,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_encrypt"]
    pub fn aes_encrypt(
        ctx: *mut aes_context,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "mbedtls_aes_decrypt"]
    pub fn aes_decrypt(
        ctx: *mut aes_context,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "mbedtls_aes_self_test"]
    pub fn aes_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct net_context {
    pub fd: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_net_context() {
    assert_eq!(
        ::core::mem::size_of::<net_context>(),
        4usize,
        concat!("Size of: ", stringify!(net_context))
    );
    assert_eq!(
        ::core::mem::align_of::<net_context>(),
        4usize,
        concat!("Alignment of ", stringify!(net_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<net_context>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(net_context),
            "::",
            stringify!(fd)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_net_init"]
    pub fn net_init(ctx: *mut net_context);
}
extern "C" {
    #[link_name = "mbedtls_net_connect"]
    pub fn net_connect(
        ctx: *mut net_context,
        host: *const raw_types::c_char,
        port: *const raw_types::c_char,
        proto: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_net_bind"]
    pub fn net_bind(
        ctx: *mut net_context,
        bind_ip: *const raw_types::c_char,
        port: *const raw_types::c_char,
        proto: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_net_accept"]
    pub fn net_accept(
        bind_ctx: *mut net_context,
        client_ctx: *mut net_context,
        client_ip: *mut raw_types::c_void,
        buf_size: usize,
        ip_len: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_net_poll"]
    pub fn net_poll(ctx: *mut net_context, rw: u32, timeout: u32) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_net_set_block"]
    pub fn net_set_block(ctx: *mut net_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_net_set_nonblock"]
    pub fn net_set_nonblock(ctx: *mut net_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_net_usleep"]
    pub fn net_usleep(usec: raw_types::c_ulong);
}
extern "C" {
    #[link_name = "mbedtls_net_recv"]
    pub fn net_recv(
        ctx: *mut raw_types::c_void,
        buf: *mut raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_net_send"]
    pub fn net_send(
        ctx: *mut raw_types::c_void,
        buf: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_net_recv_timeout"]
    pub fn net_recv_timeout(
        ctx: *mut raw_types::c_void,
        buf: *mut raw_types::c_uchar,
        len: usize,
        timeout: u32,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_net_free"]
    pub fn net_free(ctx: *mut net_context);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct havege_state {
    pub PT1: raw_types::c_int,
    pub PT2: raw_types::c_int,
    pub offset: [raw_types::c_int; 2usize],
    pub pool: [raw_types::c_int; 1024usize],
    pub WALK: [raw_types::c_int; 8192usize],
}
#[test]
fn bindgen_test_layout_havege_state() {
    assert_eq!(
        ::core::mem::size_of::<havege_state>(),
        36880usize,
        concat!("Size of: ", stringify!(havege_state))
    );
    assert_eq!(
        ::core::mem::align_of::<havege_state>(),
        4usize,
        concat!("Alignment of ", stringify!(havege_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<havege_state>())).PT1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(havege_state),
            "::",
            stringify!(PT1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<havege_state>())).PT2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(havege_state),
            "::",
            stringify!(PT2)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<havege_state>())).offset as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(havege_state),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<havege_state>())).pool as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(havege_state),
            "::",
            stringify!(pool)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<havege_state>())).WALK as *const _ as usize },
        4112usize,
        concat!(
            "Offset of field: ",
            stringify!(havege_state),
            "::",
            stringify!(WALK)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_havege_init"]
    pub fn havege_init(hs: *mut havege_state);
}
extern "C" {
    #[link_name = "mbedtls_havege_free"]
    pub fn havege_free(hs: *mut havege_state);
}
extern "C" {
    #[link_name = "mbedtls_havege_random"]
    pub fn havege_random(
        p_rng: *mut raw_types::c_void,
        output: *mut raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct poly1305_context {
    pub r: [u32; 4usize],
    pub s: [u32; 4usize],
    pub acc: [u32; 5usize],
    pub queue: [u8; 16usize],
    pub queue_len: usize,
}
#[test]
fn bindgen_test_layout_poly1305_context() {
    assert_eq!(
        ::core::mem::size_of::<poly1305_context>(),
        80usize,
        concat!("Size of: ", stringify!(poly1305_context))
    );
    assert_eq!(
        ::core::mem::align_of::<poly1305_context>(),
        8usize,
        concat!("Alignment of ", stringify!(poly1305_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poly1305_context>())).r as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(r)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poly1305_context>())).s as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(s)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poly1305_context>())).acc as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(acc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poly1305_context>())).queue as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(queue)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<poly1305_context>())).queue_len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(poly1305_context),
            "::",
            stringify!(queue_len)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_poly1305_init"]
    pub fn poly1305_init(ctx: *mut poly1305_context);
}
extern "C" {
    #[link_name = "mbedtls_poly1305_free"]
    pub fn poly1305_free(ctx: *mut poly1305_context);
}
extern "C" {
    #[link_name = "mbedtls_poly1305_starts"]
    pub fn poly1305_starts(
        ctx: *mut poly1305_context,
        key: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_poly1305_update"]
    pub fn poly1305_update(
        ctx: *mut poly1305_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_poly1305_finish"]
    pub fn poly1305_finish(
        ctx: *mut poly1305_context,
        mac: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_poly1305_mac"]
    pub fn poly1305_mac(
        key: *const raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        ilen: usize,
        mac: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_poly1305_self_test"]
    pub fn poly1305_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct chacha20_context {
    pub state: [u32; 16usize],
    pub keystream8: [u8; 64usize],
    pub keystream_bytes_used: usize,
}
#[test]
fn bindgen_test_layout_chacha20_context() {
    assert_eq!(
        ::core::mem::size_of::<chacha20_context>(),
        136usize,
        concat!("Size of: ", stringify!(chacha20_context))
    );
    assert_eq!(
        ::core::mem::align_of::<chacha20_context>(),
        8usize,
        concat!("Alignment of ", stringify!(chacha20_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<chacha20_context>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(chacha20_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<chacha20_context>())).keystream8 as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(chacha20_context),
            "::",
            stringify!(keystream8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<chacha20_context>())).keystream_bytes_used as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(chacha20_context),
            "::",
            stringify!(keystream_bytes_used)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_chacha20_init"]
    pub fn chacha20_init(ctx: *mut chacha20_context);
}
extern "C" {
    #[link_name = "mbedtls_chacha20_free"]
    pub fn chacha20_free(ctx: *mut chacha20_context);
}
extern "C" {
    #[link_name = "mbedtls_chacha20_setkey"]
    pub fn chacha20_setkey(
        ctx: *mut chacha20_context,
        key: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chacha20_starts"]
    pub fn chacha20_starts(
        ctx: *mut chacha20_context,
        nonce: *const raw_types::c_uchar,
        counter: u32,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chacha20_update"]
    pub fn chacha20_update(
        ctx: *mut chacha20_context,
        size: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chacha20_crypt"]
    pub fn chacha20_crypt(
        key: *const raw_types::c_uchar,
        nonce: *const raw_types::c_uchar,
        counter: u32,
        size: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chacha20_self_test"]
    pub fn chacha20_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct xtea_context {
    pub k: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_xtea_context() {
    assert_eq!(
        ::core::mem::size_of::<xtea_context>(),
        16usize,
        concat!("Size of: ", stringify!(xtea_context))
    );
    assert_eq!(
        ::core::mem::align_of::<xtea_context>(),
        4usize,
        concat!("Alignment of ", stringify!(xtea_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<xtea_context>())).k as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(xtea_context),
            "::",
            stringify!(k)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_xtea_init"]
    pub fn xtea_init(ctx: *mut xtea_context);
}
extern "C" {
    #[link_name = "mbedtls_xtea_free"]
    pub fn xtea_free(ctx: *mut xtea_context);
}
extern "C" {
    #[link_name = "mbedtls_xtea_setup"]
    pub fn xtea_setup(ctx: *mut xtea_context, key: *const raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_xtea_crypt_ecb"]
    pub fn xtea_crypt_ecb(
        ctx: *mut xtea_context,
        mode: raw_types::c_int,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_xtea_crypt_cbc"]
    pub fn xtea_crypt_cbc(
        ctx: *mut xtea_context,
        mode: raw_types::c_int,
        length: usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_xtea_self_test"]
    pub fn xtea_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509_csr {
    pub raw: x509_buf,
    pub cri: x509_buf,
    pub version: raw_types::c_int,
    pub subject_raw: x509_buf,
    pub subject: x509_name,
    pub pk: pk_context,
    pub sig_oid: x509_buf,
    pub sig: x509_buf,
    pub sig_md: md_type_t,
    pub sig_pk: pk_type_t,
    pub sig_opts: *mut raw_types::c_void,
}
#[test]
fn bindgen_test_layout_x509_csr() {
    assert_eq!(
        ::core::mem::size_of::<x509_csr>(),
        224usize,
        concat!("Size of: ", stringify!(x509_csr))
    );
    assert_eq!(
        ::core::mem::align_of::<x509_csr>(),
        8usize,
        concat!("Alignment of ", stringify!(x509_csr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).cri as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(cri)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).version as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).subject_raw as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(subject_raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).subject as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).pk as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(pk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).sig_oid as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_oid)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).sig as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).sig_md as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_md)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).sig_pk as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_pk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509_csr>())).sig_opts as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(x509_csr),
            "::",
            stringify!(sig_opts)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct x509write_csr {
    pub key: *mut pk_context,
    pub subject: *mut asn1_named_data,
    pub md_alg: md_type_t,
    pub extensions: *mut asn1_named_data,
}
#[test]
fn bindgen_test_layout_x509write_csr() {
    assert_eq!(
        ::core::mem::size_of::<x509write_csr>(),
        32usize,
        concat!("Size of: ", stringify!(x509write_csr))
    );
    assert_eq!(
        ::core::mem::align_of::<x509write_csr>(),
        8usize,
        concat!("Alignment of ", stringify!(x509write_csr))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_csr>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_csr>())).subject as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(subject)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_csr>())).md_alg as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(md_alg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<x509write_csr>())).extensions as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(x509write_csr),
            "::",
            stringify!(extensions)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_x509_csr_parse_der"]
    pub fn x509_csr_parse_der(
        csr: *mut x509_csr,
        buf: *const raw_types::c_uchar,
        buflen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_csr_parse"]
    pub fn x509_csr_parse(
        csr: *mut x509_csr,
        buf: *const raw_types::c_uchar,
        buflen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_csr_parse_file"]
    pub fn x509_csr_parse_file(
        csr: *mut x509_csr,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_csr_info"]
    pub fn x509_csr_info(
        buf: *mut raw_types::c_char,
        size: usize,
        prefix: *const raw_types::c_char,
        csr: *const x509_csr,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509_csr_init"]
    pub fn x509_csr_init(csr: *mut x509_csr);
}
extern "C" {
    #[link_name = "mbedtls_x509_csr_free"]
    pub fn x509_csr_free(csr: *mut x509_csr);
}
extern "C" {
    #[link_name = "mbedtls_x509write_csr_init"]
    pub fn x509write_csr_init(ctx: *mut x509write_csr);
}
extern "C" {
    #[link_name = "mbedtls_x509write_csr_set_subject_name"]
    pub fn x509write_csr_set_subject_name(
        ctx: *mut x509write_csr,
        subject_name: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_csr_set_key"]
    pub fn x509write_csr_set_key(ctx: *mut x509write_csr, key: *mut pk_context);
}
extern "C" {
    #[link_name = "mbedtls_x509write_csr_set_md_alg"]
    pub fn x509write_csr_set_md_alg(ctx: *mut x509write_csr, md_alg: md_type_t);
}
extern "C" {
    #[link_name = "mbedtls_x509write_csr_set_key_usage"]
    pub fn x509write_csr_set_key_usage(
        ctx: *mut x509write_csr,
        key_usage: raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_csr_set_ns_cert_type"]
    pub fn x509write_csr_set_ns_cert_type(
        ctx: *mut x509write_csr,
        ns_cert_type: raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_csr_set_extension"]
    pub fn x509write_csr_set_extension(
        ctx: *mut x509write_csr,
        oid: *const raw_types::c_char,
        oid_len: usize,
        val: *const raw_types::c_uchar,
        val_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_csr_free"]
    pub fn x509write_csr_free(ctx: *mut x509write_csr);
}
extern "C" {
    #[link_name = "mbedtls_x509write_csr_der"]
    pub fn x509write_csr_der(
        ctx: *mut x509write_csr,
        buf: *mut raw_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_x509write_csr_pem"]
    pub fn x509write_csr_pem(
        ctx: *mut x509write_csr,
        buf: *mut raw_types::c_uchar,
        size: usize,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_version_get_number"]
    pub fn version_get_number() -> raw_types::c_uint;
}
extern "C" {
    #[link_name = "mbedtls_version_get_string"]
    pub fn version_get_string(string: *mut raw_types::c_char);
}
extern "C" {
    #[link_name = "mbedtls_version_get_string_full"]
    pub fn version_get_string_full(string: *mut raw_types::c_char);
}
extern "C" {
    #[link_name = "mbedtls_version_check_feature"]
    pub fn version_check_feature(feature: *const raw_types::c_char) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timing_hr_time {
    pub opaque: [raw_types::c_uchar; 32usize],
}
#[test]
fn bindgen_test_layout_timing_hr_time() {
    assert_eq!(
        ::core::mem::size_of::<timing_hr_time>(),
        32usize,
        concat!("Size of: ", stringify!(timing_hr_time))
    );
    assert_eq!(
        ::core::mem::align_of::<timing_hr_time>(),
        1usize,
        concat!("Alignment of ", stringify!(timing_hr_time))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timing_hr_time>())).opaque as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timing_hr_time),
            "::",
            stringify!(opaque)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct timing_delay_context {
    pub timer: timing_hr_time,
    pub int_ms: u32,
    pub fin_ms: u32,
}
#[test]
fn bindgen_test_layout_timing_delay_context() {
    assert_eq!(
        ::core::mem::size_of::<timing_delay_context>(),
        40usize,
        concat!("Size of: ", stringify!(timing_delay_context))
    );
    assert_eq!(
        ::core::mem::align_of::<timing_delay_context>(),
        4usize,
        concat!("Alignment of ", stringify!(timing_delay_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timing_delay_context>())).timer as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timing_delay_context),
            "::",
            stringify!(timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timing_delay_context>())).int_ms as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(timing_delay_context),
            "::",
            stringify!(int_ms)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<timing_delay_context>())).fin_ms as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(timing_delay_context),
            "::",
            stringify!(fin_ms)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_timing_alarmed"]
    pub static mut timing_alarmed: raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_timing_hardclock"]
    pub fn timing_hardclock() -> raw_types::c_ulong;
}
extern "C" {
    #[link_name = "mbedtls_timing_get_timer"]
    pub fn timing_get_timer(
        val: *mut timing_hr_time,
        reset: raw_types::c_int,
    ) -> raw_types::c_ulong;
}
extern "C" {
    #[link_name = "mbedtls_set_alarm"]
    pub fn set_alarm(seconds: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_timing_set_delay"]
    pub fn timing_set_delay(data: *mut raw_types::c_void, int_ms: u32, fin_ms: u32);
}
extern "C" {
    #[link_name = "mbedtls_timing_get_delay"]
    pub fn timing_get_delay(data: *mut raw_types::c_void) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_timing_self_test"]
    pub fn timing_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_ticket_key {
    pub name: [raw_types::c_uchar; 4usize],
    pub generation_time: u32,
    pub ctx: cipher_context_t,
}
#[test]
fn bindgen_test_layout_ssl_ticket_key() {
    assert_eq!(
        ::core::mem::size_of::<ssl_ticket_key>(),
        96usize,
        concat!("Size of: ", stringify!(ssl_ticket_key))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_ticket_key>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_ticket_key))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_key>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_key),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_key>())).generation_time as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_key),
            "::",
            stringify!(generation_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_key>())).ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_key),
            "::",
            stringify!(ctx)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_ticket_context {
    pub keys: [ssl_ticket_key; 2usize],
    pub active: raw_types::c_uchar,
    pub ticket_lifetime: u32,
    pub f_rng: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *mut raw_types::c_uchar,
            arg3: usize,
        ) -> raw_types::c_int,
    >,
    pub p_rng: *mut raw_types::c_void,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_ssl_ticket_context() {
    assert_eq!(
        ::core::mem::size_of::<ssl_ticket_context>(),
        264usize,
        concat!("Size of: ", stringify!(ssl_ticket_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_ticket_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_ticket_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_context>())).keys as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(keys)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_context>())).active as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(active)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_ticket_context>())).ticket_lifetime as *const _ as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(ticket_lifetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_context>())).f_rng as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(f_rng)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_context>())).p_rng as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(p_rng)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_ticket_context>())).mutex as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_ticket_context),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_ticket_init"]
    pub fn ssl_ticket_init(ctx: *mut ssl_ticket_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_ticket_setup"]
    pub fn ssl_ticket_setup(
        ctx: *mut ssl_ticket_context,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
        cipher: cipher_type_t,
        lifetime: u32,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_ticket_write"]
    pub fn ssl_ticket_write(
        p_ticket: *mut raw_types::c_void,
        session: *const ssl_session,
        start: *mut raw_types::c_uchar,
        end: *const raw_types::c_uchar,
        tlen: *mut usize,
        lifetime: *mut u32,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_ticket_parse"]
    pub fn ssl_ticket_parse(
        p_ticket: *mut raw_types::c_void,
        session: *mut ssl_session,
        buf: *mut raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_ticket_free"]
    pub fn ssl_ticket_free(ctx: *mut ssl_ticket_context);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_sig_hash_set_t {
    pub rsa: md_type_t,
    pub ecdsa: md_type_t,
}
#[test]
fn bindgen_test_layout_ssl_sig_hash_set_t() {
    assert_eq!(
        ::core::mem::size_of::<ssl_sig_hash_set_t>(),
        8usize,
        concat!("Size of: ", stringify!(ssl_sig_hash_set_t))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_sig_hash_set_t>(),
        4usize,
        concat!("Alignment of ", stringify!(ssl_sig_hash_set_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_sig_hash_set_t>())).rsa as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_sig_hash_set_t),
            "::",
            stringify!(rsa)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_sig_hash_set_t>())).ecdsa as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_sig_hash_set_t),
            "::",
            stringify!(ecdsa)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_handshake_params {
    pub hash_algs: ssl_sig_hash_set_t,
    pub dhm_ctx: dhm_context,
    pub ecdh_ctx: ecdh_context,
    pub curves: *mut *const ecp_curve_info,
    pub psk: *mut raw_types::c_uchar,
    pub psk_len: usize,
    pub key_cert: *mut ssl_key_cert,
    pub sni_authmode: raw_types::c_int,
    pub sni_key_cert: *mut ssl_key_cert,
    pub sni_ca_chain: *mut x509_crt,
    pub sni_ca_crl: *mut x509_crl,
    pub out_msg_seq: raw_types::c_uint,
    pub in_msg_seq: raw_types::c_uint,
    pub verify_cookie: *mut raw_types::c_uchar,
    pub verify_cookie_len: raw_types::c_uchar,
    pub retransmit_timeout: u32,
    pub retransmit_state: raw_types::c_uchar,
    pub flight: *mut ssl_flight_item,
    pub cur_msg: *mut ssl_flight_item,
    pub cur_msg_p: *mut raw_types::c_uchar,
    pub in_flight_start_seq: raw_types::c_uint,
    pub alt_transform_out: *mut ssl_transform,
    pub alt_out_ctr: [raw_types::c_uchar; 8usize],
    pub buffering: ssl_handshake_params__bindgen_ty_1,
    pub mtu: u16,
    pub fin_md5: md5_context,
    pub fin_sha1: sha1_context,
    pub fin_sha256: sha256_context,
    pub fin_sha512: sha512_context,
    pub update_checksum: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ssl_context, arg2: *const raw_types::c_uchar, arg3: usize),
    >,
    pub calc_verify: ::core::option::Option<
        unsafe extern "C" fn(arg1: *mut ssl_context, arg2: *mut raw_types::c_uchar),
    >,
    pub calc_finished: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ssl_context,
            arg2: *mut raw_types::c_uchar,
            arg3: raw_types::c_int,
        ),
    >,
    pub tls_prf: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *const raw_types::c_uchar,
            arg2: usize,
            arg3: *const raw_types::c_char,
            arg4: *const raw_types::c_uchar,
            arg5: usize,
            arg6: *mut raw_types::c_uchar,
            arg7: usize,
        ) -> raw_types::c_int,
    >,
    pub pmslen: usize,
    pub randbytes: [raw_types::c_uchar; 64usize],
    pub premaster: [raw_types::c_uchar; 1060usize],
    pub resume: raw_types::c_int,
    pub max_major_ver: raw_types::c_int,
    pub max_minor_ver: raw_types::c_int,
    pub cli_exts: raw_types::c_int,
    pub new_session_ticket: raw_types::c_int,
    pub extended_ms: raw_types::c_int,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_handshake_params__bindgen_ty_1 {
    pub total_bytes_buffered: usize,
    pub seen_ccs: u8,
    pub hs: [ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer; 4usize],
    pub future_record: ssl_handshake_params__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 1usize], u8>,
    pub data: *mut raw_types::c_uchar,
    pub data_len: usize,
}
#[test]
fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer() {
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer>()))
                .data as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer>()))
                .data_len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer),
            "::",
            stringify!(data_len)
        )
    );
}
impl ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer {
    #[inline]
    pub fn is_valid(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(0usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_valid(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(0usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_fragmented(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(1usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_fragmented(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(1usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn is_complete(&self) -> raw_types::c_uint {
        unsafe { ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_is_complete(&mut self, val: raw_types::c_uint) {
        unsafe {
            let val: u32 = ::core::mem::transmute(val);
            self._bitfield_1.set(2usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        is_valid: raw_types::c_uint,
        is_fragmented: raw_types::c_uint,
        is_complete: raw_types::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 1usize], u8> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 1usize], u8> =
            Default::default();
        __bindgen_bitfield_unit.set(0usize, 1u8, {
            let is_valid: u32 = unsafe { ::core::mem::transmute(is_valid) };
            is_valid as u64
        });
        __bindgen_bitfield_unit.set(1usize, 1u8, {
            let is_fragmented: u32 = unsafe { ::core::mem::transmute(is_fragmented) };
            is_fragmented as u64
        });
        __bindgen_bitfield_unit.set(2usize, 1u8, {
            let is_complete: u32 = unsafe { ::core::mem::transmute(is_complete) };
            is_complete as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_handshake_params__bindgen_ty_1__bindgen_ty_1 {
    pub data: *mut raw_types::c_uchar,
    pub len: usize,
    pub epoch: raw_types::c_uint,
}
#[test]
fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>(),
        24usize,
        concat!(
            "Size of: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>())).data
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>())).len
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1__bindgen_ty_1>())).epoch
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(epoch)
        )
    );
}
#[test]
fn bindgen_test_layout_ssl_handshake_params__bindgen_ty_1() {
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params__bindgen_ty_1>(),
        136usize,
        concat!("Size of: ", stringify!(ssl_handshake_params__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ssl_handshake_params__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1>())).total_bytes_buffered
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(total_bytes_buffered)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1>())).seen_ccs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(seen_ccs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1>())).hs as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(hs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params__bindgen_ty_1>())).future_record
                as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params__bindgen_ty_1),
            "::",
            stringify!(future_record)
        )
    );
}
#[test]
fn bindgen_test_layout_ssl_handshake_params() {
    assert_eq!(
        ::core::mem::size_of::<ssl_handshake_params>(),
        2856usize,
        concat!("Size of: ", stringify!(ssl_handshake_params))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_handshake_params>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_handshake_params))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).hash_algs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(hash_algs)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).dhm_ctx as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(dhm_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).ecdh_ctx as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(ecdh_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).curves as *const _ as usize },
        872usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(curves)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).psk as *const _ as usize },
        880usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(psk)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).psk_len as *const _ as usize },
        888usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(psk_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).key_cert as *const _ as usize },
        896usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(key_cert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).sni_authmode as *const _ as usize
        },
        904usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_authmode)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).sni_key_cert as *const _ as usize
        },
        912usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_key_cert)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).sni_ca_chain as *const _ as usize
        },
        920usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_ca_chain)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).sni_ca_crl as *const _ as usize
        },
        928usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(sni_ca_crl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).out_msg_seq as *const _ as usize
        },
        936usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(out_msg_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).in_msg_seq as *const _ as usize
        },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(in_msg_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).verify_cookie as *const _ as usize
        },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(verify_cookie)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).verify_cookie_len as *const _ as usize
        },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(verify_cookie_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).retransmit_timeout as *const _
                as usize
        },
        956usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(retransmit_timeout)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).retransmit_state as *const _ as usize
        },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(retransmit_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).flight as *const _ as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(flight)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).cur_msg as *const _ as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(cur_msg)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).cur_msg_p as *const _ as usize },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(cur_msg_p)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).in_flight_start_seq as *const _
                as usize
        },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(in_flight_start_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).alt_transform_out as *const _ as usize
        },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(alt_transform_out)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).alt_out_ctr as *const _ as usize
        },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(alt_out_ctr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).buffering as *const _ as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(buffering)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).mtu as *const _ as usize },
        1152usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).fin_md5 as *const _ as usize },
        1156usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(fin_md5)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).fin_sha1 as *const _ as usize },
        1244usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(fin_sha1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).fin_sha256 as *const _ as usize
        },
        1336usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(fin_sha256)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).fin_sha512 as *const _ as usize
        },
        1448usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(fin_sha512)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).update_checksum as *const _ as usize
        },
        1664usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(update_checksum)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).calc_verify as *const _ as usize
        },
        1672usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(calc_verify)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).calc_finished as *const _ as usize
        },
        1680usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(calc_finished)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).tls_prf as *const _ as usize },
        1688usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(tls_prf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).pmslen as *const _ as usize },
        1696usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(pmslen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).randbytes as *const _ as usize },
        1704usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(randbytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).premaster as *const _ as usize },
        1768usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(premaster)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).resume as *const _ as usize },
        2828usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(resume)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).max_major_ver as *const _ as usize
        },
        2832usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(max_major_ver)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).max_minor_ver as *const _ as usize
        },
        2836usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(max_minor_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_handshake_params>())).cli_exts as *const _ as usize },
        2840usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(cli_exts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).new_session_ticket as *const _
                as usize
        },
        2844usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(new_session_ticket)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ssl_handshake_params>())).extended_ms as *const _ as usize
        },
        2848usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_handshake_params),
            "::",
            stringify!(extended_ms)
        )
    );
}
pub type ssl_hs_buffer = ssl_handshake_params__bindgen_ty_1_mbedtls_ssl_hs_buffer;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_transform {
    pub ciphersuite_info: *const ssl_ciphersuite_t,
    pub keylen: raw_types::c_uint,
    pub minlen: usize,
    pub ivlen: usize,
    pub fixed_ivlen: usize,
    pub maclen: usize,
    pub iv_enc: [raw_types::c_uchar; 16usize],
    pub iv_dec: [raw_types::c_uchar; 16usize],
    pub mac_enc: [raw_types::c_uchar; 20usize],
    pub mac_dec: [raw_types::c_uchar; 20usize],
    pub md_ctx_enc: md_context_t,
    pub md_ctx_dec: md_context_t,
    pub cipher_ctx_enc: cipher_context_t,
    pub cipher_ctx_dec: cipher_context_t,
    pub ctx_deflate: z_stream,
    pub ctx_inflate: z_stream,
}
#[test]
fn bindgen_test_layout_ssl_transform() {
    assert_eq!(
        ::core::mem::size_of::<ssl_transform>(),
        568usize,
        concat!("Size of: ", stringify!(ssl_transform))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_transform>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_transform))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).ciphersuite_info as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(ciphersuite_info)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).keylen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(keylen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).minlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(minlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).ivlen as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(ivlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).fixed_ivlen as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(fixed_ivlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).maclen as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(maclen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).iv_enc as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(iv_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).iv_dec as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(iv_dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).mac_enc as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(mac_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).mac_dec as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(mac_dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).md_ctx_enc as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(md_ctx_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).md_ctx_dec as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(md_ctx_dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).cipher_ctx_enc as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(cipher_ctx_enc)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).cipher_ctx_dec as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(cipher_ctx_dec)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).ctx_deflate as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(ctx_deflate)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_transform>())).ctx_inflate as *const _ as usize },
        456usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_transform),
            "::",
            stringify!(ctx_inflate)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_key_cert {
    pub cert: *mut x509_crt,
    pub key: *mut pk_context,
    pub next: *mut ssl_key_cert,
}
#[test]
fn bindgen_test_layout_ssl_key_cert() {
    assert_eq!(
        ::core::mem::size_of::<ssl_key_cert>(),
        24usize,
        concat!("Size of: ", stringify!(ssl_key_cert))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_key_cert>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_key_cert))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_key_cert>())).cert as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_cert),
            "::",
            stringify!(cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_key_cert>())).key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_cert),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_key_cert>())).next as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_key_cert),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_flight_item {
    pub p: *mut raw_types::c_uchar,
    pub len: usize,
    pub type_: raw_types::c_uchar,
    pub next: *mut ssl_flight_item,
}
#[test]
fn bindgen_test_layout_ssl_flight_item() {
    assert_eq!(
        ::core::mem::size_of::<ssl_flight_item>(),
        32usize,
        concat!("Size of: ", stringify!(ssl_flight_item))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_flight_item>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_flight_item))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_flight_item>())).p as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_flight_item>())).len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_flight_item>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_flight_item>())).next as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_flight_item),
            "::",
            stringify!(next)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_sig_hash_set_find"]
    pub fn ssl_sig_hash_set_find(set: *mut ssl_sig_hash_set_t, sig_alg: pk_type_t) -> md_type_t;
}
extern "C" {
    #[link_name = "mbedtls_ssl_sig_hash_set_add"]
    pub fn ssl_sig_hash_set_add(
        set: *mut ssl_sig_hash_set_t,
        sig_alg: pk_type_t,
        md_alg: md_type_t,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_sig_hash_set_const_hash"]
    pub fn ssl_sig_hash_set_const_hash(set: *mut ssl_sig_hash_set_t, md_alg: md_type_t);
}
extern "C" {
    #[link_name = "mbedtls_ssl_transform_free"]
    pub fn ssl_transform_free(transform: *mut ssl_transform);
}
extern "C" {
    #[link_name = "mbedtls_ssl_handshake_free"]
    pub fn ssl_handshake_free(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_handshake_client_step"]
    pub fn ssl_handshake_client_step(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_handshake_server_step"]
    pub fn ssl_handshake_server_step(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_handshake_wrapup"]
    pub fn ssl_handshake_wrapup(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_send_fatal_handshake_failure"]
    pub fn ssl_send_fatal_handshake_failure(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_reset_checksum"]
    pub fn ssl_reset_checksum(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_derive_keys"]
    pub fn ssl_derive_keys(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_handle_message_type"]
    pub fn ssl_handle_message_type(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_prepare_handshake_record"]
    pub fn ssl_prepare_handshake_record(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_update_handshake_status"]
    pub fn ssl_update_handshake_status(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_read_record"]
    pub fn ssl_read_record(
        ssl: *mut ssl_context,
        update_hs_digest: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_fetch_input"]
    pub fn ssl_fetch_input(ssl: *mut ssl_context, nb_want: usize) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_write_handshake_msg"]
    pub fn ssl_write_handshake_msg(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_write_record"]
    pub fn ssl_write_record(ssl: *mut ssl_context, force_flush: u8) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_flush_output"]
    pub fn ssl_flush_output(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_parse_certificate"]
    pub fn ssl_parse_certificate(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_write_certificate"]
    pub fn ssl_write_certificate(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_parse_change_cipher_spec"]
    pub fn ssl_parse_change_cipher_spec(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_write_change_cipher_spec"]
    pub fn ssl_write_change_cipher_spec(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_parse_finished"]
    pub fn ssl_parse_finished(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_write_finished"]
    pub fn ssl_write_finished(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_optimize_checksum"]
    pub fn ssl_optimize_checksum(ssl: *mut ssl_context, ciphersuite_info: *const ssl_ciphersuite_t);
}
extern "C" {
    #[link_name = "mbedtls_ssl_psk_derive_premaster"]
    pub fn ssl_psk_derive_premaster(
        ssl: *mut ssl_context,
        key_ex: key_exchange_type_t,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_sig_from_pk"]
    pub fn ssl_sig_from_pk(pk: *mut pk_context) -> raw_types::c_uchar;
}
extern "C" {
    #[link_name = "mbedtls_ssl_sig_from_pk_alg"]
    pub fn ssl_sig_from_pk_alg(type_: pk_type_t) -> raw_types::c_uchar;
}
extern "C" {
    #[link_name = "mbedtls_ssl_pk_alg_from_sig"]
    pub fn ssl_pk_alg_from_sig(sig: raw_types::c_uchar) -> pk_type_t;
}
extern "C" {
    #[link_name = "mbedtls_ssl_md_alg_from_hash"]
    pub fn ssl_md_alg_from_hash(hash: raw_types::c_uchar) -> md_type_t;
}
extern "C" {
    #[link_name = "mbedtls_ssl_hash_from_md_alg"]
    pub fn ssl_hash_from_md_alg(md: raw_types::c_int) -> raw_types::c_uchar;
}
extern "C" {
    #[link_name = "mbedtls_ssl_set_calc_verify_md"]
    pub fn ssl_set_calc_verify_md(ssl: *mut ssl_context, md: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_check_curve"]
    pub fn ssl_check_curve(ssl: *const ssl_context, grp_id: ecp_group_id) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_check_sig_hash"]
    pub fn ssl_check_sig_hash(ssl: *const ssl_context, md: md_type_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_check_cert_usage"]
    pub fn ssl_check_cert_usage(
        cert: *const x509_crt,
        ciphersuite: *const ssl_ciphersuite_t,
        cert_endpoint: raw_types::c_int,
        flags: *mut u32,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_write_version"]
    pub fn ssl_write_version(
        major: raw_types::c_int,
        minor: raw_types::c_int,
        transport: raw_types::c_int,
        ver: *mut raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_read_version"]
    pub fn ssl_read_version(
        major: *mut raw_types::c_int,
        minor: *mut raw_types::c_int,
        transport: raw_types::c_int,
        ver: *const raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_send_flight_completed"]
    pub fn ssl_send_flight_completed(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_recv_flight_completed"]
    pub fn ssl_recv_flight_completed(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_resend"]
    pub fn ssl_resend(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_flight_transmit"]
    pub fn ssl_flight_transmit(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_dtls_replay_check"]
    pub fn ssl_dtls_replay_check(ssl: *mut ssl_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_dtls_replay_update"]
    pub fn ssl_dtls_replay_update(ssl: *mut ssl_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_key_exchange_md_ssl_tls"]
    pub fn ssl_get_key_exchange_md_ssl_tls(
        ssl: *mut ssl_context,
        output: *mut raw_types::c_uchar,
        data: *mut raw_types::c_uchar,
        data_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_get_key_exchange_md_tls1_2"]
    pub fn ssl_get_key_exchange_md_tls1_2(
        ssl: *mut ssl_context,
        hash: *mut raw_types::c_uchar,
        hashlen: *mut usize,
        data: *mut raw_types::c_uchar,
        data_len: usize,
        md_alg: md_type_t,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_cookie_ctx {
    pub hmac_ctx: md_context_t,
    pub timeout: raw_types::c_ulong,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_ssl_cookie_ctx() {
    assert_eq!(
        ::core::mem::size_of::<ssl_cookie_ctx>(),
        80usize,
        concat!("Size of: ", stringify!(ssl_cookie_ctx))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_cookie_ctx>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_cookie_ctx))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cookie_ctx>())).hmac_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cookie_ctx),
            "::",
            stringify!(hmac_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cookie_ctx>())).timeout as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cookie_ctx),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cookie_ctx>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cookie_ctx),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_cookie_init"]
    pub fn ssl_cookie_init(ctx: *mut ssl_cookie_ctx);
}
extern "C" {
    #[link_name = "mbedtls_ssl_cookie_setup"]
    pub fn ssl_cookie_setup(
        ctx: *mut ssl_cookie_ctx,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_cookie_set_timeout"]
    pub fn ssl_cookie_set_timeout(ctx: *mut ssl_cookie_ctx, delay: raw_types::c_ulong);
}
extern "C" {
    #[link_name = "mbedtls_ssl_cookie_free"]
    pub fn ssl_cookie_free(ctx: *mut ssl_cookie_ctx);
}
extern "C" {
    #[link_name = "mbedtls_ssl_cookie_write"]
    pub fn ssl_cookie_write(
        ctx: *mut raw_types::c_void,
        p: *mut *mut raw_types::c_uchar,
        end: *mut raw_types::c_uchar,
        info: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_cookie_check"]
    pub fn ssl_cookie_check(
        ctx: *mut raw_types::c_void,
        cookie: *const raw_types::c_uchar,
        clen: usize,
        info: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_cache_entry {
    pub timestamp: mbedtls_time_t,
    pub session: ssl_session,
    pub peer_cert: x509_buf,
    pub next: *mut ssl_cache_entry,
}
#[test]
fn bindgen_test_layout_ssl_cache_entry() {
    assert_eq!(
        ::core::mem::size_of::<ssl_cache_entry>(),
        192usize,
        concat!("Size of: ", stringify!(ssl_cache_entry))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_cache_entry>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_cache_entry))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cache_entry>())).timestamp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_entry),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cache_entry>())).session as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_entry),
            "::",
            stringify!(session)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cache_entry>())).peer_cert as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_entry),
            "::",
            stringify!(peer_cert)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cache_entry>())).next as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_entry),
            "::",
            stringify!(next)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ssl_cache_context {
    pub chain: *mut ssl_cache_entry,
    pub timeout: raw_types::c_int,
    pub max_entries: raw_types::c_int,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_ssl_cache_context() {
    assert_eq!(
        ::core::mem::size_of::<ssl_cache_context>(),
        64usize,
        concat!("Size of: ", stringify!(ssl_cache_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ssl_cache_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ssl_cache_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cache_context>())).chain as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_context),
            "::",
            stringify!(chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cache_context>())).timeout as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_context),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cache_context>())).max_entries as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_context),
            "::",
            stringify!(max_entries)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ssl_cache_context>())).mutex as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ssl_cache_context),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ssl_cache_init"]
    pub fn ssl_cache_init(cache: *mut ssl_cache_context);
}
extern "C" {
    #[link_name = "mbedtls_ssl_cache_get"]
    pub fn ssl_cache_get(
        data: *mut raw_types::c_void,
        session: *mut ssl_session,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_cache_set"]
    pub fn ssl_cache_set(
        data: *mut raw_types::c_void,
        session: *const ssl_session,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ssl_cache_set_timeout"]
    pub fn ssl_cache_set_timeout(cache: *mut ssl_cache_context, timeout: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_cache_set_max_entries"]
    pub fn ssl_cache_set_max_entries(cache: *mut ssl_cache_context, max: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ssl_cache_free"]
    pub fn ssl_cache_free(cache: *mut ssl_cache_context);
}
extern "C" {
    #[link_name = "mbedtls_rsa_deduce_primes"]
    pub fn rsa_deduce_primes(
        N: *const mpi,
        E: *const mpi,
        D: *const mpi,
        P: *mut mpi,
        Q: *mut mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_deduce_private_exponent"]
    pub fn rsa_deduce_private_exponent(
        P: *const mpi,
        Q: *const mpi,
        E: *const mpi,
        D: *mut mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_deduce_crt"]
    pub fn rsa_deduce_crt(
        P: *const mpi,
        Q: *const mpi,
        D: *const mpi,
        DP: *mut mpi,
        DQ: *mut mpi,
        QP: *mut mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_validate_params"]
    pub fn rsa_validate_params(
        N: *const mpi,
        P: *const mpi,
        Q: *const mpi,
        D: *const mpi,
        E: *const mpi,
        f_rng: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_rng: *mut raw_types::c_void,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_rsa_validate_crt"]
    pub fn rsa_validate_crt(
        P: *const mpi,
        Q: *const mpi,
        D: *const mpi,
        DP: *const mpi,
        DQ: *const mpi,
        QP: *const mpi,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ripemd160_context {
    pub total: [u32; 2usize],
    pub state: [u32; 5usize],
    pub buffer: [raw_types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_ripemd160_context() {
    assert_eq!(
        ::core::mem::size_of::<ripemd160_context>(),
        92usize,
        concat!("Size of: ", stringify!(ripemd160_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ripemd160_context>(),
        4usize,
        concat!("Alignment of ", stringify!(ripemd160_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ripemd160_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ripemd160_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ripemd160_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ripemd160_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ripemd160_context>())).buffer as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ripemd160_context),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_init"]
    pub fn ripemd160_init(ctx: *mut ripemd160_context);
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_free"]
    pub fn ripemd160_free(ctx: *mut ripemd160_context);
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_clone"]
    pub fn ripemd160_clone(dst: *mut ripemd160_context, src: *const ripemd160_context);
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_starts_ret"]
    pub fn ripemd160_starts_ret(ctx: *mut ripemd160_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_update_ret"]
    pub fn ripemd160_update_ret(
        ctx: *mut ripemd160_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_finish_ret"]
    pub fn ripemd160_finish_ret(
        ctx: *mut ripemd160_context,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_internal_ripemd160_process"]
    pub fn internal_ripemd160_process(
        ctx: *mut ripemd160_context,
        data: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_starts"]
    pub fn ripemd160_starts(ctx: *mut ripemd160_context);
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_update"]
    pub fn ripemd160_update(
        ctx: *mut ripemd160_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
    );
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_finish"]
    pub fn ripemd160_finish(ctx: *mut ripemd160_context, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_process"]
    pub fn ripemd160_process(ctx: *mut ripemd160_context, data: *const raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_ret"]
    pub fn ripemd160_ret(
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ripemd160"]
    pub fn ripemd160(
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_self_test"]
    pub fn ripemd160_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct platform_context {
    pub dummy: raw_types::c_char,
}
#[test]
fn bindgen_test_layout_platform_context() {
    assert_eq!(
        ::core::mem::size_of::<platform_context>(),
        1usize,
        concat!("Size of: ", stringify!(platform_context))
    );
    assert_eq!(
        ::core::mem::align_of::<platform_context>(),
        1usize,
        concat!("Alignment of ", stringify!(platform_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<platform_context>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(platform_context),
            "::",
            stringify!(dummy)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_platform_setup"]
    pub fn platform_setup(ctx: *mut platform_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_platform_teardown"]
    pub fn platform_teardown(ctx: *mut platform_context);
}
extern "C" {
    #[link_name = "mbedtls_pkcs5_pbes2"]
    pub fn pkcs5_pbes2(
        pbe_params: *const asn1_buf,
        mode: raw_types::c_int,
        pwd: *const raw_types::c_uchar,
        pwdlen: usize,
        data: *const raw_types::c_uchar,
        datalen: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pkcs5_pbkdf2_hmac"]
    pub fn pkcs5_pbkdf2_hmac(
        ctx: *mut md_context_t,
        password: *const raw_types::c_uchar,
        plen: usize,
        salt: *const raw_types::c_uchar,
        slen: usize,
        iteration_count: raw_types::c_uint,
        key_length: u32,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pkcs5_self_test"]
    pub fn pkcs5_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pkcs12_pbe_sha1_rc4_128"]
    pub fn pkcs12_pbe_sha1_rc4_128(
        pbe_params: *mut asn1_buf,
        mode: raw_types::c_int,
        pwd: *const raw_types::c_uchar,
        pwdlen: usize,
        input: *const raw_types::c_uchar,
        len: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pkcs12_pbe"]
    pub fn pkcs12_pbe(
        pbe_params: *mut asn1_buf,
        mode: raw_types::c_int,
        cipher_type: cipher_type_t,
        md_type: md_type_t,
        pwd: *const raw_types::c_uchar,
        pwdlen: usize,
        input: *const raw_types::c_uchar,
        len: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pkcs12_derivation"]
    pub fn pkcs12_derivation(
        data: *mut raw_types::c_uchar,
        datalen: usize,
        pwd: *const raw_types::c_uchar,
        pwdlen: usize,
        salt: *const raw_types::c_uchar,
        saltlen: usize,
        mbedtls_md: md_type_t,
        id: raw_types::c_int,
        iterations: raw_types::c_int,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pk_info_t {
    pub type_: pk_type_t,
    pub name: *const raw_types::c_char,
    pub get_bitlen:
        ::core::option::Option<unsafe extern "C" fn(arg1: *const raw_types::c_void) -> usize>,
    pub can_do: ::core::option::Option<unsafe extern "C" fn(type_: pk_type_t) -> raw_types::c_int>,
    pub verify_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            md_alg: md_type_t,
            hash: *const raw_types::c_uchar,
            hash_len: usize,
            sig: *const raw_types::c_uchar,
            sig_len: usize,
        ) -> raw_types::c_int,
    >,
    pub sign_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            md_alg: md_type_t,
            hash: *const raw_types::c_uchar,
            hash_len: usize,
            sig: *mut raw_types::c_uchar,
            sig_len: *mut usize,
            f_rng: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut raw_types::c_void,
                    arg2: *mut raw_types::c_uchar,
                    arg3: usize,
                ) -> raw_types::c_int,
            >,
            p_rng: *mut raw_types::c_void,
        ) -> raw_types::c_int,
    >,
    pub decrypt_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            input: *const raw_types::c_uchar,
            ilen: usize,
            output: *mut raw_types::c_uchar,
            olen: *mut usize,
            osize: usize,
            f_rng: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut raw_types::c_void,
                    arg2: *mut raw_types::c_uchar,
                    arg3: usize,
                ) -> raw_types::c_int,
            >,
            p_rng: *mut raw_types::c_void,
        ) -> raw_types::c_int,
    >,
    pub encrypt_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            input: *const raw_types::c_uchar,
            ilen: usize,
            output: *mut raw_types::c_uchar,
            olen: *mut usize,
            osize: usize,
            f_rng: ::core::option::Option<
                unsafe extern "C" fn(
                    arg1: *mut raw_types::c_void,
                    arg2: *mut raw_types::c_uchar,
                    arg3: usize,
                ) -> raw_types::c_int,
            >,
            p_rng: *mut raw_types::c_void,
        ) -> raw_types::c_int,
    >,
    pub check_pair_func: ::core::option::Option<
        unsafe extern "C" fn(
            pub_: *const raw_types::c_void,
            prv: *const raw_types::c_void,
        ) -> raw_types::c_int,
    >,
    pub ctx_alloc_func: ::core::option::Option<unsafe extern "C" fn() -> *mut raw_types::c_void>,
    pub ctx_free_func: ::core::option::Option<unsafe extern "C" fn(ctx: *mut raw_types::c_void)>,
    pub debug_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *const raw_types::c_void, items: *mut pk_debug_item),
    >,
}
#[test]
fn bindgen_test_layout_pk_info_t() {
    assert_eq!(
        ::core::mem::size_of::<pk_info_t>(),
        96usize,
        concat!("Size of: ", stringify!(pk_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<pk_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pk_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).get_bitlen as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(get_bitlen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).can_do as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(can_do)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).verify_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(verify_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).sign_func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(sign_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).decrypt_func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(decrypt_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).encrypt_func as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(encrypt_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).check_pair_func as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(check_pair_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).ctx_alloc_func as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(ctx_alloc_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).ctx_free_func as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(ctx_free_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pk_info_t>())).debug_func as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(pk_info_t),
            "::",
            stringify!(debug_func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rsa_alt_context {
    pub key: *mut raw_types::c_void,
    pub decrypt_func: pk_rsa_alt_decrypt_func,
    pub sign_func: pk_rsa_alt_sign_func,
    pub key_len_func: pk_rsa_alt_key_len_func,
}
#[test]
fn bindgen_test_layout_rsa_alt_context() {
    assert_eq!(
        ::core::mem::size_of::<rsa_alt_context>(),
        32usize,
        concat!("Size of: ", stringify!(rsa_alt_context))
    );
    assert_eq!(
        ::core::mem::align_of::<rsa_alt_context>(),
        8usize,
        concat!("Alignment of ", stringify!(rsa_alt_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_alt_context>())).key as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_alt_context>())).decrypt_func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(decrypt_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_alt_context>())).sign_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(sign_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<rsa_alt_context>())).key_len_func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rsa_alt_context),
            "::",
            stringify!(key_len_func)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_rsa_info"]
    pub static rsa_info: pk_info_t;
}
extern "C" {
    #[link_name = "mbedtls_eckey_info"]
    pub static eckey_info: pk_info_t;
}
extern "C" {
    #[link_name = "mbedtls_eckeydh_info"]
    pub static eckeydh_info: pk_info_t;
}
extern "C" {
    #[link_name = "mbedtls_ecdsa_info"]
    pub static ecdsa_info: pk_info_t;
}
extern "C" {
    #[link_name = "mbedtls_rsa_alt_info"]
    pub static rsa_alt_info: pk_info_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pem_context {
    pub buf: *mut raw_types::c_uchar,
    pub buflen: usize,
    pub info: *mut raw_types::c_uchar,
}
#[test]
fn bindgen_test_layout_pem_context() {
    assert_eq!(
        ::core::mem::size_of::<pem_context>(),
        24usize,
        concat!("Size of: ", stringify!(pem_context))
    );
    assert_eq!(
        ::core::mem::align_of::<pem_context>(),
        8usize,
        concat!("Alignment of ", stringify!(pem_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pem_context>())).buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_context),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pem_context>())).buflen as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_context),
            "::",
            stringify!(buflen)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<pem_context>())).info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pem_context),
            "::",
            stringify!(info)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_pem_init"]
    pub fn pem_init(ctx: *mut pem_context);
}
extern "C" {
    #[link_name = "mbedtls_pem_read_buffer"]
    pub fn pem_read_buffer(
        ctx: *mut pem_context,
        header: *const raw_types::c_char,
        footer: *const raw_types::c_char,
        data: *const raw_types::c_uchar,
        pwd: *const raw_types::c_uchar,
        pwdlen: usize,
        use_len: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_pem_free"]
    pub fn pem_free(ctx: *mut pem_context);
}
extern "C" {
    #[link_name = "mbedtls_pem_write_buffer"]
    pub fn pem_write_buffer(
        header: *const raw_types::c_char,
        footer: *const raw_types::c_char,
        der_data: *const raw_types::c_uchar,
        der_len: usize,
        buf: *mut raw_types::c_uchar,
        buf_len: usize,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct oid_descriptor_t {
    pub asn1: *const raw_types::c_char,
    pub asn1_len: usize,
    pub name: *const raw_types::c_char,
    pub description: *const raw_types::c_char,
}
#[test]
fn bindgen_test_layout_oid_descriptor_t() {
    assert_eq!(
        ::core::mem::size_of::<oid_descriptor_t>(),
        32usize,
        concat!("Size of: ", stringify!(oid_descriptor_t))
    );
    assert_eq!(
        ::core::mem::align_of::<oid_descriptor_t>(),
        8usize,
        concat!("Alignment of ", stringify!(oid_descriptor_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<oid_descriptor_t>())).asn1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(asn1)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<oid_descriptor_t>())).asn1_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(asn1_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<oid_descriptor_t>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<oid_descriptor_t>())).description as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(oid_descriptor_t),
            "::",
            stringify!(description)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_oid_get_numeric_string"]
    pub fn oid_get_numeric_string(
        buf: *mut raw_types::c_char,
        size: usize,
        oid: *const asn1_buf,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_x509_ext_type"]
    pub fn oid_get_x509_ext_type(
        oid: *const asn1_buf,
        ext_type: *mut raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_attr_short_name"]
    pub fn oid_get_attr_short_name(
        oid: *const asn1_buf,
        short_name: *mut *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_pk_alg"]
    pub fn oid_get_pk_alg(oid: *const asn1_buf, pk_alg: *mut pk_type_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_oid_by_pk_alg"]
    pub fn oid_get_oid_by_pk_alg(
        pk_alg: pk_type_t,
        oid: *mut *const raw_types::c_char,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_ec_grp"]
    pub fn oid_get_ec_grp(oid: *const asn1_buf, grp_id: *mut ecp_group_id) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_oid_by_ec_grp"]
    pub fn oid_get_oid_by_ec_grp(
        grp_id: ecp_group_id,
        oid: *mut *const raw_types::c_char,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_sig_alg"]
    pub fn oid_get_sig_alg(
        oid: *const asn1_buf,
        md_alg: *mut md_type_t,
        pk_alg: *mut pk_type_t,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_sig_alg_desc"]
    pub fn oid_get_sig_alg_desc(
        oid: *const asn1_buf,
        desc: *mut *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_oid_by_sig_alg"]
    pub fn oid_get_oid_by_sig_alg(
        pk_alg: pk_type_t,
        md_alg: md_type_t,
        oid: *mut *const raw_types::c_char,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_md_alg"]
    pub fn oid_get_md_alg(oid: *const asn1_buf, md_alg: *mut md_type_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_md_hmac"]
    pub fn oid_get_md_hmac(oid: *const asn1_buf, md_hmac: *mut md_type_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_extended_key_usage"]
    pub fn oid_get_extended_key_usage(
        oid: *const asn1_buf,
        desc: *mut *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_oid_by_md"]
    pub fn oid_get_oid_by_md(
        md_alg: md_type_t,
        oid: *mut *const raw_types::c_char,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_cipher_alg"]
    pub fn oid_get_cipher_alg(
        oid: *const asn1_buf,
        cipher_alg: *mut cipher_type_t,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_oid_get_pkcs12_pbe_alg"]
    pub fn oid_get_pkcs12_pbe_alg(
        oid: *const asn1_buf,
        md_alg: *mut md_type_t,
        cipher_alg: *mut cipher_type_t,
    ) -> raw_types::c_int;
}
pub const KW_MODE_KW: nist_kw_mode_t = 0;
pub const KW_MODE_KWP: nist_kw_mode_t = 1;
pub type nist_kw_mode_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct nist_kw_context {
    pub cipher_ctx: cipher_context_t,
}
#[test]
fn bindgen_test_layout_nist_kw_context() {
    assert_eq!(
        ::core::mem::size_of::<nist_kw_context>(),
        88usize,
        concat!("Size of: ", stringify!(nist_kw_context))
    );
    assert_eq!(
        ::core::mem::align_of::<nist_kw_context>(),
        8usize,
        concat!("Alignment of ", stringify!(nist_kw_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<nist_kw_context>())).cipher_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(nist_kw_context),
            "::",
            stringify!(cipher_ctx)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_nist_kw_init"]
    pub fn nist_kw_init(ctx: *mut nist_kw_context);
}
extern "C" {
    #[link_name = "mbedtls_nist_kw_setkey"]
    pub fn nist_kw_setkey(
        ctx: *mut nist_kw_context,
        cipher: cipher_id_t,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
        is_wrap: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_nist_kw_free"]
    pub fn nist_kw_free(ctx: *mut nist_kw_context);
}
extern "C" {
    #[link_name = "mbedtls_nist_kw_wrap"]
    pub fn nist_kw_wrap(
        ctx: *mut nist_kw_context,
        mode: nist_kw_mode_t,
        input: *const raw_types::c_uchar,
        in_len: usize,
        output: *mut raw_types::c_uchar,
        out_len: *mut usize,
        out_size: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_nist_kw_unwrap"]
    pub fn nist_kw_unwrap(
        ctx: *mut nist_kw_context,
        mode: nist_kw_mode_t,
        input: *const raw_types::c_uchar,
        in_len: usize,
        output: *mut raw_types::c_uchar,
        out_len: *mut usize,
        out_size: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_nist_kw_self_test"]
    pub fn nist_kw_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_memory_buffer_alloc_init"]
    pub fn memory_buffer_alloc_init(buf: *mut raw_types::c_uchar, len: usize);
}
extern "C" {
    #[link_name = "mbedtls_memory_buffer_alloc_free"]
    pub fn memory_buffer_alloc_free();
}
extern "C" {
    #[link_name = "mbedtls_memory_buffer_set_verify"]
    pub fn memory_buffer_set_verify(verify: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_memory_buffer_alloc_verify"]
    pub fn memory_buffer_alloc_verify() -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_memory_buffer_alloc_self_test"]
    pub fn memory_buffer_alloc_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md_info_t {
    pub type_: md_type_t,
    pub name: *const raw_types::c_char,
    pub size: raw_types::c_int,
    pub block_size: raw_types::c_int,
    pub starts_func: ::core::option::Option<
        unsafe extern "C" fn(ctx: *mut raw_types::c_void) -> raw_types::c_int,
    >,
    pub update_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            input: *const raw_types::c_uchar,
            ilen: usize,
        ) -> raw_types::c_int,
    >,
    pub finish_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            output: *mut raw_types::c_uchar,
        ) -> raw_types::c_int,
    >,
    pub digest_func: ::core::option::Option<
        unsafe extern "C" fn(
            input: *const raw_types::c_uchar,
            ilen: usize,
            output: *mut raw_types::c_uchar,
        ) -> raw_types::c_int,
    >,
    pub ctx_alloc_func: ::core::option::Option<unsafe extern "C" fn() -> *mut raw_types::c_void>,
    pub ctx_free_func: ::core::option::Option<unsafe extern "C" fn(ctx: *mut raw_types::c_void)>,
    pub clone_func: ::core::option::Option<
        unsafe extern "C" fn(dst: *mut raw_types::c_void, src: *const raw_types::c_void),
    >,
    pub process_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            input: *const raw_types::c_uchar,
        ) -> raw_types::c_int,
    >,
}
#[test]
fn bindgen_test_layout_md_info_t() {
    assert_eq!(
        ::core::mem::size_of::<md_info_t>(),
        88usize,
        concat!("Size of: ", stringify!(md_info_t))
    );
    assert_eq!(
        ::core::mem::align_of::<md_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(md_info_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).name as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).block_size as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(block_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).starts_func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(starts_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).update_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(update_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).finish_func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(finish_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).digest_func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(digest_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).ctx_alloc_func as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(ctx_alloc_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).ctx_free_func as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(ctx_free_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).clone_func as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(clone_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md_info_t>())).process_func as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(md_info_t),
            "::",
            stringify!(process_func)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_md4_info"]
    pub static md4_info: md_info_t;
}
extern "C" {
    #[link_name = "mbedtls_md5_info"]
    pub static md5_info: md_info_t;
}
extern "C" {
    #[link_name = "mbedtls_ripemd160_info"]
    pub static ripemd160_info: md_info_t;
}
extern "C" {
    #[link_name = "mbedtls_sha1_info"]
    pub static sha1_info: md_info_t;
}
extern "C" {
    #[link_name = "mbedtls_sha224_info"]
    pub static sha224_info: md_info_t;
}
extern "C" {
    #[link_name = "mbedtls_sha256_info"]
    pub static sha256_info: md_info_t;
}
extern "C" {
    #[link_name = "mbedtls_sha384_info"]
    pub static sha384_info: md_info_t;
}
extern "C" {
    #[link_name = "mbedtls_sha512_info"]
    pub static sha512_info: md_info_t;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md4_context {
    pub total: [u32; 2usize],
    pub state: [u32; 4usize],
    pub buffer: [raw_types::c_uchar; 64usize],
}
#[test]
fn bindgen_test_layout_md4_context() {
    assert_eq!(
        ::core::mem::size_of::<md4_context>(),
        88usize,
        concat!("Size of: ", stringify!(md4_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md4_context>(),
        4usize,
        concat!("Alignment of ", stringify!(md4_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md4_context>())).total as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_context),
            "::",
            stringify!(total)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md4_context>())).state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md4_context>())).buffer as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(md4_context),
            "::",
            stringify!(buffer)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_md4_init"]
    pub fn md4_init(ctx: *mut md4_context);
}
extern "C" {
    #[link_name = "mbedtls_md4_free"]
    pub fn md4_free(ctx: *mut md4_context);
}
extern "C" {
    #[link_name = "mbedtls_md4_clone"]
    pub fn md4_clone(dst: *mut md4_context, src: *const md4_context);
}
extern "C" {
    #[link_name = "mbedtls_md4_starts_ret"]
    pub fn md4_starts_ret(ctx: *mut md4_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md4_update_ret"]
    pub fn md4_update_ret(
        ctx: *mut md4_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md4_finish_ret"]
    pub fn md4_finish_ret(
        ctx: *mut md4_context,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_internal_md4_process"]
    pub fn internal_md4_process(
        ctx: *mut md4_context,
        data: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md4_starts"]
    pub fn md4_starts(ctx: *mut md4_context);
}
extern "C" {
    #[link_name = "mbedtls_md4_update"]
    pub fn md4_update(ctx: *mut md4_context, input: *const raw_types::c_uchar, ilen: usize);
}
extern "C" {
    #[link_name = "mbedtls_md4_finish"]
    pub fn md4_finish(ctx: *mut md4_context, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_md4_process"]
    pub fn md4_process(ctx: *mut md4_context, data: *const raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_md4_ret"]
    pub fn md4_ret(
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md4"]
    pub fn md4(input: *const raw_types::c_uchar, ilen: usize, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_md4_self_test"]
    pub fn md4_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct md2_context {
    pub cksum: [raw_types::c_uchar; 16usize],
    pub state: [raw_types::c_uchar; 48usize],
    pub buffer: [raw_types::c_uchar; 16usize],
    pub left: usize,
}
#[test]
fn bindgen_test_layout_md2_context() {
    assert_eq!(
        ::core::mem::size_of::<md2_context>(),
        88usize,
        concat!("Size of: ", stringify!(md2_context))
    );
    assert_eq!(
        ::core::mem::align_of::<md2_context>(),
        8usize,
        concat!("Alignment of ", stringify!(md2_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md2_context>())).cksum as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(cksum)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md2_context>())).state as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md2_context>())).buffer as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(buffer)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<md2_context>())).left as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(md2_context),
            "::",
            stringify!(left)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_md2_init"]
    pub fn md2_init(ctx: *mut md2_context);
}
extern "C" {
    #[link_name = "mbedtls_md2_free"]
    pub fn md2_free(ctx: *mut md2_context);
}
extern "C" {
    #[link_name = "mbedtls_md2_clone"]
    pub fn md2_clone(dst: *mut md2_context, src: *const md2_context);
}
extern "C" {
    #[link_name = "mbedtls_md2_starts_ret"]
    pub fn md2_starts_ret(ctx: *mut md2_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md2_update_ret"]
    pub fn md2_update_ret(
        ctx: *mut md2_context,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md2_finish_ret"]
    pub fn md2_finish_ret(
        ctx: *mut md2_context,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_internal_md2_process"]
    pub fn internal_md2_process(ctx: *mut md2_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md2_starts"]
    pub fn md2_starts(ctx: *mut md2_context);
}
extern "C" {
    #[link_name = "mbedtls_md2_update"]
    pub fn md2_update(ctx: *mut md2_context, input: *const raw_types::c_uchar, ilen: usize);
}
extern "C" {
    #[link_name = "mbedtls_md2_finish"]
    pub fn md2_finish(ctx: *mut md2_context, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_md2_process"]
    pub fn md2_process(ctx: *mut md2_context);
}
extern "C" {
    #[link_name = "mbedtls_md2_ret"]
    pub fn md2_ret(
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_md2"]
    pub fn md2(input: *const raw_types::c_uchar, ilen: usize, output: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_md2_self_test"]
    pub fn md2_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hmac_drbg_context {
    pub md_ctx: md_context_t,
    pub V: [raw_types::c_uchar; 64usize],
    pub reseed_counter: raw_types::c_int,
    pub entropy_len: usize,
    pub prediction_resistance: raw_types::c_int,
    pub reseed_interval: raw_types::c_int,
    pub f_entropy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *mut raw_types::c_uchar,
            arg3: usize,
        ) -> raw_types::c_int,
    >,
    pub p_entropy: *mut raw_types::c_void,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_hmac_drbg_context() {
    assert_eq!(
        ::core::mem::size_of::<hmac_drbg_context>(),
        176usize,
        concat!("Size of: ", stringify!(hmac_drbg_context))
    );
    assert_eq!(
        ::core::mem::align_of::<hmac_drbg_context>(),
        8usize,
        concat!("Alignment of ", stringify!(hmac_drbg_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).md_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(md_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).V as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(V)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hmac_drbg_context>())).reseed_counter as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(reseed_counter)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).entropy_len as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(entropy_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hmac_drbg_context>())).prediction_resistance as *const _
                as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(prediction_resistance)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<hmac_drbg_context>())).reseed_interval as *const _ as usize
        },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(reseed_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).f_entropy as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(f_entropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).p_entropy as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(p_entropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<hmac_drbg_context>())).mutex as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(hmac_drbg_context),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_init"]
    pub fn hmac_drbg_init(ctx: *mut hmac_drbg_context);
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_seed"]
    pub fn hmac_drbg_seed(
        ctx: *mut hmac_drbg_context,
        md_info: *const md_info_t,
        f_entropy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_entropy: *mut raw_types::c_void,
        custom: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_seed_buf"]
    pub fn hmac_drbg_seed_buf(
        ctx: *mut hmac_drbg_context,
        md_info: *const md_info_t,
        data: *const raw_types::c_uchar,
        data_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_set_prediction_resistance"]
    pub fn hmac_drbg_set_prediction_resistance(
        ctx: *mut hmac_drbg_context,
        resistance: raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_set_entropy_len"]
    pub fn hmac_drbg_set_entropy_len(ctx: *mut hmac_drbg_context, len: usize);
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_set_reseed_interval"]
    pub fn hmac_drbg_set_reseed_interval(ctx: *mut hmac_drbg_context, interval: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_update_ret"]
    pub fn hmac_drbg_update_ret(
        ctx: *mut hmac_drbg_context,
        additional: *const raw_types::c_uchar,
        add_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_reseed"]
    pub fn hmac_drbg_reseed(
        ctx: *mut hmac_drbg_context,
        additional: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_random_with_add"]
    pub fn hmac_drbg_random_with_add(
        p_rng: *mut raw_types::c_void,
        output: *mut raw_types::c_uchar,
        output_len: usize,
        additional: *const raw_types::c_uchar,
        add_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_random"]
    pub fn hmac_drbg_random(
        p_rng: *mut raw_types::c_void,
        output: *mut raw_types::c_uchar,
        out_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_free"]
    pub fn hmac_drbg_free(ctx: *mut hmac_drbg_context);
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_update"]
    pub fn hmac_drbg_update(
        ctx: *mut hmac_drbg_context,
        additional: *const raw_types::c_uchar,
        add_len: usize,
    );
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_write_seed_file"]
    pub fn hmac_drbg_write_seed_file(
        ctx: *mut hmac_drbg_context,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_update_seed_file"]
    pub fn hmac_drbg_update_seed_file(
        ctx: *mut hmac_drbg_context,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hmac_drbg_self_test"]
    pub fn hmac_drbg_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hkdf"]
    pub fn hkdf(
        md: *const md_info_t,
        salt: *const raw_types::c_uchar,
        salt_len: usize,
        ikm: *const raw_types::c_uchar,
        ikm_len: usize,
        info: *const raw_types::c_uchar,
        info_len: usize,
        okm: *mut raw_types::c_uchar,
        okm_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hkdf_extract"]
    pub fn hkdf_extract(
        md: *const md_info_t,
        salt: *const raw_types::c_uchar,
        salt_len: usize,
        ikm: *const raw_types::c_uchar,
        ikm_len: usize,
        prk: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hkdf_expand"]
    pub fn hkdf_expand(
        md: *const md_info_t,
        prk: *const raw_types::c_uchar,
        prk_len: usize,
        info: *const raw_types::c_uchar,
        info_len: usize,
        okm: *mut raw_types::c_uchar,
        okm_len: usize,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct gcm_context {
    pub cipher_ctx: cipher_context_t,
    pub HL: [u64; 16usize],
    pub HH: [u64; 16usize],
    pub len: u64,
    pub add_len: u64,
    pub base_ectr: [raw_types::c_uchar; 16usize],
    pub y: [raw_types::c_uchar; 16usize],
    pub buf: [raw_types::c_uchar; 16usize],
    pub mode: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_gcm_context() {
    assert_eq!(
        ::core::mem::size_of::<gcm_context>(),
        416usize,
        concat!("Size of: ", stringify!(gcm_context))
    );
    assert_eq!(
        ::core::mem::align_of::<gcm_context>(),
        8usize,
        concat!("Alignment of ", stringify!(gcm_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).cipher_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(cipher_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).HL as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(HL)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).HH as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(HH)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).len as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).add_len as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(add_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).base_ectr as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(base_ectr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).y as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).buf as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<gcm_context>())).mode as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(gcm_context),
            "::",
            stringify!(mode)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_gcm_init"]
    pub fn gcm_init(ctx: *mut gcm_context);
}
extern "C" {
    #[link_name = "mbedtls_gcm_setkey"]
    pub fn gcm_setkey(
        ctx: *mut gcm_context,
        cipher: cipher_id_t,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_gcm_crypt_and_tag"]
    pub fn gcm_crypt_and_tag(
        ctx: *mut gcm_context,
        mode: raw_types::c_int,
        length: usize,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
        add: *const raw_types::c_uchar,
        add_len: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
        tag_len: usize,
        tag: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_gcm_auth_decrypt"]
    pub fn gcm_auth_decrypt(
        ctx: *mut gcm_context,
        length: usize,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
        add: *const raw_types::c_uchar,
        add_len: usize,
        tag: *const raw_types::c_uchar,
        tag_len: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_gcm_starts"]
    pub fn gcm_starts(
        ctx: *mut gcm_context,
        mode: raw_types::c_int,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
        add: *const raw_types::c_uchar,
        add_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_gcm_update"]
    pub fn gcm_update(
        ctx: *mut gcm_context,
        length: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_gcm_finish"]
    pub fn gcm_finish(
        ctx: *mut gcm_context,
        tag: *mut raw_types::c_uchar,
        tag_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_gcm_free"]
    pub fn gcm_free(ctx: *mut gcm_context);
}
extern "C" {
    #[link_name = "mbedtls_gcm_self_test"]
    pub fn gcm_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_strerror"]
    pub fn strerror(errnum: raw_types::c_int, buffer: *mut raw_types::c_char, buflen: usize);
}
extern "C" {
    #[link_name = "mbedtls_platform_entropy_poll"]
    pub fn platform_entropy_poll(
        data: *mut raw_types::c_void,
        output: *mut raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_havege_poll"]
    pub fn havege_poll(
        data: *mut raw_types::c_void,
        output: *mut raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_hardclock_poll"]
    pub fn hardclock_poll(
        data: *mut raw_types::c_void,
        output: *mut raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> raw_types::c_int;
}
pub type entropy_f_source_ptr = ::core::option::Option<
    unsafe extern "C" fn(
        data: *mut raw_types::c_void,
        output: *mut raw_types::c_uchar,
        len: usize,
        olen: *mut usize,
    ) -> raw_types::c_int,
>;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct entropy_source_state {
    pub f_source: entropy_f_source_ptr,
    pub p_source: *mut raw_types::c_void,
    pub size: usize,
    pub threshold: usize,
    pub strong: raw_types::c_int,
}
#[test]
fn bindgen_test_layout_entropy_source_state() {
    assert_eq!(
        ::core::mem::size_of::<entropy_source_state>(),
        40usize,
        concat!("Size of: ", stringify!(entropy_source_state))
    );
    assert_eq!(
        ::core::mem::align_of::<entropy_source_state>(),
        8usize,
        concat!("Alignment of ", stringify!(entropy_source_state))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_source_state>())).f_source as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(f_source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_source_state>())).p_source as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(p_source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_source_state>())).size as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_source_state>())).threshold as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(threshold)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_source_state>())).strong as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_source_state),
            "::",
            stringify!(strong)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct entropy_context {
    pub accumulator_started: raw_types::c_int,
    pub accumulator: sha512_context,
    pub source_count: raw_types::c_int,
    pub source: [entropy_source_state; 20usize],
    pub havege_data: havege_state,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_entropy_context() {
    assert_eq!(
        ::core::mem::size_of::<entropy_context>(),
        37960usize,
        concat!("Size of: ", stringify!(entropy_context))
    );
    assert_eq!(
        ::core::mem::align_of::<entropy_context>(),
        8usize,
        concat!("Alignment of ", stringify!(entropy_context))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<entropy_context>())).accumulator_started as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(accumulator_started)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_context>())).accumulator as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(accumulator)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_context>())).source_count as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(source_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_context>())).source as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(source)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_context>())).havege_data as *const _ as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(havege_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<entropy_context>())).mutex as *const _ as usize },
        37912usize,
        concat!(
            "Offset of field: ",
            stringify!(entropy_context),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_entropy_init"]
    pub fn entropy_init(ctx: *mut entropy_context);
}
extern "C" {
    #[link_name = "mbedtls_entropy_free"]
    pub fn entropy_free(ctx: *mut entropy_context);
}
extern "C" {
    #[link_name = "mbedtls_entropy_add_source"]
    pub fn entropy_add_source(
        ctx: *mut entropy_context,
        f_source: entropy_f_source_ptr,
        p_source: *mut raw_types::c_void,
        threshold: usize,
        strong: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_entropy_gather"]
    pub fn entropy_gather(ctx: *mut entropy_context) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_entropy_func"]
    pub fn entropy_func(
        data: *mut raw_types::c_void,
        output: *mut raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_entropy_update_manual"]
    pub fn entropy_update_manual(
        ctx: *mut entropy_context,
        data: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_entropy_write_seed_file"]
    pub fn entropy_write_seed_file(
        ctx: *mut entropy_context,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_entropy_update_seed_file"]
    pub fn entropy_update_seed_file(
        ctx: *mut entropy_context,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_entropy_self_test"]
    pub fn entropy_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct des_context {
    pub sk: [u32; 32usize],
}
#[test]
fn bindgen_test_layout_des_context() {
    assert_eq!(
        ::core::mem::size_of::<des_context>(),
        128usize,
        concat!("Size of: ", stringify!(des_context))
    );
    assert_eq!(
        ::core::mem::align_of::<des_context>(),
        4usize,
        concat!("Alignment of ", stringify!(des_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<des_context>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(des_context),
            "::",
            stringify!(sk)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct des3_context {
    pub sk: [u32; 96usize],
}
#[test]
fn bindgen_test_layout_des3_context() {
    assert_eq!(
        ::core::mem::size_of::<des3_context>(),
        384usize,
        concat!("Size of: ", stringify!(des3_context))
    );
    assert_eq!(
        ::core::mem::align_of::<des3_context>(),
        4usize,
        concat!("Alignment of ", stringify!(des3_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<des3_context>())).sk as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(des3_context),
            "::",
            stringify!(sk)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_des_init"]
    pub fn des_init(ctx: *mut des_context);
}
extern "C" {
    #[link_name = "mbedtls_des_free"]
    pub fn des_free(ctx: *mut des_context);
}
extern "C" {
    #[link_name = "mbedtls_des3_init"]
    pub fn des3_init(ctx: *mut des3_context);
}
extern "C" {
    #[link_name = "mbedtls_des3_free"]
    pub fn des3_free(ctx: *mut des3_context);
}
extern "C" {
    #[link_name = "mbedtls_des_key_set_parity"]
    pub fn des_key_set_parity(key: *mut raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_des_key_check_key_parity"]
    pub fn des_key_check_key_parity(key: *const raw_types::c_uchar) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des_key_check_weak"]
    pub fn des_key_check_weak(key: *const raw_types::c_uchar) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des_setkey_enc"]
    pub fn des_setkey_enc(
        ctx: *mut des_context,
        key: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des_setkey_dec"]
    pub fn des_setkey_dec(
        ctx: *mut des_context,
        key: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des3_set2key_enc"]
    pub fn des3_set2key_enc(
        ctx: *mut des3_context,
        key: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des3_set2key_dec"]
    pub fn des3_set2key_dec(
        ctx: *mut des3_context,
        key: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des3_set3key_enc"]
    pub fn des3_set3key_enc(
        ctx: *mut des3_context,
        key: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des3_set3key_dec"]
    pub fn des3_set3key_dec(
        ctx: *mut des3_context,
        key: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des_crypt_ecb"]
    pub fn des_crypt_ecb(
        ctx: *mut des_context,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des_crypt_cbc"]
    pub fn des_crypt_cbc(
        ctx: *mut des_context,
        mode: raw_types::c_int,
        length: usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des3_crypt_ecb"]
    pub fn des3_crypt_ecb(
        ctx: *mut des3_context,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des3_crypt_cbc"]
    pub fn des3_crypt_cbc(
        ctx: *mut des3_context,
        mode: raw_types::c_int,
        length: usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_des_setkey"]
    pub fn des_setkey(SK: *mut u32, key: *const raw_types::c_uchar);
}
extern "C" {
    #[link_name = "mbedtls_des_self_test"]
    pub fn des_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_debug_set_threshold"]
    pub fn debug_set_threshold(threshold: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_debug_print_msg"]
    pub fn debug_print_msg(
        ssl: *const ssl_context,
        level: raw_types::c_int,
        file: *const raw_types::c_char,
        line: raw_types::c_int,
        format: *const raw_types::c_char,
        ...
    );
}
extern "C" {
    #[link_name = "mbedtls_debug_print_ret"]
    pub fn debug_print_ret(
        ssl: *const ssl_context,
        level: raw_types::c_int,
        file: *const raw_types::c_char,
        line: raw_types::c_int,
        text: *const raw_types::c_char,
        ret: raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "mbedtls_debug_print_buf"]
    pub fn debug_print_buf(
        ssl: *const ssl_context,
        level: raw_types::c_int,
        file: *const raw_types::c_char,
        line: raw_types::c_int,
        text: *const raw_types::c_char,
        buf: *const raw_types::c_uchar,
        len: usize,
    );
}
extern "C" {
    #[link_name = "mbedtls_debug_print_mpi"]
    pub fn debug_print_mpi(
        ssl: *const ssl_context,
        level: raw_types::c_int,
        file: *const raw_types::c_char,
        line: raw_types::c_int,
        text: *const raw_types::c_char,
        X: *const mpi,
    );
}
extern "C" {
    #[link_name = "mbedtls_debug_print_ecp"]
    pub fn debug_print_ecp(
        ssl: *const ssl_context,
        level: raw_types::c_int,
        file: *const raw_types::c_char,
        line: raw_types::c_int,
        text: *const raw_types::c_char,
        X: *const ecp_point,
    );
}
extern "C" {
    #[link_name = "mbedtls_debug_print_crt"]
    pub fn debug_print_crt(
        ssl: *const ssl_context,
        level: raw_types::c_int,
        file: *const raw_types::c_char,
        line: raw_types::c_int,
        text: *const raw_types::c_char,
        crt: *const x509_crt,
    );
}
pub const DEBUG_ECDH_Q: debug_ecdh_attr = 0;
pub const DEBUG_ECDH_QP: debug_ecdh_attr = 1;
pub const DEBUG_ECDH_Z: debug_ecdh_attr = 2;
pub type debug_ecdh_attr = u32;
extern "C" {
    #[link_name = "mbedtls_debug_printf_ecdh"]
    pub fn debug_printf_ecdh(
        ssl: *const ssl_context,
        level: raw_types::c_int,
        file: *const raw_types::c_char,
        line: raw_types::c_int,
        ecdh: *const ecdh_context,
        attr: debug_ecdh_attr,
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ctr_drbg_context {
    pub counter: [raw_types::c_uchar; 16usize],
    pub reseed_counter: raw_types::c_int,
    pub prediction_resistance: raw_types::c_int,
    pub entropy_len: usize,
    pub reseed_interval: raw_types::c_int,
    pub aes_ctx: aes_context,
    pub f_entropy: ::core::option::Option<
        unsafe extern "C" fn(
            arg1: *mut raw_types::c_void,
            arg2: *mut raw_types::c_uchar,
            arg3: usize,
        ) -> raw_types::c_int,
    >,
    pub p_entropy: *mut raw_types::c_void,
    pub mutex: threading_mutex_t,
}
#[test]
fn bindgen_test_layout_ctr_drbg_context() {
    assert_eq!(
        ::core::mem::size_of::<ctr_drbg_context>(),
        392usize,
        concat!("Size of: ", stringify!(ctr_drbg_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ctr_drbg_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ctr_drbg_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).counter as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(counter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctr_drbg_context>())).reseed_counter as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(reseed_counter)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctr_drbg_context>())).prediction_resistance as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(prediction_resistance)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).entropy_len as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(entropy_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<ctr_drbg_context>())).reseed_interval as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(reseed_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).aes_ctx as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(aes_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).f_entropy as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(f_entropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).p_entropy as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(p_entropy)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ctr_drbg_context>())).mutex as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ctr_drbg_context),
            "::",
            stringify!(mutex)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_init"]
    pub fn ctr_drbg_init(ctx: *mut ctr_drbg_context);
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_seed"]
    pub fn ctr_drbg_seed(
        ctx: *mut ctr_drbg_context,
        f_entropy: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        p_entropy: *mut raw_types::c_void,
        custom: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_free"]
    pub fn ctr_drbg_free(ctx: *mut ctr_drbg_context);
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_set_prediction_resistance"]
    pub fn ctr_drbg_set_prediction_resistance(
        ctx: *mut ctr_drbg_context,
        resistance: raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_set_entropy_len"]
    pub fn ctr_drbg_set_entropy_len(ctx: *mut ctr_drbg_context, len: usize);
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_set_reseed_interval"]
    pub fn ctr_drbg_set_reseed_interval(ctx: *mut ctr_drbg_context, interval: raw_types::c_int);
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_reseed"]
    pub fn ctr_drbg_reseed(
        ctx: *mut ctr_drbg_context,
        additional: *const raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_update_ret"]
    pub fn ctr_drbg_update_ret(
        ctx: *mut ctr_drbg_context,
        additional: *const raw_types::c_uchar,
        add_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_random_with_add"]
    pub fn ctr_drbg_random_with_add(
        p_rng: *mut raw_types::c_void,
        output: *mut raw_types::c_uchar,
        output_len: usize,
        additional: *const raw_types::c_uchar,
        add_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_random"]
    pub fn ctr_drbg_random(
        p_rng: *mut raw_types::c_void,
        output: *mut raw_types::c_uchar,
        output_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_update"]
    pub fn ctr_drbg_update(
        ctx: *mut ctr_drbg_context,
        additional: *const raw_types::c_uchar,
        add_len: usize,
    );
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_write_seed_file"]
    pub fn ctr_drbg_write_seed_file(
        ctx: *mut ctr_drbg_context,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_update_seed_file"]
    pub fn ctr_drbg_update_seed_file(
        ctx: *mut ctr_drbg_context,
        path: *const raw_types::c_char,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_self_test"]
    pub fn ctr_drbg_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ctr_drbg_seed_entropy_len"]
    pub fn ctr_drbg_seed_entropy_len(
        arg1: *mut ctr_drbg_context,
        arg2: ::core::option::Option<
            unsafe extern "C" fn(
                arg1: *mut raw_types::c_void,
                arg2: *mut raw_types::c_uchar,
                arg3: usize,
            ) -> raw_types::c_int,
        >,
        arg3: *mut raw_types::c_void,
        arg4: *const raw_types::c_uchar,
        arg5: usize,
        arg6: usize,
    ) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cmac_context_t {
    pub state: [raw_types::c_uchar; 16usize],
    pub unprocessed_block: [raw_types::c_uchar; 16usize],
    pub unprocessed_len: usize,
}
#[test]
fn bindgen_test_layout_cmac_context_t() {
    assert_eq!(
        ::core::mem::size_of::<cmac_context_t>(),
        40usize,
        concat!("Size of: ", stringify!(cmac_context_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cmac_context_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cmac_context_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmac_context_t>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cmac_context_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<cmac_context_t>())).unprocessed_block as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cmac_context_t),
            "::",
            stringify!(unprocessed_block)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cmac_context_t>())).unprocessed_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cmac_context_t),
            "::",
            stringify!(unprocessed_len)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_cipher_cmac_starts"]
    pub fn cipher_cmac_starts(
        ctx: *mut cipher_context_t,
        key: *const raw_types::c_uchar,
        keybits: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_cmac_update"]
    pub fn cipher_cmac_update(
        ctx: *mut cipher_context_t,
        input: *const raw_types::c_uchar,
        ilen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_cmac_finish"]
    pub fn cipher_cmac_finish(
        ctx: *mut cipher_context_t,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_cmac_reset"]
    pub fn cipher_cmac_reset(ctx: *mut cipher_context_t) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cipher_cmac"]
    pub fn cipher_cmac(
        cipher_info: *const cipher_info_t,
        key: *const raw_types::c_uchar,
        keylen: usize,
        input: *const raw_types::c_uchar,
        ilen: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aes_cmac_prf_128"]
    pub fn aes_cmac_prf_128(
        key: *const raw_types::c_uchar,
        key_len: usize,
        input: *const raw_types::c_uchar,
        in_len: usize,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_cmac_self_test"]
    pub fn cmac_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cipher_base_t {
    pub cipher: cipher_id_t,
    pub ecb_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            mode: operation_t,
            input: *const raw_types::c_uchar,
            output: *mut raw_types::c_uchar,
        ) -> raw_types::c_int,
    >,
    pub cbc_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            mode: operation_t,
            length: usize,
            iv: *mut raw_types::c_uchar,
            input: *const raw_types::c_uchar,
            output: *mut raw_types::c_uchar,
        ) -> raw_types::c_int,
    >,
    pub cfb_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            mode: operation_t,
            length: usize,
            iv_off: *mut usize,
            iv: *mut raw_types::c_uchar,
            input: *const raw_types::c_uchar,
            output: *mut raw_types::c_uchar,
        ) -> raw_types::c_int,
    >,
    pub ofb_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            length: usize,
            iv_off: *mut usize,
            iv: *mut raw_types::c_uchar,
            input: *const raw_types::c_uchar,
            output: *mut raw_types::c_uchar,
        ) -> raw_types::c_int,
    >,
    pub ctr_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            length: usize,
            nc_off: *mut usize,
            nonce_counter: *mut raw_types::c_uchar,
            stream_block: *mut raw_types::c_uchar,
            input: *const raw_types::c_uchar,
            output: *mut raw_types::c_uchar,
        ) -> raw_types::c_int,
    >,
    pub xts_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            mode: operation_t,
            length: usize,
            data_unit: *const raw_types::c_uchar,
            input: *const raw_types::c_uchar,
            output: *mut raw_types::c_uchar,
        ) -> raw_types::c_int,
    >,
    pub stream_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            length: usize,
            input: *const raw_types::c_uchar,
            output: *mut raw_types::c_uchar,
        ) -> raw_types::c_int,
    >,
    pub setkey_enc_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            key: *const raw_types::c_uchar,
            key_bitlen: raw_types::c_uint,
        ) -> raw_types::c_int,
    >,
    pub setkey_dec_func: ::core::option::Option<
        unsafe extern "C" fn(
            ctx: *mut raw_types::c_void,
            key: *const raw_types::c_uchar,
            key_bitlen: raw_types::c_uint,
        ) -> raw_types::c_int,
    >,
    pub ctx_alloc_func: ::core::option::Option<unsafe extern "C" fn() -> *mut raw_types::c_void>,
    pub ctx_free_func: ::core::option::Option<unsafe extern "C" fn(ctx: *mut raw_types::c_void)>,
}
#[test]
fn bindgen_test_layout_cipher_base_t() {
    assert_eq!(
        ::core::mem::size_of::<cipher_base_t>(),
        96usize,
        concat!("Size of: ", stringify!(cipher_base_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_base_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cipher_base_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).cipher as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(cipher)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).ecb_func as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ecb_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).cbc_func as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(cbc_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).cfb_func as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(cfb_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).ofb_func as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ofb_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).ctr_func as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ctr_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).xts_func as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(xts_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).stream_func as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(stream_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).setkey_enc_func as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(setkey_enc_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).setkey_dec_func as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(setkey_dec_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).ctx_alloc_func as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ctx_alloc_func)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_base_t>())).ctx_free_func as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_base_t),
            "::",
            stringify!(ctx_free_func)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct cipher_definition_t {
    pub type_: cipher_type_t,
    pub info: *const cipher_info_t,
}
#[test]
fn bindgen_test_layout_cipher_definition_t() {
    assert_eq!(
        ::core::mem::size_of::<cipher_definition_t>(),
        16usize,
        concat!("Size of: ", stringify!(cipher_definition_t))
    );
    assert_eq!(
        ::core::mem::align_of::<cipher_definition_t>(),
        8usize,
        concat!("Alignment of ", stringify!(cipher_definition_t))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_definition_t>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_definition_t),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<cipher_definition_t>())).info as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(cipher_definition_t),
            "::",
            stringify!(info)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_cipher_definitions"]
    pub static mut cipher_definitions: [cipher_definition_t; 0usize];
}
extern "C" {
    #[link_name = "mbedtls_cipher_supported"]
    pub static mut cipher_supported: [raw_types::c_int; 0usize];
}
pub const CHACHAPOLY_ENCRYPT: chachapoly_mode_t = 0;
pub const CHACHAPOLY_DECRYPT: chachapoly_mode_t = 1;
pub type chachapoly_mode_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct chachapoly_context {
    pub chacha20_ctx: chacha20_context,
    pub poly1305_ctx: poly1305_context,
    pub aad_len: u64,
    pub ciphertext_len: u64,
    pub state: raw_types::c_int,
    pub mode: chachapoly_mode_t,
}
#[test]
fn bindgen_test_layout_chachapoly_context() {
    assert_eq!(
        ::core::mem::size_of::<chachapoly_context>(),
        240usize,
        concat!("Size of: ", stringify!(chachapoly_context))
    );
    assert_eq!(
        ::core::mem::align_of::<chachapoly_context>(),
        8usize,
        concat!("Alignment of ", stringify!(chachapoly_context))
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<chachapoly_context>())).chacha20_ctx as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(chacha20_ctx)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<chachapoly_context>())).poly1305_ctx as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(poly1305_ctx)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<chachapoly_context>())).aad_len as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(aad_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<chachapoly_context>())).ciphertext_len as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(ciphertext_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<chachapoly_context>())).state as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<chachapoly_context>())).mode as *const _ as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(chachapoly_context),
            "::",
            stringify!(mode)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_chachapoly_init"]
    pub fn chachapoly_init(ctx: *mut chachapoly_context);
}
extern "C" {
    #[link_name = "mbedtls_chachapoly_free"]
    pub fn chachapoly_free(ctx: *mut chachapoly_context);
}
extern "C" {
    #[link_name = "mbedtls_chachapoly_setkey"]
    pub fn chachapoly_setkey(
        ctx: *mut chachapoly_context,
        key: *const raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chachapoly_starts"]
    pub fn chachapoly_starts(
        ctx: *mut chachapoly_context,
        nonce: *const raw_types::c_uchar,
        mode: chachapoly_mode_t,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chachapoly_update_aad"]
    pub fn chachapoly_update_aad(
        ctx: *mut chachapoly_context,
        aad: *const raw_types::c_uchar,
        aad_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chachapoly_update"]
    pub fn chachapoly_update(
        ctx: *mut chachapoly_context,
        len: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chachapoly_finish"]
    pub fn chachapoly_finish(
        ctx: *mut chachapoly_context,
        mac: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chachapoly_encrypt_and_tag"]
    pub fn chachapoly_encrypt_and_tag(
        ctx: *mut chachapoly_context,
        length: usize,
        nonce: *const raw_types::c_uchar,
        aad: *const raw_types::c_uchar,
        aad_len: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
        tag: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chachapoly_auth_decrypt"]
    pub fn chachapoly_auth_decrypt(
        ctx: *mut chachapoly_context,
        length: usize,
        nonce: *const raw_types::c_uchar,
        aad: *const raw_types::c_uchar,
        aad_len: usize,
        tag: *const raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_chachapoly_self_test"]
    pub fn chachapoly_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ccm_context {
    pub cipher_ctx: cipher_context_t,
}
#[test]
fn bindgen_test_layout_ccm_context() {
    assert_eq!(
        ::core::mem::size_of::<ccm_context>(),
        88usize,
        concat!("Size of: ", stringify!(ccm_context))
    );
    assert_eq!(
        ::core::mem::align_of::<ccm_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ccm_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<ccm_context>())).cipher_ctx as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ccm_context),
            "::",
            stringify!(cipher_ctx)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_ccm_init"]
    pub fn ccm_init(ctx: *mut ccm_context);
}
extern "C" {
    #[link_name = "mbedtls_ccm_setkey"]
    pub fn ccm_setkey(
        ctx: *mut ccm_context,
        cipher: cipher_id_t,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ccm_free"]
    pub fn ccm_free(ctx: *mut ccm_context);
}
extern "C" {
    #[link_name = "mbedtls_ccm_encrypt_and_tag"]
    pub fn ccm_encrypt_and_tag(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
        add: *const raw_types::c_uchar,
        add_len: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
        tag: *mut raw_types::c_uchar,
        tag_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ccm_star_encrypt_and_tag"]
    pub fn ccm_star_encrypt_and_tag(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
        add: *const raw_types::c_uchar,
        add_len: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
        tag: *mut raw_types::c_uchar,
        tag_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ccm_auth_decrypt"]
    pub fn ccm_auth_decrypt(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
        add: *const raw_types::c_uchar,
        add_len: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
        tag: *const raw_types::c_uchar,
        tag_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ccm_star_auth_decrypt"]
    pub fn ccm_star_auth_decrypt(
        ctx: *mut ccm_context,
        length: usize,
        iv: *const raw_types::c_uchar,
        iv_len: usize,
        add: *const raw_types::c_uchar,
        add_len: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
        tag: *const raw_types::c_uchar,
        tag_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_ccm_self_test"]
    pub fn ccm_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct camellia_context {
    pub nr: raw_types::c_int,
    pub rk: [u32; 68usize],
}
#[test]
fn bindgen_test_layout_camellia_context() {
    assert_eq!(
        ::core::mem::size_of::<camellia_context>(),
        276usize,
        concat!("Size of: ", stringify!(camellia_context))
    );
    assert_eq!(
        ::core::mem::align_of::<camellia_context>(),
        4usize,
        concat!("Alignment of ", stringify!(camellia_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<camellia_context>())).nr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(camellia_context),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<camellia_context>())).rk as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(camellia_context),
            "::",
            stringify!(rk)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_camellia_init"]
    pub fn camellia_init(ctx: *mut camellia_context);
}
extern "C" {
    #[link_name = "mbedtls_camellia_free"]
    pub fn camellia_free(ctx: *mut camellia_context);
}
extern "C" {
    #[link_name = "mbedtls_camellia_setkey_enc"]
    pub fn camellia_setkey_enc(
        ctx: *mut camellia_context,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_camellia_setkey_dec"]
    pub fn camellia_setkey_dec(
        ctx: *mut camellia_context,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_camellia_crypt_ecb"]
    pub fn camellia_crypt_ecb(
        ctx: *mut camellia_context,
        mode: raw_types::c_int,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_camellia_crypt_cbc"]
    pub fn camellia_crypt_cbc(
        ctx: *mut camellia_context,
        mode: raw_types::c_int,
        length: usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_camellia_crypt_cfb128"]
    pub fn camellia_crypt_cfb128(
        ctx: *mut camellia_context,
        mode: raw_types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_camellia_crypt_ctr"]
    pub fn camellia_crypt_ctr(
        ctx: *mut camellia_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut raw_types::c_uchar,
        stream_block: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_camellia_self_test"]
    pub fn camellia_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct blowfish_context {
    pub P: [u32; 18usize],
    pub S: [[u32; 256usize]; 4usize],
}
#[test]
fn bindgen_test_layout_blowfish_context() {
    assert_eq!(
        ::core::mem::size_of::<blowfish_context>(),
        4168usize,
        concat!("Size of: ", stringify!(blowfish_context))
    );
    assert_eq!(
        ::core::mem::align_of::<blowfish_context>(),
        4usize,
        concat!("Alignment of ", stringify!(blowfish_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blowfish_context>())).P as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(blowfish_context),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<blowfish_context>())).S as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(blowfish_context),
            "::",
            stringify!(S)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_blowfish_init"]
    pub fn blowfish_init(ctx: *mut blowfish_context);
}
extern "C" {
    #[link_name = "mbedtls_blowfish_free"]
    pub fn blowfish_free(ctx: *mut blowfish_context);
}
extern "C" {
    #[link_name = "mbedtls_blowfish_setkey"]
    pub fn blowfish_setkey(
        ctx: *mut blowfish_context,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_blowfish_crypt_ecb"]
    pub fn blowfish_crypt_ecb(
        ctx: *mut blowfish_context,
        mode: raw_types::c_int,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_blowfish_crypt_cbc"]
    pub fn blowfish_crypt_cbc(
        ctx: *mut blowfish_context,
        mode: raw_types::c_int,
        length: usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_blowfish_crypt_cfb64"]
    pub fn blowfish_crypt_cfb64(
        ctx: *mut blowfish_context,
        mode: raw_types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_blowfish_crypt_ctr"]
    pub fn blowfish_crypt_ctr(
        ctx: *mut blowfish_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut raw_types::c_uchar,
        stream_block: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_base64_encode"]
    pub fn base64_encode(
        dst: *mut raw_types::c_uchar,
        dlen: usize,
        olen: *mut usize,
        src: *const raw_types::c_uchar,
        slen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_base64_decode"]
    pub fn base64_decode(
        dst: *mut raw_types::c_uchar,
        dlen: usize,
        olen: *mut usize,
        src: *const raw_types::c_uchar,
        slen: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_base64_self_test"]
    pub fn base64_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_len"]
    pub fn asn1_write_len(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_tag"]
    pub fn asn1_write_tag(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        tag: raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_raw_buffer"]
    pub fn asn1_write_raw_buffer(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        buf: *const raw_types::c_uchar,
        size: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_mpi"]
    pub fn asn1_write_mpi(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        X: *const mpi,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_null"]
    pub fn asn1_write_null(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_oid"]
    pub fn asn1_write_oid(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        oid: *const raw_types::c_char,
        oid_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_algorithm_identifier"]
    pub fn asn1_write_algorithm_identifier(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        oid: *const raw_types::c_char,
        oid_len: usize,
        par_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_bool"]
    pub fn asn1_write_bool(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        boolean: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_int"]
    pub fn asn1_write_int(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        val: raw_types::c_int,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_tagged_string"]
    pub fn asn1_write_tagged_string(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        tag: raw_types::c_int,
        text: *const raw_types::c_char,
        text_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_printable_string"]
    pub fn asn1_write_printable_string(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        text: *const raw_types::c_char,
        text_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_utf8_string"]
    pub fn asn1_write_utf8_string(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        text: *const raw_types::c_char,
        text_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_ia5_string"]
    pub fn asn1_write_ia5_string(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        text: *const raw_types::c_char,
        text_len: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_bitstring"]
    pub fn asn1_write_bitstring(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        buf: *const raw_types::c_uchar,
        bits: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_write_octet_string"]
    pub fn asn1_write_octet_string(
        p: *mut *mut raw_types::c_uchar,
        start: *mut raw_types::c_uchar,
        buf: *const raw_types::c_uchar,
        size: usize,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_asn1_store_named_data"]
    pub fn asn1_store_named_data(
        list: *mut *mut asn1_named_data,
        oid: *const raw_types::c_char,
        oid_len: usize,
        val: *const raw_types::c_uchar,
        val_len: usize,
    ) -> *mut asn1_named_data;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct aria_context {
    pub nr: raw_types::c_uchar,
    pub rk: [[u32; 4usize]; 17usize],
}
#[test]
fn bindgen_test_layout_aria_context() {
    assert_eq!(
        ::core::mem::size_of::<aria_context>(),
        276usize,
        concat!("Size of: ", stringify!(aria_context))
    );
    assert_eq!(
        ::core::mem::align_of::<aria_context>(),
        4usize,
        concat!("Alignment of ", stringify!(aria_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aria_context>())).nr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(aria_context),
            "::",
            stringify!(nr)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<aria_context>())).rk as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(aria_context),
            "::",
            stringify!(rk)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_aria_init"]
    pub fn aria_init(ctx: *mut aria_context);
}
extern "C" {
    #[link_name = "mbedtls_aria_free"]
    pub fn aria_free(ctx: *mut aria_context);
}
extern "C" {
    #[link_name = "mbedtls_aria_setkey_enc"]
    pub fn aria_setkey_enc(
        ctx: *mut aria_context,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aria_setkey_dec"]
    pub fn aria_setkey_dec(
        ctx: *mut aria_context,
        key: *const raw_types::c_uchar,
        keybits: raw_types::c_uint,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aria_crypt_ecb"]
    pub fn aria_crypt_ecb(
        ctx: *mut aria_context,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aria_crypt_cbc"]
    pub fn aria_crypt_cbc(
        ctx: *mut aria_context,
        mode: raw_types::c_int,
        length: usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aria_crypt_cfb128"]
    pub fn aria_crypt_cfb128(
        ctx: *mut aria_context,
        mode: raw_types::c_int,
        length: usize,
        iv_off: *mut usize,
        iv: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aria_crypt_ctr"]
    pub fn aria_crypt_ctr(
        ctx: *mut aria_context,
        length: usize,
        nc_off: *mut usize,
        nonce_counter: *mut raw_types::c_uchar,
        stream_block: *mut raw_types::c_uchar,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aria_self_test"]
    pub fn aria_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct arc4_context {
    pub x: raw_types::c_int,
    pub y: raw_types::c_int,
    pub m: [raw_types::c_uchar; 256usize],
}
#[test]
fn bindgen_test_layout_arc4_context() {
    assert_eq!(
        ::core::mem::size_of::<arc4_context>(),
        264usize,
        concat!("Size of: ", stringify!(arc4_context))
    );
    assert_eq!(
        ::core::mem::align_of::<arc4_context>(),
        4usize,
        concat!("Alignment of ", stringify!(arc4_context))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arc4_context>())).x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(arc4_context),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arc4_context>())).y as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(arc4_context),
            "::",
            stringify!(y)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<arc4_context>())).m as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(arc4_context),
            "::",
            stringify!(m)
        )
    );
}
extern "C" {
    #[link_name = "mbedtls_arc4_init"]
    pub fn arc4_init(ctx: *mut arc4_context);
}
extern "C" {
    #[link_name = "mbedtls_arc4_free"]
    pub fn arc4_free(ctx: *mut arc4_context);
}
extern "C" {
    #[link_name = "mbedtls_arc4_setup"]
    pub fn arc4_setup(
        ctx: *mut arc4_context,
        key: *const raw_types::c_uchar,
        keylen: raw_types::c_uint,
    );
}
extern "C" {
    #[link_name = "mbedtls_arc4_crypt"]
    pub fn arc4_crypt(
        ctx: *mut arc4_context,
        length: usize,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_arc4_self_test"]
    pub fn arc4_self_test(verbose: raw_types::c_int) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aesni_has_support"]
    pub fn aesni_has_support(what: raw_types::c_uint) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aesni_crypt_ecb"]
    pub fn aesni_crypt_ecb(
        ctx: *mut aes_context,
        mode: raw_types::c_int,
        input: *const raw_types::c_uchar,
        output: *mut raw_types::c_uchar,
    ) -> raw_types::c_int;
}
extern "C" {
    #[link_name = "mbedtls_aesni_gcm_mult"]
    pub fn aesni_gcm_mult(
        c: *mut raw_types::c_uchar,
        a: *const raw_types::c_uchar,
        b: *const raw_types::c_uchar,
    );
}
extern "C" {
    #[link_name = "mbedtls_aesni_inverse_key"]
    pub fn aesni_inverse_key(
        invkey: *mut raw_types::c_uchar,
        fwdkey: *const raw_types::c_uchar,
        nr: raw_types::c_int,
    );
}
extern "C" {
    #[link_name = "mbedtls_aesni_setkey_enc"]
    pub fn aesni_setkey_enc(
        rk: *mut raw_types::c_uchar,
        key: *const raw_types::c_uchar,
        bits: usize,
    ) -> raw_types::c_int;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: raw_types::c_uint,
    pub fp_offset: raw_types::c_uint,
    pub overflow_arg_area: *mut raw_types::c_void,
    pub reg_save_area: *mut raw_types::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::core::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::core::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::core::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::core::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
use ::types::*;
